/*********************************************************************************************************************
* STC32G Opensourec Library 即（STC32G 开源库）是一个基于官方 SDK 接口的第三方开源库
* Copyright (c) 2022 SEEKFREE 逐飞科技
*
* 本文件是STC 开源库的一部分
*
* STC32G 开源库 是免费软件
* 您可以根据自由软件基金会发布的 GPL（GNU General Public License，即 GNU通用公共许可证）的条款
* 即 GPL 的第3版（即 GPL3.0）或（您选择的）任何后来的版本，重新发布和/或修改它
*
* 本开源库的发布是希望它能发挥作用，但并未对其作任何的保证
* 甚至没有隐含的适销性或适合特定用途的保证
* 更多细节请参见 GPL
*
* 您应该在收到本开源库的同时收到一份 GPL 的副本
* 如果没有，请参阅<https://www.gnu.org/licenses/>
*
* 额外注明：
* 本开源库使用 GPL3.0 开源许可证协议 以上许可申明为译文版本
* 许可申明英文版在 libraries/doc 文件夹下的 GPL3_permission_statement.txt 文件中
* 许可证副本在 libraries 文件夹下 即该文件夹下的 LICENSE 文件
* 欢迎各位使用并传播本程序 但修改内容时必须保留逐飞科技的版权声明（即本声明）
*
* 文件名称          
* 公司名称          成都逐飞科技有限公司
* 版本信息          查看 libraries/doc 文件夹内 version 文件 版本说明
* 开发环境          MDK FOR C251
* 适用平台          STC32G
* 店铺链接          https://seekfree.taobao.com/
*
* 修改记录
* 日期              作者           备注
* 2024-08-01        大W            first version
********************************************************************************************************************/

#include "zf_common_clock.h"
#include "zf_driver_eeprom.h"
#include "zf_driver_delay.h"

//-------------------------------------------------------------------------------------------------------------------
//  @brief      EEPROM触发操作，
//  @param
//  @return     void
//  Sample usage:       		内部使用用户无需关心
//-------------------------------------------------------------------------------------------------------------------
void eeprom_trig(void)
{

    IAP_TRIG = 0x5A;
    IAP_TRIG = 0xA5;                    //先送5AH，再送A5H到IAP触发寄存器，每次都需要如此
    //送完A5H后，IAP命令立即被触发启动
    //CPU等待IAP完成后，才会继续执行程序。
    _nop_();   //由于STC32G是多级流水线的指令系统，触发命令后建议加4个NOP，保证IAP_DATA的数据完成准备
    _nop_();
    _nop_();
    _nop_();

}


//-------------------------------------------------------------------------------------------------------------------
//  @brief      初始化EEPROM
//  @param      NULL
//  @return     void
//  Sample usage:
//-------------------------------------------------------------------------------------------------------------------
void iap_init(void)
{
    IAP_CONTR = 0x80;	 	//使能EEPROM操作
    iap_set_tps();			//设置擦除等待时间
}

//-------------------------------------------------------------------------------------------------------------------
//  @brief      关闭EEPROM
//  @param      NULL
//  @return     void
//  Sample usage:
//-------------------------------------------------------------------------------------------------------------------
void iap_idle(void)
{
    IAP_CONTR = 0;			//失能EEPROM操作
}


//-------------------------------------------------------------------------------------------------------------------
//  @brief      获取EEPROM操作失败状态位，需要软件清零
//  @param      NULL
//  @return     void
//  Sample usage:
//								操作失败返回1;
//-------------------------------------------------------------------------------------------------------------------
uint8 iap_get_cmd_state(void)
{
    return ((IAP_CONTR & 0x01) == 0x01);
}


//-------------------------------------------------------------------------------------------------------------------
//  @brief      设置IAP等待时间
//  @param      NULL
//  @return     void
//  Sample usage:
//-------------------------------------------------------------------------------------------------------------------
void iap_set_tps(void)
{
    uint8 write_time;
    write_time = (system_clock / 1000000) ;
    IAP_TPS = write_time + 1;
}

//-------------------------------------------------------------------------------------------------------------------
// 函数简介     EEPROM读一个字节
// 参数说明     addr 		需要读的地址
// 返回参数     uint8		读取到的值
//          
// 使用示例  
//          
//-------------------------------------------------------------------------------------------------------------------
uint8 iap_read_byte(uint32 addr)
{
	uint8 temp;
	bit flag = 0;
	flag = EA;
	EA = 0;
	
    IAP_CMD = 1; 				//设置 IAP 读命令

	IAP_ADDRL = addr; 		//设置 IAP 低地址
	IAP_ADDRH = addr >> 8; 	//设置 IAP 高地址
	IAP_ADDRE = addr >> 16;	//设置 IAP 最高地址
	eeprom_trig();
	temp = IAP_DATA; 		//读 IAP 数据

    EA = flag;
	return temp;
}

//-------------------------------------------------------------------------------------------------------------------
// 函数简介     EEPROM写一个字节
// 参数说明     addr 		需要读的地址
// 返回参数     uint8		读取到的值
//          
// 使用示例  
//          
//-------------------------------------------------------------------------------------------------------------------
void iap_write_byte(uint32 addr, uint8 byte)
{
	bit flag = 0;

	flag = EA;
	EA = 0;

	IAP_CMD = 2; 			// 设置 IAP 写命令

	IAP_ADDRL = addr; 		// 设置 IAP 低地址
	IAP_ADDRH = addr >> 8; 	// 设置 IAP 高地址
	IAP_ADDRE = addr >> 16;	// 设置 IAP 最高地址
	IAP_DATA = byte; 		// 写 IAP 数据

	eeprom_trig();

	EA = flag;
}
	
//-------------------------------------------------------------------------------------------------------------------
//  @brief      EEPROM读取多个字节
//  @param      addr			需要读取的eeprom地址
//  @param      *buf			需要读取的数据地址
//  @param      len				需要读取的数据长度
//  @return     void
//  Sample usage:               uint8 str[10];
//								iap_read_bytes(0x00,str,10);
//								将0x00-0x0A地址中的数据，读取到str中。
//-------------------------------------------------------------------------------------------------------------------
void iap_read_buff(uint32 addr, uint8 *buf, uint16 len)
{
    while(len--)
    {
        *buf++ = iap_read_byte(addr); 		//读 IAP 数据
        addr++;
    }
}


//-------------------------------------------------------------------------------------------------------------------
//  @brief      EEPROM写多个字节
//  @param      addr			需要写的eeprom地址
//  @param      *buf			需要写的数据地址
//  @param      len				需要写的数据长度
//  @return     void
//  Sample usage:       		iap_write_bytes(0x00,(uint8 *)"0123456789",10);
//								将"0123456789"写入0x00-0x0A地址中;
//-------------------------------------------------------------------------------------------------------------------
void iap_write_buff(uint32 addr, uint8 *buf, uint16 len)
{
	while(len--)
    {
        iap_write_byte(addr, *buf); 		//读 IAP 数据
        addr++;
		buf++;
    }
}



//-------------------------------------------------------------------------------------------------------------------
//  @brief      EEPROM擦除目标地址所在的一页（1扇区/512字节）
//  @param      addr			需要写的eeprom地址
//  @return     void
//  Sample usage:       		iap_erase_page(0x20);
//								擦除0x00-0x200的数据
//-------------------------------------------------------------------------------------------------------------------
void iap_erase_page(uint32 addr)
{
	bit flag = 0;

	flag = EA;
	EA = 0;
    IAP_CMD = 3; 				//设置 IAP 擦除命令
    IAP_ADDRL = addr; 			//设置 IAP 低地址
    IAP_ADDRH = addr >> 8;  	//设置 IAP 高地址
    IAP_ADDRE = addr >> 16;		//设置 IAP 最高地址
    eeprom_trig();
    
   	EA = flag;
    system_delay_ms(10);		//擦除1扇区(512字节)：约4-6ms
}



//-------------------------------------------------------------------------------------------------------------------
//  @brief      扩展EEPROM写多个字节(无需擦除)
//  @param      addr			需要写的eeprom地址
//  @param      *buf			需要写的数据地址
//  @param      len				需要写的数据长度
//  @return     void
//  Sample usage:       		extern_iap_write_bytes(0x0000,(uint8 *)"0123456789",10);
//								将"0123456789"写入0x00-0x0A地址中;
//	@note：						不要跨扇区使用。
//								addr地址：0-511为一个扇区,512-1023为一个扇区，1024-1535为一个扇区，依次类推。
//-------------------------------------------------------------------------------------------------------------------
void extern_iap_write_buff(uint16 addr, uint8 *buf, uint16 len)
{
    uint8 temp[512] = {0};
    uint16 i;
    
    for(i = 0; i < 512 ; i++)	temp[i] = 0;						//清0
    
    iap_read_buff(addr & 0xFE00, temp, 512);						//读取
    
    for(i = 0; i < len; i++)	temp[(addr & 0x1FF) + i] = buf[i];	//改
    
    iap_erase_page(addr);											//擦除
    iap_write_buff(addr & 0xFE00, temp, 512);					//写入
}


