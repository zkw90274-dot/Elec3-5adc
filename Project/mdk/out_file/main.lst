C251 COMPILER V5.60.0,  main                                                               18/01/26  23:10:20  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\out_file\main.obj
COMPILER INVOKED BY: E:\Tools\keil5\Keil_v5\C251\BIN\C251.EXE ..\user\main.c LARGE NOALIAS WARNINGLEVEL(3) OPTIMIZE(SIZE
                    -) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_dri
                    -ver;..\user;..\code) DEBUG PRINT(.\out_file\main.lst) TABS(2) OBJECT(.\out_file\main.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * STC32G Opensourec Library 即（STC32G 开源库）是一个基于官方 SDK 接口的第三方开源
             -
    3          * Copyright (c) 2022 SEEKFREE 逐飞科技
    4          *
    5          * 本文件是STC 开源库的一部分
    6          *
    7          * STC32G 开源库 是免费软件
    8          * 您可以根据自由软件基金会发布的 GPL（GNU General Public License，即 GNU通用公共许
             -可证）的条款
    9          * 即 GPL 的第3版（即 GPL3.0）或（您选择的）任何后来的版本，重新发布和/或修
             -它
   10          *
   11          * 本开源库的发布是希望它能发挥作用，但并未对其作任何的保证
   12          * 甚至没有隐含的适销性或适合特定用途的保证
   13          * 更多细节请参见 GPL
   14          *
   15          * 您应该在收到本开源库的同时收到一份 GPL 的副本
   16          * 如果没有，请参阅<https://www.gnu.org/licenses/>
   17          *
   18          * 额外注明：
   19          * 本开源库使用 GPL3.0 开源许可证协议 以上许可申明为译文版本
   20          * 许可申明英文版在 libraries/doc 文件夹下的 GPL3_permission_statement.txt 文件中
   21          * 许可证副本在 libraries 文件夹下 即该文件夹下的 LICENSE 文件
   22          * 欢迎各位使用并传播本程序 但修改内容时必须保留逐飞科技的版权声明（即本
             -声明）
   23          *
   24          * 文件名称
   25          * 公司名称          成都逐飞科技有限公司
   26          * 版本信息          查看 libraries/doc 文件夹内 version 文件 版本说明
   27          * 开发环境          MDK FOR C251
   28          * 适用平台          STC32G
   29          * 店铺链接          https://seekfree.taobao.com/
   30          *
   31          * 修改记录
   32          * 日期              作者           备注
   33          * 2024-08-01        大W            first version
   34          *********************************************************************************************************
             -***********/
   35          
   36          #include "zf_common_headfile.h"
   37          #include "../code/adc.h"
   38          #include "../code/normalization.h"
   39          #include "../code/encoder.h"
   40          #include "../code/IMU.h"
   41          #include "../code/pid.h"
   42          
   43          
   44          #define PIT_CH_1                          (TIM1_PIT)                 // 使用的周期中断编号 如
             -修改 需要同步对应修改周期中断编号与 isr.c 中的调用
   45          #define PIT_CH_2                          (TIM2_PIT)                 // 使用的周期中断编号 如
             -修改 需要同步对应修改周期中断编号与 isr.c 中的调用
   46          
   47          void pit_handler_1(void);
   48          void pit_handler_2(void);
   49          
C251 COMPILER V5.60.0,  main                                                               18/01/26  23:10:20  PAGE 2   

   50          float left_target = 0;                    //左轮目标值
   51          float right_target = 0;                 //右轮目标值
   52          uint8 imu_state = 0;                                          // IMU初始化状态
   53          
   54          // PD控制变量
   55          float position_error = 0.0f;                                  // 位置误差
   56          float pd_correction = 0.0f;                                  // PD方向环修正值
   57          
   58          void main()
   59          {
   60   1          clock_init(SYSTEM_CLOCK_30M);
   61   1          debug_init();
   62   1      
   63   1          Lcd_Init();
   64   1          key_init();
   65   1          Motor_Init();
   66   1          Adc_All_Init();
   67   1          Encoder_Init();
   68   1      
   69   1          // IMU660RB初始化
   70   1          imu_state = imu_init();
   71   1          if(imu_state == 0)
   72   1          {
   73   2              printf("IMU init success!\r\n");
   74   2          }
   75   1          else
   76   1          {
   77   2              printf("IMU init failed!\r\n");
   78   2          }
   79   1      
   80   1        //差比和差系数初始化
   81   1      //  SDSD_init(&SDSD,1.0,1.0,1.0);
   82   1      
   83   1      // PID初始化 (Kp, Ki, Kd 参数需要根据实际情况调试)
   84   1      //    pid_init(&pid_motor_left,1.7, 0.22, 0.2);           // 左电机PID参数
   85   1      //    pid_init(&pid_motor_right, 1.7, 0.1, 0.0);        // 右电机PID参数
   86   1      //  pid_init(&pid_SDSD,1.0,0,0);                //SDSD的PID参数
   87   1      
   88   1          // PD方向环+角速度环初始化 (参数需要根据实际情况调试)
   89   1          // Kp=2.5, Kd=0.8 (方向环) | Kp_gyro=1.2, Kd_gyro=0.3 (角速度环)
   90   1          pd_init(&pd_direction, 2.5f, 0.8f, 1.2f, 0.3f);
   91   1      
   92   1      // 设置目标速度 (单位: 编码器计数值每5ms)
   93   1      //    pid_set_target(&pid_motor_left, left_target);             // 左电机目标速度
   94   1      //    pid_set_target(&pid_motor_right, right_target);           // 右电机目标速度
   95   1      //
   96   1      //  //设置预期差值
   97   1      //  pid_set_target(&pid_SDSD,0);
   98   1      
   99   1      // 此处编写用户代码 例如外设初始化代码等
  100   1          tim1_irq_handler = pit_handler_1;             //重写tim0中断处理函数
  101   1          tim2_irq_handler = pit_handler_2;             //重写tim0中断处理函数
  102   1      
  103   1          pit_ms_init(PIT_CH_1,10);                   // 初始化 PIT 为周期中断 10ms 周期
  104   1          pit_ms_init(PIT_CH_2,50);                   // 初始化 PIT 为周期中断 10ms 周期
  105   1      
  106   1          while(1)
  107   1          {
  108   2              // 此处编写需要循环执行的代码
  109   2      
  110   2              // 获取ADC值 (使用快速去极值平均滤波 - 推荐)
  111   2              Adc_Getval_Fast();
  112   2              Normalization();
  113   2      
  114   2              // 打印归一化后的ADC值
  115   2              printf("ADC: %d,%d,%d,%d,%d\r\n",
C251 COMPILER V5.60.0,  main                                                               18/01/26  23:10:20  PAGE 3   

  116   2                     adc_normalized_list[0],
  117   2                     adc_normalized_list[1],
  118   2                     adc_normalized_list[2],
  119   2                     adc_normalized_list[3],
  120   2                     adc_normalized_list[4]);
  121   2      
  122   2              // 打印编码器数据
  123   2              printf("Encoder: R=%d, L=%d\r\n", encoder_data_dir_R, encoder_data_dir_L);
  124   2      
  125   2              // 打印IMU欧拉角数据
  126   2              printf("IMU: Roll=%.2f, Pitch=%.2f, Yaw=%.2f\r\n",
  127   2                     imu.euler.roll, imu.euler.pitch, imu.euler.yaw);
  128   2      
  129   2              // 延时避免打印过快
  130   2              system_delay_ms(100);
  131   2          }
  132   1      }
  133          //-------------------------------------------------------------------------------------------------------
             -------------
  134          // 函数简介     PIT 的周期中断处理函数 这个函数将在 PIT 对应的定时器中断调用
             - 详见 isr.c
  135          // 参数说明     void
  136          // 返回参数     void
  137          // 使用示例     pit_handler();
  138          // 备注信息     10ms周期中断，处理编码器采集和电机控制
  139          //-------------------------------------------------------------------------------------------------------
             -------------
  140          void pit_handler_1 (void)
  141          {
  142   1          uint8 sensor_valid;  // 传感器有效标志
  143   1      
  144   1          // 使用滤波后的编码器获取函数 (一阶IIR低通滤波)
  145   1          Encoder_Get_Filtered();
  146   1      
  147   1          // ========== ADC有效性判断 ==========
  148   1          // 检查中间传感器(通道2)是否在有效范围内
  149   1          // adc_normalized_list[2]: 0=赛道最左, 25=赛道中心, 50=赛道最右
  150   1          sensor_valid = 1;
  151   1      
  152   1          // 判断1: 检查传感器是否全黑(可能脱离赛道)
  153   1          if(adc_normalized_list[2] > 48 &&
  154   1             adc_normalized_list[1] > 48 &&
  155   1             adc_normalized_list[3] > 48)
  156   1          {
  157   2              sensor_valid = 0;  // 赛道丢失
  158   2          }
  159   1      
  160   1          // 判断2: 检查传感器是否全白(可能起飞或传感器故障)
  161   1          if(adc_normalized_list[2] < 2 &&
  162   1             adc_normalized_list[1] < 2 &&
  163   1             adc_normalized_list[3] < 2)
  164   1          {
  165   2              sensor_valid = 0;  // 传感器异常
  166   2          }
  167   1      
  168   1          // 计算位置误差 (中心位置为25)
  169   1          position_error = (float)adc_normalized_list[2] - 25.0f;
  170   1      
  171   1          // ========== PD方向环+角速度环组合控制 ==========
  172   1          if(sensor_valid)
  173   1          {
  174   2              // 传感器正常，使用PD控制
  175   2              pd_correction = pd_direction_gyro_loop(position_error);
  176   2          }
  177   1          else
  178   1          {
C251 COMPILER V5.60.0,  main                                                               18/01/26  23:10:20  PAGE 4   

  179   2              // 传感器异常，保持上一次的修正值或使用IMU角速度保持直行
  180   2              // 方案1: 保持上一次值(简单但可能有延迟)
  181   2              // pd_correction = pd_correction;  // 保持不变
  182   2      
  183   2              // 方案2: 使用角速度反馈保持直行(推荐)
  184   2              pd_correction = -imu.gyro_z * 0.5f;  // 简单的角速度负反馈
  185   2          }
  186   1      
  187   1          // 电机PID控制 (PD方向环修正值叠加到编码器输入)
  188   1          motor_pid_control(encoder_data_dir_L + pd_correction, encoder_data_dir_R - pd_correction);
  189   1      }
  190          
  191          //-------------------------------------------------------------------------------------------------------
             -------------
  192          // 函数简介     PIT 的周期中断处理函数 这个函数将在 PIT 对应的定时器中断调用
             - 详见 isr.c
  193          // 参数说明     void
  194          // 返回参数     void
  195          // 使用示例     pit_handler();
  196          //-------------------------------------------------------------------------------------------------------
             -------------
  197          void pit_handler_2 (void)
  198          {
  199   1        imu_update();
  200   1      
  201   1      
  202   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       674     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        17     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       166     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
