C251 COMPILER V5.60.0,  zf_device_dl1b                                                     08/01/26  02:12:47  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_device_dl1b
OBJECT MODULE PLACED IN .\out_file\zf_device_dl1b.obj
COMPILER INVOKED BY: E:\Tools\keil5\Keil_v5\C251\BIN\C251.EXE ..\..\libraries\zf_device\zf_device_dl1b.c LARGE NOALIAS W
                    -ARNINGLEVEL(3) OPTIMIZE(SIZE) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_d
                    -evice;..\..\libraries\zf_driver;..\user;..\code) DEBUG PRINT(.\out_file\zf_device_dl1b.lst) TABS(2) OBJECT(.\out_file\zf
                    -_device_dl1b.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * STC32G Opensourec Library å³ï¼ˆSTC32G å¼€æºåº“ï¼‰æ˜¯ä¸€ä¸ªåŸºäºå®˜æ–¹ SDK æ¥å£çš„ç¬¬ä¸‰æ–¹å¼€æºåº
             -“
    3          * Copyright (c) 2022 SEEKFREE é€é£ç§‘æŠ€
    4          *
    5          * æœ¬æ–‡ä»¶æ˜¯STC å¼€æºåº“çš„ä¸€éƒ¨åˆ†
    6          *
    7          * STC32G å¼€æºåº“ æ˜¯å…è´¹è½¯ä»¶
    8          * æ‚¨å¯ä»¥æ ¹æ®è‡ªç”±è½¯ä»¶åŸºé‡‘ä¼šå‘å¸ƒçš„ GPLï¼ˆGNU General Public Licenseï¼Œå³ GNUé€šç”¨å…¬å…±è®¸
             -å¯è¯ï¼‰çš„æ¡æ¬¾
    9          * å³ GPL çš„ç¬¬3ç‰ˆï¼ˆå³ GPL3.0ï¼‰æˆ–ï¼ˆæ‚¨é€‰æ‹©çš„ï¼‰ä»»ä½•åæ¥çš„ç‰ˆæœ¬ï¼Œé‡æ–°å‘å¸ƒå’Œ/æˆ–ä¿®æ”
             -¹å®ƒ
   10          *
   11          * æœ¬å¼€æºåº“çš„å‘å¸ƒæ˜¯å¸Œæœ›å®ƒèƒ½å‘æŒ¥ä½œç”¨ï¼Œä½†å¹¶æœªå¯¹å…¶ä½œä»»ä½•çš„ä¿è¯
   12          * ç”šè‡³æ²¡æœ‰éšå«çš„é€‚é”€æ€§æˆ–é€‚åˆç‰¹å®šç”¨é€”çš„ä¿è¯
   13          * æ›´å¤šç»†èŠ‚è¯·å‚è§ GPL
   14          *
   15          * æ‚¨åº”è¯¥åœ¨æ”¶åˆ°æœ¬å¼€æºåº“çš„åŒæ—¶æ”¶åˆ°ä¸€ä»½ GPL çš„å‰¯æœ¬
   16          * å¦‚æœæ²¡æœ‰ï¼Œè¯·å‚é˜…<https://www.gnu.org/licenses/>
   17          *
   18          * é¢å¤–æ³¨æ˜ï¼š
   19          * æœ¬å¼€æºåº“ä½¿ç”¨ GPL3.0 å¼€æºè®¸å¯è¯åè®® ä»¥ä¸Šè®¸å¯ç”³æ˜ä¸ºè¯‘æ–‡ç‰ˆæœ¬
   20          * è®¸å¯ç”³æ˜è‹±æ–‡ç‰ˆåœ¨ libraries/doc æ–‡ä»¶å¤¹ä¸‹çš„ GPL3_permission_statement.txt æ–‡ä»¶ä¸­
   21          * è®¸å¯è¯å‰¯æœ¬åœ¨ libraries æ–‡ä»¶å¤¹ä¸‹ å³è¯¥æ–‡ä»¶å¤¹ä¸‹çš„ LICENSE æ–‡ä»¶
   22          * æ¬¢è¿å„ä½ä½¿ç”¨å¹¶ä¼ æ’­æœ¬ç¨‹åº ä½†ä¿®æ”¹å†…å®¹æ—¶å¿…é¡»ä¿ç•™é€é£ç§‘æŠ€çš„ç‰ˆæƒå£°æ˜ï¼ˆå³æœ¬
             -å£°æ˜ï¼‰
   23          *
   24          * æ–‡ä»¶åç§°          
   25          * å…¬å¸åç§°          æˆéƒ½é€é£ç§‘æŠ€æœ‰é™å…¬å¸
   26          * ç‰ˆæœ¬ä¿¡æ¯          æŸ¥çœ‹ libraries/doc æ–‡ä»¶å¤¹å†… version æ–‡ä»¶ ç‰ˆæœ¬è¯´æ˜
   27          * å¼€å‘ç¯å¢ƒ          MDK FOR C251
   28          * é€‚ç”¨å¹³å°          STC32G
   29          * åº—é“ºé“¾æ¥          https://seekfree.taobao.com/
   30          *
   31          * ä¿®æ”¹è®°å½•
   32          * æ—¥æœŸ              ä½œè€…           å¤‡æ³¨
   33          * 2024-08-01        å¤§W            first version
   34          *********************************************************************************************************
             -***********/
   35          /********************************************************************************************************
             -*************
   36          * æ¥çº¿å®šä¹‰ï¼š
   37          *                   ------------------------------------
   38          *                   æ¨¡å—ç®¡è„š            å•ç‰‡æœºç®¡è„š
   39          *                   SCL                 æŸ¥çœ‹ zf_device_dl1b.h ä¸­ DL1B_SCL_PIN  å®å®šä¹‰
   40          *                   SDA                 æŸ¥çœ‹ zf_device_dl1b.h ä¸­ DL1B_SDA_PIN  å®å®šä¹‰
   41          *                   XS                  æŸ¥çœ‹ zf_device_dl1b.h ä¸­ DL1B_XS_PIN   å®å®šä¹‰
   42          *                   VCC                 5V ç”µæº
   43          *                   GND                 ç”µæºåœ°
   44          *                   ------------------------------------
   45          *********************************************************************************************************
             -***********/
   46          
   47          #include "zf_common_debug.h"
   48          
C251 COMPILER V5.60.0,  zf_device_dl1b                                                     08/01/26  02:12:47  PAGE 2   

   49          #include "zf_driver_delay.h"
   50          #include "zf_driver_exti.h"
   51          #include "zf_driver_soft_iic.h"
   52          
   53          #include "zf_device_dl1b.h"
   54          #include "zf_device_config.h"
   55          #include "zf_device_type.h"
   56          
   57          #pragma warning disable = 177
   58          #pragma warning disable = 183
   59          
   60          static uint8 dl1b_init_flag = 0;
   61          uint8 dl1b_finsh_flag = 0;
   62          uint16 dl1b_distance_mm = 8192;
   63          
   64          #if (DL1B_USE_INTERFACE==SOFT_IIC) 
   65            static soft_iic_info_struct dl1b_iic_struct;
   66            #define dl1b_transfer_8bit_array(tdata, tlen, rdata, rlen)      (soft_iic_transfer_8bit_array(&dl1b_iic_
             -struct, (tdata), (tlen), (rdata), (rlen)))
   67          #elif (DL1B_USE_INTERFACE==HARDWARE_IIC)
                 #define dl1b_transfer_8bit_array(tdata, tlen, rdata, rlen)      (iic_transfer_8bit_array(DL1B_IIC, DL1B_
             -DEV_ADDR, (tdata), (tlen), (rdata), (rlen)))
               #endif
   70          
   71          //-------------------------------------------------------------------------------------------------------
             -------------
   72          // å‡½æ•°ç®€ä»‹     è¿”å›ä»¥æ¯«ç±³ä¸ºå•ä½çš„èŒƒå›´è¯»æ•°
   73          // å‚æ•°è¯´æ˜     void
   74          // è¿”å›å‚æ•°     void
   75          // ä½¿ç”¨ç¤ºä¾‹     dl1b_get_distance();
   76          // å¤‡æ³¨ä¿¡æ¯     åœ¨å¼€å§‹å•æ¬¡å°„ç¨‹æµ‹é‡åä¹Ÿè°ƒç”¨æ­¤å‡½æ•°
   77          //-------------------------------------------------------------------------------------------------------
             -------------
   78          void dl1b_get_distance (void)
   79          {
   80   1          if(dl1b_init_flag)
   81   1          {
   82   2              uint8 data_buffer[3];
   83   2              int16 dl1b_distance_temp = 0;
   84   2              
   85   2              data_buffer[0] = DL1B_GPIO__TIO_HV_STATUS >> 8;
   86   2              data_buffer[1] = DL1B_GPIO__TIO_HV_STATUS & 0xFF;
   87   2              dl1b_transfer_8bit_array(data_buffer, 2, &data_buffer[2], 1);
   88   2              
   89   2              if(data_buffer[2])
   90   2              {
   91   3              
   92   3                  data_buffer[0] = DL1B_SYSTEM__INTERRUPT_CLEAR >> 8;
   93   3                  data_buffer[1] = DL1B_SYSTEM__INTERRUPT_CLEAR & 0xFF;
   94   3                  data_buffer[2] = 0x01;
   95   3                  dl1b_transfer_8bit_array(data_buffer, 3, data_buffer, 0);// clear Interrupt
   96   3                  
   97   3                  data_buffer[0] = DL1B_RESULT__RANGE_STATUS >> 8;
   98   3                  data_buffer[1] = DL1B_RESULT__RANGE_STATUS & 0xFF;
   99   3                  dl1b_transfer_8bit_array(data_buffer, 2, &data_buffer[2], 1);
  100   3                  
  101   3                  if(0x89 == data_buffer[2])
  102   3                  {
  103   4                      data_buffer[0] = DL1B_RESULT__FINAL_CROSSTALK_CORRECTED_RANGE_MM_SD0 >> 8;
  104   4                      data_buffer[1] = DL1B_RESULT__FINAL_CROSSTALK_CORRECTED_RANGE_MM_SD0 & 0xFF;
  105   4                      dl1b_transfer_8bit_array(data_buffer, 2, data_buffer, 2);
  106   4                      dl1b_distance_temp = data_buffer[0];
  107   4                      dl1b_distance_temp = (dl1b_distance_temp << 8) | data_buffer[1];
  108   4                      
  109   4                      if(dl1b_distance_temp > 4000 || dl1b_distance_temp < 0)
  110   4                      {
C251 COMPILER V5.60.0,  zf_device_dl1b                                                     08/01/26  02:12:47  PAGE 3   

  111   5                          dl1b_distance_mm = 8192;
  112   5                          dl1b_finsh_flag = 0;
  113   5                      }
  114   4                      else
  115   4                      {
  116   5                          dl1b_distance_mm = dl1b_distance_temp;
  117   5                          dl1b_finsh_flag = 1;
  118   5                      }
  119   4                  }
  120   3                  else
  121   3                  {
  122   4                      dl1b_distance_mm = 8192;
  123   4                      dl1b_finsh_flag = 0;
  124   4                  }
  125   3              }
  126   2              else
  127   2              {
  128   3                  dl1b_distance_mm = 8192;
  129   3                  dl1b_finsh_flag = 0;
  130   3              }
  131   2          }
  132   1      }
  133          
  134          //-------------------------------------------------------------------------------------------------------
             -------------
  135          // å‡½æ•°ç®€ä»‹     DL1B INT ä¸­æ–­å“åº”å¤„ç†å‡½æ•°
  136          // å‚æ•°è¯´æ˜     void
  137          // è¿”å›å‚æ•°     void
  138          // ä½¿ç”¨ç¤ºä¾‹     dl1b_int_handler();
  139          // å¤‡æ³¨ä¿¡æ¯     æœ¬å‡½æ•°éœ€è¦åœ¨ DL1B_INT_PIN å¯¹åº”çš„å¤–éƒ¨ä¸­æ–­å¤„ç†å‡½æ•°ä¸­è°ƒç”¨
  140          //-------------------------------------------------------------------------------------------------------
             -------------
  141          void dl1b_int_handler (void)
  142          {
  143   1      #if DL1B_INT_ENABLE
                   dl1b_get_distance();
               #endif
  146   1      }
  147          
  148          //-------------------------------------------------------------------------------------------------------
             -------------
  149          // å‡½æ•°ç®€ä»‹     åˆå§‹åŒ– DL1B
  150          // å‚æ•°è¯´æ˜     void
  151          // è¿”å›å‚æ•°     uint8           1-åˆå§‹åŒ–å¤±è´¥ 0-åˆå§‹åŒ–æˆåŠŸ
  152          // ä½¿ç”¨ç¤ºä¾‹     dl1b_init();
  153          // å¤‡æ³¨ä¿¡æ¯
  154          //-------------------------------------------------------------------------------------------------------
             -------------
  155          uint8 dl1b_init (void)
  156          {
  157   1          uint8   return_state    = 0;
  158   1      //    uint8   data_buffer[2 + sizeof(dl1b_config_file)];
  159   1      //    uint16  time_out_count  = 0;
  160   1      //    
  161   1      //#if DL1B_USE_INTERFACE
  162   1      //    soft_iic_init(&dl1b_iic_struct, DL1B_DEV_ADDR, DL1B_SOFT_IIC_DELAY, DL1B_SCL_PIN, DL1B_SDA_PIN);
  163   1      //#else
  164   1      //    iic_init(DL1B_IIC, DL1B_DEV_ADDR, DL1B_IIC_SPEED, DL1B_SCL_PIN, DL1B_SDA_PIN);
  165   1      //#endif
  166   1      //    
  167   1      //#if DL1B_XS_ENABLE
  168   1      //    gpio_init(DL1B_XS_PIN, GPO, GPIO_HIGH, GPO_PUSH_PULL);
  169   1      //#endif
  170   1      //    
  171   1      //    do
  172   1      //    {
C251 COMPILER V5.60.0,  zf_device_dl1b                                                     08/01/26  02:12:47  PAGE 4   

  173   1      //    
  174   1      //#if DL1B_XS_ENABLE
  175   1      //        system_delay_ms(50);
  176   1      //        gpio_low(DL1B_XS_PIN);
  177   1      //        system_delay_ms(10);
  178   1      //        gpio_high(DL1B_XS_PIN);
  179   1      //        system_delay_ms(50);
  180   1      //#endif
  181   1      //        
  182   1      //        data_buffer[0] = DL1B_FIRMWARE__SYSTEM_STATUS >> 8;
  183   1      //        data_buffer[1] = DL1B_FIRMWARE__SYSTEM_STATUS & 0xFF;
  184   1      //        dl1b_transfer_8bit_array(data_buffer, 2, &data_buffer[2], 1);
  185   1      //        return_state = (0x01 == (data_buffer[2] & 0x01)) ? (0) : (1);
  186   1      //        
  187   1      //        if(1 == return_state)
  188   1      //        {
  189   1      //            break;
  190   1      //        }
  191   1      //        
  192   1      //        data_buffer[0] = DL1B_I2C_SLAVE__DEVICE_ADDRESS >> 8;
  193   1      //        data_buffer[1] = DL1B_I2C_SLAVE__DEVICE_ADDRESS & 0xFF;
  194   1      //        
  195   1      //        memcpy(&data_buffer[2], (uint8 *)dl1b_config_file, sizeof(dl1b_config_file));
  196   1      //        dl1b_transfer_8bit_array(data_buffer, 2 + sizeof(dl1b_config_file), data_buffer, 0);
  197   1      //        
  198   1      //        while(1)
  199   1      //        {
  200   1      //            data_buffer[0] = DL1B_GPIO__TIO_HV_STATUS >> 8;
  201   1      //            data_buffer[1] = DL1B_GPIO__TIO_HV_STATUS & 0xFF;
  202   1      //            dl1b_transfer_8bit_array(data_buffer, 2, &data_buffer[2], 1);
  203   1      //            
  204   1      //            if(0x00 == (data_buffer[2] & 0x01))
  205   1      //            {
  206   1      //                time_out_count = 0;
  207   1      //                break;
  208   1      //            }
  209   1      //            
  210   1      //            if(DL1B_TIMEOUT_COUNT < time_out_count ++)
  211   1      //            {
  212   1      //                return_state = 1;
  213   1      //                break;
  214   1      //            }
  215   1      //            
  216   1      //            system_delay_ms(1);
  217   1      //        }
  218   1      //        
  219   1      //        dl1b_init_flag = 1;
  220   1      //        
  221   1      //#if DL1B_INT_ENABLE
  222   1      //        exti_init(DL1B_INT_PIN, EXTI_TRIGGER_FALLING);
  223   1      //        dl1b_int_handler();
  224   1      //        dl1b_finsh_flag = 0;
  225   1      //#endif
  226   1      //        set_tof_type(TOF_DL1B, dl1b_int_handler);
  227   1      //    }
  228   1      //    while(0);
  229   1      //    
  230   1          return return_state;
  231   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       407     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
C251 COMPILER V5.60.0,  zf_device_dl1b                                                     08/01/26  02:12:47  PAGE 5   

  pdata size           =    ------     ------
  xdata size           =        13          3
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        19     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
