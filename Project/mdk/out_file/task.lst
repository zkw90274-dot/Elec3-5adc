C251 COMPILER V5.60.0,  task                                                               18/01/26  23:59:59  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE task
OBJECT MODULE PLACED IN .\out_file\task.obj
COMPILER INVOKED BY: E:\Tools\keil5\Keil_v5\C251\BIN\C251.EXE ..\code\task.c LARGE NOALIAS WARNINGLEVEL(3) OPTIMIZE(SIZE
                    -) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_dri
                    -ver;..\user;..\code) DEBUG PRINT(.\out_file\task.lst) TABS(2) OBJECT(.\out_file\task.obj) 

stmt  level    source

    1          #include "task.h"
    2          
    3          //-------------------------------------------------------------------------------------------------------
             -------------
    4          // ÂáΩÊï∞ÁÆÄ‰ªã     Ê£ÄÊü•ADC‰º†ÊÑüÂô®ÊúâÊïàÊÄß
    5          // ÂèÇÊï∞ËØ¥Êòé     void
    6          // ËøîÂõûÂèÇÊï∞     uint8           1-‰º†ÊÑüÂô®ÊúâÊïà 0-‰º†ÊÑüÂô®Êó†Êïà
    7          // ‰ΩøÁî®Á§∫‰æã     uint8 valid = sensor_check_valid();
    8          // Â§áÊ≥®‰ø°ÊÅØ     Ê£ÄÊü•‰º†ÊÑüÂô®ÊòØÂê¶ÂÖ®ÈªëÊàñÂÖ®ÁôΩÔºåÂà§Êñ≠‰º†ÊÑüÂô®Êï∞ÊçÆÊòØÂê¶ÂèØÁî®
    9          //-------------------------------------------------------------------------------------------------------
             -------------
   10          uint8 sensor_check_valid(void)
   11          {
   12   1          uint8 sensor_valid;
   13   1      
   14   1          sensor_valid = 1;
   15   1      
   16   1          // Âà§Êñ≠1: Ê£ÄÊü•‰º†ÊÑüÂô®ÊòØÂê¶ÂÖ®Èªë(ÂèØËÉΩËÑ±Á¶ªËµõÈÅì)
   17   1          if(adc_normalized_list[2] > 48 &&
   18   1             adc_normalized_list[1] > 48 &&
   19   1             adc_normalized_list[3] > 48)
   20   1          {
   21   2              sensor_valid = 0;  // ËµõÈÅì‰∏¢Â§±
   22   2          }
   23   1      
   24   1          // Âà§Êñ≠2: Ê£ÄÊü•‰º†ÊÑüÂô®ÊòØÂê¶ÂÖ®ÁôΩ(ÂèØËÉΩËµ∑È£ûÊàñ‰º†ÊÑüÂô®ÊïÖÈöú)
   25   1          if(adc_normalized_list[2] < 2 &&
   26   1             adc_normalized_list[1] < 2 &&
   27   1             adc_normalized_list[3] < 2)
   28   1          {
   29   2              sensor_valid = 0;  // ‰º†ÊÑüÂô®ÂºÇÂ∏∏
   30   2          }
   31   1      
   32   1          return sensor_valid;
   33   1      }
   34          
   35          //-------------------------------------------------------------------------------------------------------
             -------------
   36          // ÂáΩÊï∞ÁÆÄ‰ªã     ËÆ°ÁÆó‰ΩçÁΩÆËØØÂ∑Æ
   37          // ÂèÇÊï∞ËØ¥Êòé     void
   38          // ËøîÂõûÂèÇÊï∞     float           ‰ΩçÁΩÆËØØÂ∑Æ(‰∏≠ÂøÉ‰∏∫0)
   39          // ‰ΩøÁî®Á§∫‰æã     float err = position_error_calc();
   40          // Â§áÊ≥®‰ø°ÊÅØ     ËÆ°ÁÆó‰∏≠Èó¥‰º†ÊÑüÂô®Áõ∏ÂØπ‰∏≠ÂøÉÁöÑÂÅèÂ∑Æ
   41          //              adc_normalized_list[2]: 0=ËµõÈÅìÊúÄÂ∑¶, 25=ËµõÈÅì‰∏≠ÂøÉ, 50=ËµõÈÅìÊúÄÂè≥
   42          //              ËøîÂõûÂÄº: Ë¥üÊï∞=ÂÅèÂ∑¶, Ê≠£Êï∞=ÂÅèÂè≥, 0=Â±Ö‰∏≠
   43          //-------------------------------------------------------------------------------------------------------
             -------------
   44          float position_error_calc(void)
   45          {
   46   1          float error;
   47   1      
   48   1          error = (float)adc_normalized_list[2] - 25.0f;
   49   1      
   50   1          return error;
   51   1      }
   52          
   53          //-------------------------------------------------------------------------------------------------------
C251 COMPILER V5.60.0,  task                                                               18/01/26  23:59:59  PAGE 2   

             -------------
   54          // ÂáΩÊï∞ÁÆÄ‰ªã     SDSDÊéßÂà∂(Â∏¶‰º†ÊÑüÂô®Âà§Êñ≠)
   55          // ÂèÇÊï∞ËØ¥Êòé     void
   56          // ËøîÂõûÂèÇÊï∞     float           ÁîµÊú∫Â∑ÆÈÄü‰øÆÊ≠£ÂÄº
   57          // ‰ΩøÁî®Á§∫‰æã     float correction = sdsd_control_with_sensor_check();
   58          // Â§áÊ≥®‰ø°ÊÅØ     ‰ΩøÁî®SDSDÁÆóÊ≥ïËÆ°ÁÆóÂÅèÂ∑ÆÔºåÈÄöËøáPIDËæìÂá∫ÁîµÊú∫Â∑ÆÈÄü‰øÆÊ≠£ÂÄº
   59          //              ÊéßÂà∂ÊµÅÁ®ã: ‰º†ÊÑüÂô®Ê£ÄÊü• -> SDSDËÆ°ÁÆó -> PIDÊéßÂà∂ -> ÂºÇÂ∏∏Â§ÑÁêÜ
   60          //-------------------------------------------------------------------------------------------------------
             -------------
   61          float sdsd_control_with_sensor_check(void)
   62          {
   63   1          uint8 sensor_valid;
   64   1          float input_SDSD;
   65   1          float output_SDSD;
   66   1      
   67   1          // Ê£ÄÊü•‰º†ÊÑüÂô®ÊúâÊïàÊÄß
   68   1          sensor_valid = sensor_check_valid();
   69   1      
   70   1          if(sensor_valid)
   71   1          {
   72   2              // ‰º†ÊÑüÂô®Ê≠£Â∏∏Ôºå‰ΩøÁî®SDSDËÆ°ÁÆó
   73   2              input_SDSD = SDSD_calculate(&SDSD);
   74   2              output_SDSD = pid_calc_position(&pid_SDSD, input_SDSD);
   75   2          }
   76   1          else
   77   1          {
   78   2              // ‰º†ÊÑüÂô®ÂºÇÂ∏∏Ôºå‰øùÊåÅ‰∏ä‰∏ÄÊ¨°ÁöÑPIDËæìÂá∫
   79   2              output_SDSD = pid_SDSD.out;
   80   2          }
   81   1      
   82   1          return output_SDSD;
   83   1      }
   84          
   85          //-------------------------------------------------------------------------------------------------------
             -------------
   86          // ÂáΩÊï∞ÁÆÄ‰ªã     PDÊñπÂêëÁéØ+ËßíÈÄüÂ∫¶ÁéØÊéßÂà∂(Â∏¶‰º†ÊÑüÂô®Âà§Êñ≠)
   87          // ÂèÇÊï∞ËØ¥Êòé     void
   88          // ËøîÂõûÂèÇÊï∞     float           ÁîµÊú∫Â∑ÆÈÄü‰øÆÊ≠£ÂÄº
   89          // ‰ΩøÁî®Á§∫‰æã     float correction = pd_control_with_sensor_check();
   90          // Â§áÊ≥®‰ø°ÊÅØ     Ëá™Âä®Ê£ÄÊü•‰º†ÊÑüÂô®ÊúâÊïàÊÄßÔºå‰º†ÊÑüÂô®ÂºÇÂ∏∏Êó∂‰ΩøÁî®IMUËßíÈÄüÂ∫¶ÂèçÈ¶à‰øùÊåÅÁõ¥Ë
             -°å
   91          //              ÊéßÂà∂ÊµÅÁ®ã: ‰º†ÊÑüÂô®Ê£ÄÊü• -> ‰ΩçÁΩÆËØØÂ∑ÆËÆ°ÁÆó -> PDÊéßÂà∂ -> ÂºÇÂ∏∏Â§ÑÁêÜ
   92          //-------------------------------------------------------------------------------------------------------
             -------------
   93          float pd_control_with_sensor_check(void)
   94          {
   95   1          uint8 sensor_valid;
   96   1          float position_error;
   97   1          float correction;
   98   1      
   99   1          // Ê£ÄÊü•‰º†ÊÑüÂô®ÊúâÊïàÊÄß
  100   1          sensor_valid = sensor_check_valid();
  101   1      
  102   1          // ËÆ°ÁÆó‰ΩçÁΩÆËØØÂ∑Æ
  103   1          position_error = position_error_calc();
  104   1      
  105   1          // PDÊñπÂêëÁéØ+ËßíÈÄüÂ∫¶ÁéØÁªÑÂêàÊéßÂà∂
  106   1          if(sensor_valid)
  107   1          {
  108   2              // ‰º†ÊÑüÂô®Ê≠£Â∏∏Ôºå‰ΩøÁî®PDÊéßÂà∂
  109   2              correction = pd_direction_gyro_loop(position_error);
  110   2          }
  111   1          else
  112   1          {
  113   2              // ‰º†ÊÑüÂô®ÂºÇÂ∏∏Ôºå‰ΩøÁî®IMUËßíÈÄüÂ∫¶ÂèçÈ¶à‰øùÊåÅÁõ¥Ë°å
  114   2              correction = -imu.gyro_z * 0.5f;  // ÁÆÄÂçïÁöÑËßíÈÄüÂ∫¶Ë¥üÂèçÈ¶à
C251 COMPILER V5.60.0,  task                                                               18/01/26  23:59:59  PAGE 3   

  115   2          }
  116   1      
  117   1          return correction;
  118   1      }
  119          
  120          //-------------------------------------------------------------------------------------------------------
             -------------
  121          // ÂáΩÊï∞ÁÆÄ‰ªã     ÁîµÊú∫ÊéßÂà∂‰ªªÂä°(10msÂë®ÊúüË∞ÉÁî®)
  122          // ÂèÇÊï∞ËØ¥Êòé     void
  123          // ËøîÂõûÂèÇÊï∞     void
  124          // ‰ΩøÁî®Á§∫‰æã     motor_control_task();
  125          // Â§áÊ≥®‰ø°ÊÅØ     Âú®10msÂÆöÊó∂‰∏≠Êñ≠‰∏≠Ë∞ÉÁî®ÔºåÂÆåÊàêÁºñÁ†ÅÂô®ÈááÈõÜÂíåÁîµÊú∫ÊéßÂà∂
  126          //              ÂäüËÉΩ: ÁºñÁ†ÅÂô®ÈááÈõÜ -> ÊéßÂà∂ÁÆóÊ≥ïÈÄâÊã© -> ÁîµÊú∫ËæìÂá∫
  127          //              ÊéßÂà∂Ê®°ÂºèÁî± CONTROL_MODE_CURRENT ÂÆèÂÆö‰πâÂÜ≥ÂÆö
  128          //-------------------------------------------------------------------------------------------------------
             -------------
  129          void motor_control_task(void)
  130          {
  131   1          float correction;
  132   1      
  133   1          // ‰ΩøÁî®Êª§Ê≥¢ÂêéÁöÑÁºñÁ†ÅÂô®Ëé∑ÂèñÂáΩÊï∞ (‰∏ÄÈò∂IIR‰ΩéÈÄöÊª§Ê≥¢)
  134   1          Encoder_Get_Filtered();
  135   1      
  136   1          // Ê†πÊçÆÊéßÂà∂Ê®°ÂºèÈÄâÊã©‰∏çÂêåÁöÑÊéßÂà∂ÁÆóÊ≥ï
  137   1      #if(CONTROL_MODE_CURRENT == CONTROL_MODE_SDSD)
  138   1          // Ê®°Âºè0: SDSDÊéßÂà∂
  139   1          correction = sdsd_control_with_sensor_check();
  140   1      
  141   1      #elif(CONTROL_MODE_CURRENT == CONTROL_MODE_PD_DIRECTION)
                   // Ê®°Âºè1: PDÊñπÂêëÁéØ+ËßíÈÄüÂ∫¶ÁéØÊéßÂà∂
                   correction = pd_control_with_sensor_check();
               
               #else
                   #error "Êú™ÂÆö‰πâÁöÑÊéßÂà∂Ê®°ÂºèÔºåËØ∑Âú® task.h ‰∏≠ËÆæÁΩÆ CONTROL_MODE_CURRENT"
               #endif
  148   1      
  149   1          // ÁîµÊú∫PIDÊéßÂà∂ (‰øÆÊ≠£ÂÄºÂè†Âä†Âà∞ÁºñÁ†ÅÂô®ËæìÂÖ•)
  150   1          motor_pid_control(encoder_data_dir_L + correction, encoder_data_dir_R - correction);
  151   1      }
  152          
  153          //-------------------------------------------------------------------------------------------------------
             -------------
  154          // ÂáΩÊï∞ÁÆÄ‰ªã     IMUÊõ¥Êñ∞‰ªªÂä°(50msÂë®ÊúüË∞ÉÁî®)
  155          // ÂèÇÊï∞ËØ¥Êòé     void
  156          // ËøîÂõûÂèÇÊï∞     void
  157          // ‰ΩøÁî®Á§∫‰æã     imu_update_task();
  158          // Â§áÊ≥®‰ø°ÊÅØ     Âú®50msÂÆöÊó∂‰∏≠Êñ≠‰∏≠Ë∞ÉÁî®ÔºåÊõ¥Êñ∞IMUÊï∞ÊçÆ
  159          //              ÂäüËÉΩ: Ëé∑ÂèñIMUÂéüÂßãÊï∞ÊçÆ -> ÂõõÂÖÉÊï∞Ëß£ÁÆó -> Ê¨ßÊãâËßíÊõ¥Êñ∞
  160          //-------------------------------------------------------------------------------------------------------
             -------------
  161          void imu_update_task(void)
  162          {
  163   1          imu_update();
  164   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       255     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------          1
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
C251 COMPILER V5.60.0,  task                                                               18/01/26  23:59:59  PAGE 4   

  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
