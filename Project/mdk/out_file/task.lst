C251 COMPILER V5.60.0,  task                                                               21/01/26  02:20:57  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE task
OBJECT MODULE PLACED IN .\out_file\task.obj
COMPILER INVOKED BY: E:\Tools\keil5\Keil_v5\C251\BIN\C251.EXE ..\code\task.c LARGE NOALIAS WARNINGLEVEL(3) OPTIMIZE(SIZE
                    -) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_dri
                    -ver;..\user;..\code) DEBUG PRINT(.\out_file\task.lst) TABS(2) OBJECT(.\out_file\task.obj) 

stmt  level    source

    1          #include "task.h"
    2          
    3          //-------------------------------------------------------------------------------------------------------
             -------------
    4          // ÂÖ®Â±ÄÂèòÈáè
    5          //-------------------------------------------------------------------------------------------------------
             -------------
    6          static uint8 current_control_mode = CONTROL_MODE_PID_ONLY;  // ÂΩìÂâçÊéßÂà∂Ê®°Âºè
    7          
    8          //-------------------------------------------------------------------------------------------------------
             -------------
    9          // ÂáΩÊï∞ÁÆÄ‰ªã     Ê£ÄÊü•ADC‰º†ÊÑüÂô®ÊúâÊïàÊÄß
   10          // ÂèÇÊï∞ËØ¥Êòé     void
   11          // ËøîÂõûÂèÇÊï∞     uint8           1-‰º†ÊÑüÂô®ÊúâÊïà 0-‰º†ÊÑüÂô®Êó†Êïà
   12          // ‰ΩøÁî®Á§∫‰æã     uint8 valid = sensor_check_valid();
   13          // Â§áÊ≥®‰ø°ÊÅØ     Ê£ÄÊü•‰º†ÊÑüÂô®ÊòØÂê¶ÂÖ®ÈªëÊàñÂÖ®ÁôΩÔºåÂà§Êñ≠‰º†ÊÑüÂô®Êï∞ÊçÆÊòØÂê¶ÂèØÁî®
   14          //-------------------------------------------------------------------------------------------------------
             -------------
   15          uint8 sensor_check_valid(void)
   16          {
   17   1          uint8 sensor_valid;
   18   1      
   19   1          sensor_valid = 1;
   20   1      
   21   1          // Âà§Êñ≠1: Ê£ÄÊü•‰º†ÊÑüÂô®ÊòØÂê¶ÂÖ®Èªë(ÂèØËÉΩËÑ±Á¶ªËµõÈÅì)
   22   1          if(adc_normalized_list[2] > 48 &&
   23   1             adc_normalized_list[1] > 48 &&
   24   1             adc_normalized_list[3] > 48)
   25   1          {
   26   2              sensor_valid = 0;  // ËµõÈÅì‰∏¢Â§±
   27   2          }
   28   1      
   29   1          // Âà§Êñ≠2: Ê£ÄÊü•‰º†ÊÑüÂô®ÊòØÂê¶ÂÖ®ÁôΩ(ÂèØËÉΩËµ∑È£ûÊàñ‰º†ÊÑüÂô®ÊïÖÈöú)
   30   1          if(adc_normalized_list[2] < 2 &&
   31   1             adc_normalized_list[1] < 2 &&
   32   1             adc_normalized_list[3] < 2)
   33   1          {
   34   2              sensor_valid = 0;  // ‰º†ÊÑüÂô®ÂºÇÂ∏∏
   35   2          }
   36   1      
   37   1          return sensor_valid;
   38   1      }
   39          
   40          //-------------------------------------------------------------------------------------------------------
             -------------
   41          // ÂáΩÊï∞ÁÆÄ‰ªã     ËÆ°ÁÆó‰ΩçÁΩÆËØØÂ∑Æ
   42          // ÂèÇÊï∞ËØ¥Êòé     void
   43          // ËøîÂõûÂèÇÊï∞     float           ‰ΩçÁΩÆËØØÂ∑Æ(‰∏≠ÂøÉ‰∏∫0)
   44          // ‰ΩøÁî®Á§∫‰æã     float err = position_error_calc();
   45          // Â§áÊ≥®‰ø°ÊÅØ     ËÆ°ÁÆó‰∏≠Èó¥‰º†ÊÑüÂô®Áõ∏ÂØπ‰∏≠ÂøÉÁöÑÂÅèÂ∑Æ
   46          //              adc_normalized_list[2]: 0=ËµõÈÅìÊúÄÂ∑¶, 25=ËµõÈÅì‰∏≠ÂøÉ, 50=ËµõÈÅìÊúÄÂè≥
   47          //              ËøîÂõûÂÄº: Ë¥üÊï∞=ÂÅèÂ∑¶, Ê≠£Êï∞=ÂÅèÂè≥, 0=Â±Ö‰∏≠
   48          //-------------------------------------------------------------------------------------------------------
             -------------
   49          float position_error_calc(void)
   50          {
   51   1          float error;
C251 COMPILER V5.60.0,  task                                                               21/01/26  02:20:57  PAGE 2   

   52   1      
   53   1          error = (float)adc_normalized_list[2] - 25.0f;
   54   1      
   55   1          return error;
   56   1      }
   57          
   58          //-------------------------------------------------------------------------------------------------------
             -------------
   59          // ÂáΩÊï∞ÁÆÄ‰ªã     Á∫ØPIDÈÄüÂ∫¶ÁéØÊéßÂà∂(Êó†Âæ™Ëøπ)
   60          // ÂèÇÊï∞ËØ¥Êòé     void
   61          // ËøîÂõûÂèÇÊï∞     float           ÁîµÊú∫Â∑ÆÈÄü‰øÆÊ≠£ÂÄº(ÂßãÁªà‰∏∫0)
   62          // ‰ΩøÁî®Á§∫‰æã     float correction = pid_only_control();
   63          // Â§áÊ≥®‰ø°ÊÅØ     ‰ªÖ‰ΩøÁî®ÁîµÊú∫ÈÄüÂ∫¶ÁéØPIDÔºåÊó†Âæ™ËøπÂäüËÉΩ
   64          //              Áî®‰∫éÊµãËØïÁîµÊú∫ÈÄüÂ∫¶ÁéØÊòØÂê¶Ê≠£Â∏∏Â∑•‰Ωú
   65          //-------------------------------------------------------------------------------------------------------
             -------------
   66          float pid_only_control(void)
   67          {
   68   1          // Á∫ØPIDÊ®°ÂºèÔºåÊó†Âæ™Ëøπ‰øÆÊ≠£
   69   1          return 0.0f;
   70   1      }
   71          
   72          //-------------------------------------------------------------------------------------------------------
             -------------
   73          // ÂáΩÊï∞ÁÆÄ‰ªã     SDSDÊéßÂà∂(Â∏¶‰º†ÊÑüÂô®Âà§Êñ≠)
   74          // ÂèÇÊï∞ËØ¥Êòé     void
   75          // ËøîÂõûÂèÇÊï∞     float           ÁîµÊú∫Â∑ÆÈÄü‰øÆÊ≠£ÂÄº
   76          // ‰ΩøÁî®Á§∫‰æã     float correction = sdsd_control_with_sensor_check();
   77          // Â§áÊ≥®‰ø°ÊÅØ     ‰ΩøÁî®SDSDÁÆóÊ≥ïËÆ°ÁÆóÂÅèÂ∑ÆÔºåÈÄöËøáPIDËæìÂá∫ÁîµÊú∫Â∑ÆÈÄü‰øÆÊ≠£ÂÄº
   78          //              ÊéßÂà∂ÊµÅÁ®ã: ‰º†ÊÑüÂô®Ê£ÄÊü• -> SDSDËÆ°ÁÆó -> PIDÊéßÂà∂ -> ÂºÇÂ∏∏Â§ÑÁêÜ
   79          //-------------------------------------------------------------------------------------------------------
             -------------
   80          float sdsd_control_with_sensor_check(void)
   81          {
   82   1          uint8 sensor_valid;
   83   1          float input_SDSD;
   84   1          float output_SDSD;
   85   1      
   86   1          // Ê£ÄÊü•‰º†ÊÑüÂô®ÊúâÊïàÊÄß
   87   1          sensor_valid = sensor_check_valid();
   88   1      
   89   1          if(sensor_valid)
   90   1          {
   91   2              // ‰º†ÊÑüÂô®Ê≠£Â∏∏Ôºå‰ΩøÁî®SDSDËÆ°ÁÆó
   92   2              input_SDSD = SDSD_calculate(&SDSD);
   93   2              output_SDSD = pid_calc_position(&pid_SDSD, input_SDSD);
   94   2          }
   95   1          else
   96   1          {
   97   2              // ‰º†ÊÑüÂô®ÂºÇÂ∏∏Ôºå‰øùÊåÅ‰∏ä‰∏ÄÊ¨°ÁöÑPIDËæìÂá∫
   98   2              output_SDSD = pid_SDSD.out;
   99   2          }
  100   1      
  101   1          return output_SDSD;
  102   1      }
  103          
  104          //-------------------------------------------------------------------------------------------------------
             -------------
  105          // ÂáΩÊï∞ÁÆÄ‰ªã     PDÊñπÂêëÁéØ+ËßíÈÄüÂ∫¶ÁéØÊéßÂà∂(Â∏¶‰º†ÊÑüÂô®Âà§Êñ≠)
  106          // ÂèÇÊï∞ËØ¥Êòé     void
  107          // ËøîÂõûÂèÇÊï∞     float           ÁîµÊú∫Â∑ÆÈÄü‰øÆÊ≠£ÂÄº
  108          // ‰ΩøÁî®Á§∫‰æã     float correction = pd_control_with_sensor_check();
  109          // Â§áÊ≥®‰ø°ÊÅØ     Ëá™Âä®Ê£ÄÊü•‰º†ÊÑüÂô®ÊúâÊïàÊÄßÔºå‰º†ÊÑüÂô®ÂºÇÂ∏∏Êó∂‰ΩøÁî®IMUËßíÈÄüÂ∫¶ÂèçÈ¶à‰øùÊåÅÁõ¥Ë
             -°å
  110          //              ÊéßÂà∂ÊµÅÁ®ã: ‰º†ÊÑüÂô®Ê£ÄÊü• -> ‰ΩçÁΩÆËØØÂ∑ÆËÆ°ÁÆó -> PDÊéßÂà∂ -> ÂºÇÂ∏∏Â§ÑÁêÜ
  111          //-------------------------------------------------------------------------------------------------------
C251 COMPILER V5.60.0,  task                                                               21/01/26  02:20:57  PAGE 3   

             -------------
  112          float pd_control_with_sensor_check(void)
  113          {
  114   1          uint8 sensor_valid;
  115   1          float position_error;
  116   1          float correction;
  117   1      
  118   1          // Ê£ÄÊü•‰º†ÊÑüÂô®ÊúâÊïàÊÄß
  119   1          sensor_valid = sensor_check_valid();
  120   1      
  121   1          // ËÆ°ÁÆó‰ΩçÁΩÆËØØÂ∑Æ
  122   1          position_error = position_error_calc();
  123   1      
  124   1          // PDÊñπÂêëÁéØ+ËßíÈÄüÂ∫¶ÁéØÁªÑÂêàÊéßÂà∂
  125   1          if(sensor_valid)
  126   1          {
  127   2              // ‰º†ÊÑüÂô®Ê≠£Â∏∏Ôºå‰ΩøÁî®PDÊéßÂà∂
  128   2              correction = pd_direction_gyro_loop(position_error);
  129   2          }
  130   1          else
  131   1          {
  132   2              // ‰º†ÊÑüÂô®ÂºÇÂ∏∏Ôºå‰ΩøÁî®IMUËßíÈÄüÂ∫¶ÂèçÈ¶à‰øùÊåÅÁõ¥Ë°å
  133   2              correction = -imu.gyro_z * 0.5f;  // ÁÆÄÂçïÁöÑËßíÈÄüÂ∫¶Ë¥üÂèçÈ¶à
  134   2          }
  135   1      
  136   1          return correction;
  137   1      }
  138          
  139          //-------------------------------------------------------------------------------------------------------
             -------------
  140          // ÂáΩÊï∞ÁÆÄ‰ªã     Ëé∑ÂèñÂΩìÂâçÊéßÂà∂Ê®°Âºè
  141          // ÂèÇÊï∞ËØ¥Êòé     void
  142          // ËøîÂõûÂèÇÊï∞     uint8           ÂΩìÂâçÊéßÂà∂Ê®°Âºè
  143          // ‰ΩøÁî®Á§∫‰æã     uint8 mode = get_control_mode();
  144          // Â§áÊ≥®‰ø°ÊÅØ     ËøîÂõûÂΩìÂâçÊéßÂà∂Ê®°ÂºèÁºñÂè∑
  145          //-------------------------------------------------------------------------------------------------------
             -------------
  146          uint8 get_control_mode(void)
  147          {
  148   1          #if(CONTROL_SELECT_METHOD == CONTROL_SELECT_METHOD_STATIC)
  149   1              return CONTROL_MODE_CURRENT;
  150   1          #else
                       return current_control_mode;
                   #endif
  153   1      }
  154          
  155          //-------------------------------------------------------------------------------------------------------
             -------------
  156          // ÂáΩÊï∞ÁÆÄ‰ªã     Ëé∑ÂèñÊéßÂà∂Ê®°ÂºèÂêçÁß∞
  157          // ÂèÇÊï∞ËØ¥Êòé     mode            ÊéßÂà∂Ê®°ÂºèÁºñÂè∑
  158          // ËøîÂõûÂèÇÊï∞     char*           Ê®°ÂºèÂêçÁß∞Â≠óÁ¨¶‰∏≤
  159          // ‰ΩøÁî®Á§∫‰æã     printf("ÂΩìÂâçÊ®°Âºè: %s\r\n", get_mode_name(get_control_mode()));
  160          // Â§áÊ≥®‰ø°ÊÅØ     ËøîÂõûÊéßÂà∂Ê®°ÂºèÁöÑ‰∏≠ÊñáÂêçÁß∞
  161          //-------------------------------------------------------------------------------------------------------
             -------------
  162          char* get_mode_name(uint8 mode)
  163          {
  164   1          switch(mode)
  165   1          {
  166   2              case CONTROL_MODE_PID_ONLY:
  167   2                  return "Á∫ØPIDÈÄüÂ∫¶ÁéØ";
  168   2              case CONTROL_MODE_SDSD:
  169   2                  return "SDSDÂæ™Ëøπ";
  170   2              case CONTROL_MODE_PD_DIRECTION:
  171   2                  return "PDÊñπÂêëÁéØ+ËßíÈÄüÂ∫¶ÁéØ";
  172   2              default:
C251 COMPILER V5.60.0,  task                                                               21/01/26  02:20:57  PAGE 4   

  173   2                  return "Êú™Áü•Ê®°Âºè";
  174   2          }
  175   1      }
  176          
  177          //-------------------------------------------------------------------------------------------------------
             -------------
  178          // ÂáΩÊï∞ÁÆÄ‰ªã     ÁîµÊú∫ÊéßÂà∂‰ªªÂä°(10msÂë®ÊúüË∞ÉÁî®)
  179          // ÂèÇÊï∞ËØ¥Êòé     void
  180          // ËøîÂõûÂèÇÊï∞     void
  181          // ‰ΩøÁî®Á§∫‰æã     motor_control_task();
  182          // Â§áÊ≥®‰ø°ÊÅØ     Âú®10msÂÆöÊó∂‰∏≠Êñ≠‰∏≠Ë∞ÉÁî®ÔºåÂÆåÊàêÁºñÁ†ÅÂô®ÈááÈõÜÂíåÁîµÊú∫ÊéßÂà∂
  183          //              ÂäüËÉΩ: ÁºñÁ†ÅÂô®ÈááÈõÜ -> ÊéßÂà∂ÁÆóÊ≥ïÈÄâÊã© -> ÁîµÊú∫ËæìÂá∫
  184          //              ÊéßÂà∂Ê®°ÂºèÁî± task.h ‰∏≠ÁöÑ CONTROL_MODE_CURRENT ÂÜ≥ÂÆö
  185          //-------------------------------------------------------------------------------------------------------
             -------------
  186          void motor_control_task(void)
  187          {
  188   1          float correction;
  189   1          uint8 mode;
  190   1      
  191   1          // ‰ΩøÁî®Êª§Ê≥¢ÂêéÁöÑÁºñÁ†ÅÂô®Ëé∑ÂèñÂáΩÊï∞ (‰∏ÄÈò∂IIR‰ΩéÈÄöÊª§Ê≥¢)
  192   1          Encoder_Get_Filtered();
  193   1      
  194   1          // Ëé∑ÂèñÂΩìÂâçÊéßÂà∂Ê®°Âºè
  195   1          mode = get_control_mode();
  196   1      
  197   1          // Ê†πÊçÆÊéßÂà∂Ê®°ÂºèÈÄâÊã©‰∏çÂêåÁöÑÊéßÂà∂ÁÆóÊ≥ï
  198   1          switch(mode)
  199   1          {
  200   2              case CONTROL_MODE_PID_ONLY:
  201   2                  // Ê®°Âºè0: Á∫ØPIDÈÄüÂ∫¶ÁéØÊéßÂà∂(Êó†Âæ™Ëøπ)
  202   2                  correction = pid_only_control();
  203   2                  break;
  204   2      
  205   2              case CONTROL_MODE_SDSD:
  206   2                  // Ê®°Âºè1: SDSDÊéßÂà∂
  207   2                  correction = sdsd_control_with_sensor_check();
  208   2                  break;
  209   2      
  210   2              case CONTROL_MODE_PD_DIRECTION:
  211   2                  // Ê®°Âºè2: PDÊñπÂêëÁéØ+ËßíÈÄüÂ∫¶ÁéØÊéßÂà∂
  212   2                  correction = pd_control_with_sensor_check();
  213   2                  break;
  214   2      
  215   2              default:
  216   2                  // ÈªòËÆ§: Á∫ØPIDÊ®°Âºè
  217   2                  correction = pid_only_control();
  218   2                  break;
  219   2          }
  220   1      
  221   1          // ÁîµÊú∫PIDÊéßÂà∂ (‰øÆÊ≠£ÂÄºÂè†Âä†Âà∞ÁºñÁ†ÅÂô®ËæìÂÖ•)
  222   1          motor_pid_control(encoder_data_dir_L + correction, encoder_data_dir_R - correction);
  223   1      }
  224          
  225          //-------------------------------------------------------------------------------------------------------
             -------------
  226          // ÂáΩÊï∞ÁÆÄ‰ªã     IMUÊõ¥Êñ∞‰ªªÂä°(50msÂë®ÊúüË∞ÉÁî®)
  227          // ÂèÇÊï∞ËØ¥Êòé     void
  228          // ËøîÂõûÂèÇÊï∞     void
  229          // ‰ΩøÁî®Á§∫‰æã     imu_update_task();
  230          // Â§áÊ≥®‰ø°ÊÅØ     Âú®50msÂÆöÊó∂‰∏≠Êñ≠‰∏≠Ë∞ÉÁî®ÔºåÊõ¥Êñ∞IMUÊï∞ÊçÆ
  231          //              ÂäüËÉΩ: Ëé∑ÂèñIMUÂéüÂßãÊï∞ÊçÆ -> ÂõõÂÖÉÊï∞Ëß£ÁÆó -> Ê¨ßÊãâËßíÊõ¥Êñ∞
  232          //-------------------------------------------------------------------------------------------------------
             -------------
  233          void imu_update_task(void)
  234          {
C251 COMPILER V5.60.0,  task                                                               21/01/26  02:20:57  PAGE 5   

  235   1          imu_update();
  236   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       344     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =         1          1
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        71     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
