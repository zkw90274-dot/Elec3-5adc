C251 COMPILER V5.60.0,  zf_driver_gpio                                                     08/01/26  02:12:46  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_driver_gpio
OBJECT MODULE PLACED IN .\out_file\zf_driver_gpio.obj
COMPILER INVOKED BY: E:\Tools\keil5\Keil_v5\C251\BIN\C251.EXE ..\..\libraries\zf_driver\zf_driver_gpio.c LARGE NOALIAS W
                    -ARNINGLEVEL(3) OPTIMIZE(SIZE) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_d
                    -evice;..\..\libraries\zf_driver;..\user;..\code) DEBUG PRINT(.\out_file\zf_driver_gpio.lst) TABS(2) OBJECT(.\out_file\zf
                    -_driver_gpio.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * STC32G Opensourec Library 即（STC32G 开源库）是一个基于官方 SDK 接口的第三方开源库
    3          * Copyright (c) 2022 SEEKFREE 逐飞科技
    4          *
    5          * 本文件是STC 开源库的一部分
    6          *
    7          * STC32G 开源库 是免费软件
    8          * 您可以根据自由软件基金会发布的 GPL（GNU General Public License，即 GNU通用公共许可证）的条款
    9          * 即 GPL 的第3版（即 GPL3.0）或（您选择的）任何后来的版本，重新发布和/或修改它
   10          *
   11          * 本开源库的发布是希望它能发挥作用，但并未对其作任何的保证
   12          * 甚至没有隐含的适销性或适合特定用途的保证
   13          * 更多细节请参见 GPL
   14          *
   15          * 您应该在收到本开源库的同时收到一份 GPL 的副本
   16          * 如果没有，请参阅<https://www.gnu.org/licenses/>
   17          *
   18          * 额外注明：
   19          * 本开源库使用 GPL3.0 开源许可证协议 以上许可申明为译文版本
   20          * 许可申明英文版在 libraries/doc 文件夹下的 GPL3_permission_statement.txt 文件中
   21          * 许可证副本在 libraries 文件夹下 即该文件夹下的 LICENSE 文件
   22          * 欢迎各位使用并传播本程序 但修改内容时必须保留逐飞科技的版权声明（即本声明）
   23          *
   24          * 文件名称          
   25          * 公司名称          成都逐飞科技有限公司
   26          * 版本信息          查看 libraries/doc 文件夹内 version 文件 版本说明
   27          * 开发环境          MDK FOR C251
   28          * 适用平台          STC32G
   29          * 店铺链接          https://seekfree.taobao.com/
   30          *
   31          * 修改记录
   32          * 日期              作者           备注
   33          * 2024-08-01        大W            first version
   34          * 2024-xx-xx        优化           精简重复逻辑，适配SFR特性
   35          *********************************************************************************************************
             -***********/
   36          
   37          #include "zf_common_debug.h"
   38          #include "zf_driver_gpio.h"
   39          
   40          
   41          // 内部使用，用户无需关心。
   42          static void gpio_set_mode(gpio_pin_enum pin, gpio_mode_enum mode)
   43          {
   44   1        #define PXPU(pin)  (*(unsigned char volatile far *)(0x7efe10 + (pin >> 4 - 1)))
   45   1      //  #define PXPD(pin)  (*(unsigned char volatile far *)(0x7efe40 + (pin >> 4 - 1)))
   46   1        
   47   1          if(GPI_FLOATING_IN == mode || GPIO_NO_PULL == mode)
   48   1          {
   49   2              PXPU(pin) &= ~(1 << (pin & 0x0F));
   50   2      //        PXPD(pin) &= ~(1 << (pin & 0x0F));
   51   2          }
   52   1      //    else if(GPI_PULL_DOWN == mode)
   53   1      //    {
   54   1      //        PXPD(pin) |= (1 << (pin & 0x0F));
C251 COMPILER V5.60.0,  zf_driver_gpio                                                     08/01/26  02:12:46  PAGE 2   

   55   1      //    }
   56   1          else if(GPI_PULL_UP == mode || GPO_PUSH_PULL == mode)
   57   1          {
   58   2              PXPU(pin) |= (1 << (pin & 0x0F));
   59   2          }
   60   1        else if(GPO_OPEN_DTAIN == mode)
   61   1        {
   62   2              // 开漏输出：操作对应端口的模式寄存器（PnM1/PnM0）
   63   2          switch(pin & 0xF0)
   64   2          {
   65   3            case IO_P00:
   66   3                      P0M1 |= (1 << (pin & 0xF));
   67   3                      P0M0 |= (1 << (pin & 0xF));
   68   3              break;
   69   3            case IO_P10:
   70   3                      P1M1 |= (1 << (pin & 0xF));
   71   3                      P1M0 |= (1 << (pin & 0xF));
   72   3              break;
   73   3            case IO_P20:
   74   3                      P2M1 |= (1 << (pin & 0xF));
   75   3                      P2M0 |= (1 << (pin & 0xF));
   76   3              break;
   77   3            case IO_P30:
   78   3                      P3M1 |= (1 << (pin & 0xF));
   79   3                      P3M0 |= (1 << (pin & 0xF));
   80   3              break;
   81   3            case IO_P40:
   82   3                      P4M1 |= (1 << (pin & 0xF));
   83   3                      P4M0 |= (1 << (pin & 0xF));
   84   3              break;
   85   3            case IO_P50:
   86   3                      P5M1 |= (1 << (pin & 0xF));
   87   3                      P5M0 |= (1 << (pin & 0xF));
   88   3              break;
   89   3            case IO_P60:
   90   3                      P6M1 |= (1 << (pin & 0xF));
   91   3                      P6M0 |= (1 << (pin & 0xF));
   92   3              break;
   93   3            case IO_P70:
   94   3                      P7M1 |= (1 << (pin & 0xF));
   95   3                      P7M0 |= (1 << (pin & 0xF));
   96   3              break;
   97   3            default:
   98   3              break; // 无效引脚
   99   3          }
  100   2        }
  101   1        else
  102   1        {
  103   2          // zf_assert(0); // 参数不匹配
  104   2        }
  105   1      }
  106          
  107          // 内部使用，用户无需关心。
  108          void gpio_set_level_speed(gpio_pin_enum pin, gpio_speed_enum speed)
  109          {
  110   1          // 提前计算引脚位和端口标志
  111   1          uint8 pin_bit = pin & 0x0F;
  112   1          uint8 port_flag = pin & 0xF0;
  113   1      
  114   1          // 根据端口标志操作对应PnSR寄存器（速度配置）
  115   1          switch(port_flag)
  116   1          {
  117   2              case IO_P00:
  118   2                  // 快速模式：清除位；低速模式：置位
  119   2                  (GPIO_SPEED_FAST == speed) ? (P0SR &= ~(1 << pin_bit)) : (P0SR |= (1 << pin_bit));
  120   2                  break;
C251 COMPILER V5.60.0,  zf_driver_gpio                                                     08/01/26  02:12:46  PAGE 3   

  121   2              case IO_P10:
  122   2                  (GPIO_SPEED_FAST == speed) ? (P1SR &= ~(1 << pin_bit)) : (P1SR |= (1 << pin_bit));
  123   2                  break;
  124   2              case IO_P20:
  125   2                  (GPIO_SPEED_FAST == speed) ? (P2SR &= ~(1 << pin_bit)) : (P2SR |= (1 << pin_bit));
  126   2                  break;
  127   2              case IO_P30:
  128   2                  (GPIO_SPEED_FAST == speed) ? (P3SR &= ~(1 << pin_bit)) : (P3SR |= (1 << pin_bit));
  129   2                  break;
  130   2              case IO_P40:
  131   2                  (GPIO_SPEED_FAST == speed) ? (P4SR &= ~(1 << pin_bit)) : (P4SR |= (1 << pin_bit));
  132   2                  break;
  133   2              case IO_P50:
  134   2                  (GPIO_SPEED_FAST == speed) ? (P5SR &= ~(1 << pin_bit)) : (P5SR |= (1 << pin_bit));
  135   2                  break;
  136   2              case IO_P60:
  137   2                  (GPIO_SPEED_FAST == speed) ? (P6SR &= ~(1 << pin_bit)) : (P6SR |= (1 << pin_bit));
  138   2                  break;
  139   2              case IO_P70:
  140   2                  (GPIO_SPEED_FAST == speed) ? (P7SR &= ~(1 << pin_bit)) : (P7SR |= (1 << pin_bit));
  141   2                  break;
  142   2              default:
  143   2                  // zf_assert(0); // 无效引脚
  144   2                  break;
  145   2          }
  146   1      }
  147          
  148          
  149          // 内部使用，用户无需关心。
  150          static void gpio_set_dir(gpio_pin_enum pin, gpio_dir_enum dir)
  151          {
  152   1          switch(pin & 0xF0)
  153   1          {
  154   2              case IO_P00:
  155   2              {
  156   3                  if(GPIO == dir || GPI == dir)
  157   3                  {
  158   4                      P0M1 &= ~(1 << (pin & 0xF));
  159   4                      P0M0 &= ~(1 << (pin & 0xF));
  160   4                  }
  161   3      //            else if(GPO_OPEN_DTAIN == dir)
  162   3      //            {
  163   3      //                P0M1 |= (1 << (pin & 0xF));
  164   3      //                P0M0 |= (1 << (pin & 0xF));
  165   3      //            }
  166   3                  else if(GPO == dir)
  167   3                  {
  168   4                      P0M1 &= ~(1 << (pin & 0xF));
  169   4                      P0M0 |= (1 << (pin & 0xF));
  170   4                  }
  171   3              }
  172   2              break;
  173   2              
  174   2              case IO_P10:
  175   2              {
  176   3                  if(GPIO == dir || GPI == dir)
  177   3                  {
  178   4                      P1M1 &= ~(1 << (pin & 0xF));
  179   4                      P1M0 &= ~(1 << (pin & 0xF));
  180   4                  }
  181   3      //            else if(GPO_OPEN_DTAIN == dir)
  182   3      //            {
  183   3      //                P1M1 |= (1 << (pin & 0xF));
  184   3      //                P1M0 |= (1 << (pin & 0xF));
  185   3      //            }
  186   3                  else if(GPO == dir)
C251 COMPILER V5.60.0,  zf_driver_gpio                                                     08/01/26  02:12:46  PAGE 4   

  187   3                  {
  188   4                      P1M1 &= ~(1 << (pin & 0xF));
  189   4                      P1M0 |= (1 << (pin & 0xF));
  190   4                  }
  191   3              }
  192   2              break;
  193   2              
  194   2              case IO_P20:
  195   2              {
  196   3                  if(GPIO == dir || GPI == dir)
  197   3                  {
  198   4                      P2M1 &= ~(1 << (pin & 0xF));
  199   4                      P2M0 &= ~(1 << (pin & 0xF));
  200   4                  }
  201   3      //            else if(GPO_OPEN_DTAIN == dir)
  202   3      //            {
  203   3      //                P2M1 |= (1 << (pin & 0xF));
  204   3      //                P2M0 |= (1 << (pin & 0xF));
  205   3      //            }
  206   3                  else if(GPO == dir)
  207   3                  {
  208   4                      P2M1 &= ~(1 << (pin & 0xF));
  209   4                      P2M0 |= (1 << (pin & 0xF));
  210   4                  }
  211   3              }
  212   2              break;
  213   2              
  214   2              case IO_P30:
  215   2              {
  216   3                  if(GPIO == dir || GPI == dir)
  217   3                  {
  218   4                      P3M1 &= ~(1 << (pin & 0xF));
  219   4                      P3M0 &= ~(1 << (pin & 0xF));
  220   4                  }
  221   3      //            else if(GPO_OPEN_DTAIN == dir)
  222   3      //            {
  223   3      //                P3M1 |= (1 << (pin & 0xF));
  224   3      //                P3M0 |= (1 << (pin & 0xF));
  225   3      //            }
  226   3                  else if(GPO == dir)
  227   3                  {
  228   4                      P3M1 &= ~(1 << (pin & 0xF));
  229   4                      P3M0 |= (1 << (pin & 0xF));
  230   4                  }
  231   3              }
  232   2              break;
  233   2              
  234   2              case IO_P40:
  235   2              {
  236   3                  if(GPIO == dir || GPI == dir)
  237   3                  {
  238   4                      P4M1 &= ~(1 << (pin & 0xF));
  239   4                      P4M0 &= ~(1 << (pin & 0xF));
  240   4                  }
  241   3      //            else if(GPO_OPEN_DTAIN == dir)
  242   3      //            {
  243   3      //                P4M1 |= (1 << (pin & 0xF));
  244   3      //                P4M0 |= (1 << (pin & 0xF));
  245   3      //            }
  246   3                  else if(GPO == dir)
  247   3                  {
  248   4                      P4M1 &= ~(1 << (pin & 0xF));
  249   4                      P4M0 |= (1 << (pin & 0xF));
  250   4                  }
  251   3              }
  252   2              break;
C251 COMPILER V5.60.0,  zf_driver_gpio                                                     08/01/26  02:12:46  PAGE 5   

  253   2              
  254   2              case IO_P50:
  255   2              {
  256   3                  if(GPIO == dir || GPI == dir)
  257   3                  {
  258   4                      P5M1 &= ~(1 << (pin & 0xF));
  259   4                      P5M0 &= ~(1 << (pin & 0xF));
  260   4                  }
  261   3      //            else if(GPO_OPEN_DTAIN == dir)
  262   3      //            {
  263   3      //                P5M1 |= (1 << (pin & 0xF));
  264   3      //                P5M0 |= (1 << (pin & 0xF));
  265   3      //            }
  266   3                  else if(GPO == dir)
  267   3                  {
  268   4                      P5M1 &= ~(1 << (pin & 0xF));
  269   4                      P5M0 |= (1 << (pin & 0xF));
  270   4                  }
  271   3              }
  272   2              break;
  273   2          
  274   2          case IO_P60:
  275   2              {
  276   3                  if(GPIO == dir || GPI == dir)
  277   3                  {
  278   4                      P6M1 &= ~(1 << (pin & 0xF));
  279   4                      P6M0 &= ~(1 << (pin & 0xF));
  280   4                  }
  281   3      //            else if(GPO_OPEN_DTAIN == dir)
  282   3      //            {
  283   3      //                P6M1 |= (1 << (pin & 0xF));
  284   3      //                P6M0 |= (1 << (pin & 0xF));
  285   3      //            }
  286   3                  else if(GPO == dir)
  287   3                  {
  288   4                      P6M1 &= ~(1 << (pin & 0xF));
  289   4                      P6M0 |= (1 << (pin & 0xF));
  290   4                  }
  291   3              }
  292   2              break;
  293   2          
  294   2          case IO_P70:
  295   2              {
  296   3                  if(GPIO == dir || GPI == dir)
  297   3                  {
  298   4                      P7M1 &= ~(1 << (pin & 0xF));
  299   4                      P7M0 &= ~(1 << (pin & 0xF));
  300   4                  }
  301   3      //            else if(GPO_OPEN_DTAIN == dir)
  302   3      //            {
  303   3      //                P7M1 |= (1 << (pin & 0xF));
  304   3      //                P7M0 |= (1 << (pin & 0xF));
  305   3      //            }
  306   3                  else if(GPO == dir)
  307   3                  {
  308   4                      P7M1 &= ~(1 << (pin & 0xF));
  309   4                      P7M0 |= (1 << (pin & 0xF));
  310   4                  }
  311   3      
  312   3              }
  313   2              break;
  314   2              
  315   2              default:
  316   2              {
  317   3            zf_assert(0);
  318   3            // 没有这个引脚
C251 COMPILER V5.60.0,  zf_driver_gpio                                                     08/01/26  02:12:46  PAGE 6   

  319   3              } break;
  320   2          }
  321   1      }
  322          
  323          //-------------------------------------------------------------------------------------------------------
             -------------
  324          // 函数简介     GPIO状态获取
  325          // 参数说明     pin         选择的引脚 (可选择范围由 zf_driver_gpio.h 内gpio_pin_enum枚举值确定)
  326          // 返回参数     uint8       0：低电平 1：高电平
  327          // 使用示例     uint8 status = gpio_get_level(IO_P00);//获取P00引脚电平
  328          //-------------------------------------------------------------------------------------------------------
             -------------
  329          uint8 gpio_get_level(gpio_pin_enum pin)
  330          {
  331   1          uint8 pin_bit = pin & 0x0F;
  332   1          uint8 port_flag = pin & 0xF0;
  333   1          uint8 status = 0;
  334   1      
  335   1          // 根据端口标志读取对应Pn寄存器
  336   1          switch(port_flag)
  337   1          {
  338   2              case IO_P00: status = P0 & (1 << pin_bit); break;
  339   2              case IO_P10: status = P1 & (1 << pin_bit); break;
  340   2              case IO_P20: status = P2 & (1 << pin_bit); break;
  341   2              case IO_P30: status = P3 & (1 << pin_bit); break;
  342   2              case IO_P40: status = P4 & (1 << pin_bit); break;
  343   2              case IO_P50: status = P5 & (1 << pin_bit); break;
  344   2              case IO_P60: status = P6 & (1 << pin_bit); break;
  345   2              case IO_P70: status = P7 & (1 << pin_bit); break;
  346   2              default: break; // 无效引脚
  347   2          }
  348   1          
  349   1          return status ? 1 : 0; // 转换为0/1返回
  350   1      }
  351          
  352          //-------------------------------------------------------------------------------------------------------
             -------------
  353          // 函数简介     GPIO输出设置
  354          // 参数说明     pin         引脚号选择的引脚 (可选择范围由 common.h 内GPIO_PIN_enum枚举值确定)
  355          // 参数说明     dat         引脚的电平状态，输出时有效 0：低电平 1：高电平
  356          // 返回参数     void
  357          // 使用示例     gpio_set_level(D0, 0);//D0输出低电平
  358          //-------------------------------------------------------------------------------------------------------
             -------------
  359          void gpio_set_level(gpio_pin_enum pin, uint8 dat)
  360          {
  361   1          uint8 pin_bit = pin & 0x0F;
  362   1          uint8 port_flag = pin & 0xF0;
  363   1      
  364   1          // 三元运算符精简置位/清零逻辑
  365   1          switch(port_flag)
  366   1          {
  367   2              case IO_P00: dat ? (P0 |= (1 << pin_bit)) : (P0 &= ~(1 << pin_bit)); break;
  368   2              case IO_P10: dat ? (P1 |= (1 << pin_bit)) : (P1 &= ~(1 << pin_bit)); break;
  369   2              case IO_P20: dat ? (P2 |= (1 << pin_bit)) : (P2 &= ~(1 << pin_bit)); break;
  370   2              case IO_P30: dat ? (P3 |= (1 << pin_bit)) : (P3 &= ~(1 << pin_bit)); break;
  371   2              case IO_P40: dat ? (P4 |= (1 << pin_bit)) : (P4 &= ~(1 << pin_bit)); break;
  372   2              case IO_P50: dat ? (P5 |= (1 << pin_bit)) : (P5 &= ~(1 << pin_bit)); break;
  373   2              case IO_P60: dat ? (P6 |= (1 << pin_bit)) : (P6 &= ~(1 << pin_bit)); break;
  374   2              case IO_P70: dat ? (P7 |= (1 << pin_bit)) : (P7 &= ~(1 << pin_bit)); break;
  375   2              default: break; // 无效引脚
  376   2          }
  377   1      }
  378          
  379          //-------------------------------------------------------------------------------------------------------
             -------------
C251 COMPILER V5.60.0,  zf_driver_gpio                                                     08/01/26  02:12:46  PAGE 7   

  380          // 函数简介     GPIO电平翻转
  381          // 参数说明     pin         引脚号选择的引脚
  382          // 返回参数     void
  383          // 使用示例     gpio_toggle_level(D0);//翻转D0电平
  384          //-------------------------------------------------------------------------------------------------------
             -------------
  385          void gpio_toggle_level(gpio_pin_enum pin)
  386          {
  387   1          // 直接调用现有函数，逻辑清晰
  388   1          gpio_set_level(pin, !gpio_get_level(pin));
  389   1      }
  390          
  391          //-------------------------------------------------------------------------------------------------------
             -------------
  392          // 函数简介     GPIO设置高阻输入
  393          // 参数说明     pin         引脚号选择的引脚
  394          // 返回参数     void
  395          // 使用示例     
  396          //-------------------------------------------------------------------------------------------------------
             -------------
  397          void gpio_set_impedance(gpio_pin_enum pin)
  398          {
  399   1          uint8 pin_bit = pin & 0x0F;
  400   1          uint8 port_flag = pin & 0xF0;
  401   1      
  402   1          // 统一高阻输入配置（PnM1置位，PnM0清零）
  403   1          switch(port_flag)
  404   1          {
  405   2              case IO_P00: P0M1 |= (1 << pin_bit); P0M0 &= ~(1 << pin_bit); break;
  406   2              case IO_P10: P1M1 |= (1 << pin_bit); P1M0 &= ~(1 << pin_bit); break;
  407   2              case IO_P20: P2M1 |= (1 << pin_bit); P2M0 &= ~(1 << pin_bit); break;
  408   2              case IO_P30: P3M1 |= (1 << pin_bit); P3M0 &= ~(1 << pin_bit); break;
  409   2              case IO_P40: P4M1 |= (1 << pin_bit); P4M0 &= ~(1 << pin_bit); break;
  410   2              case IO_P50: P5M1 |= (1 << pin_bit); P5M0 &= ~(1 << pin_bit); break;
  411   2              case IO_P60: P6M1 |= (1 << pin_bit); P6M0 &= ~(1 << pin_bit); break;
  412   2              case IO_P70: P7M1 |= (1 << pin_bit); P7M0 &= ~(1 << pin_bit); break;
  413   2              default: break; // 无效引脚
  414   2          }
  415   1      }
  416          
  417          //-------------------------------------------------------------------------------------------------------
             -------------
  418          // 函数简介     GPIO初始化
  419          // 参数说明     pin         选择的引脚
  420          // 参数说明     dir         引脚的方向   输出：GPO   输入：GPI
  421          // 参数说明     dat         引脚初始化时设置的电平状态，输出时有效
  422          // 参数说明     mode        引脚模式（上下拉/开漏等）
  423          // 返回参数     void
  424          // 使用示例     gpio_init(D0, GPO, 1, GPO_PUSH_PULL);//D0初始化为输出、高电平、推挽模式
  425          //-------------------------------------------------------------------------------------------------------
             -------------
  426          void gpio_init(gpio_pin_enum pin, gpio_dir_enum dir, const uint8 dat, gpio_mode_enum mode)
  427          {
  428   1        zf_assert(dir == (mode >> 4));
  429   1      
  430   1        if(dir == GPIO)
  431   1        {
  432   2          gpio_set_dir(pin, GPIO);
  433   2          gpio_set_mode(pin, mode);
  434   2        }
  435   1        else if(dir == GPI)
  436   1        {
  437   2          if(mode == GPI_IMPEDANCE)
  438   2          {
  439   3            gpio_set_impedance(pin);
  440   3          }
C251 COMPILER V5.60.0,  zf_driver_gpio                                                     08/01/26  02:12:46  PAGE 8   

  441   2          else
  442   2          {
  443   3            gpio_set_dir(pin, GPI);
  444   3            gpio_set_mode(pin, mode);
  445   3          }
  446   2        }
  447   1        else if(dir == GPO)
  448   1        {
  449   2          if(GPO_PUSH_PULL == mode)
  450   2          {
  451   3            gpio_set_dir(pin, GPO);
  452   3            gpio_set_mode(pin, GPI_PULL_UP);
  453   3          }
  454   2          else if(GPO_OPEN_DTAIN == mode)
  455   2          {
  456   3            gpio_set_mode(pin, GPO_OPEN_DTAIN);
  457   3          }
  458   2        }
  459   1        gpio_set_level(pin, dat);
  460   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2586     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------          3
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        43     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
