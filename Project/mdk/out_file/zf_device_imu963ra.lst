C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 08/01/26  02:12:47  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_device_imu963ra
OBJECT MODULE PLACED IN .\out_file\zf_device_imu963ra.obj
COMPILER INVOKED BY: E:\Tools\keil5\Keil_v5\C251\BIN\C251.EXE ..\..\libraries\zf_device\zf_device_imu963ra.c LARGE NOALI
                    -AS WARNINGLEVEL(3) OPTIMIZE(SIZE) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\
                    -zf_device;..\..\libraries\zf_driver;..\user;..\code) DEBUG PRINT(.\out_file\zf_device_imu963ra.lst) TABS(2) OBJECT(.\out
                    -_file\zf_device_imu963ra.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * STC32G Opensourec Library å³ï¼ˆSTC32G å¼€æºåº“ï¼‰æ˜¯ä¸€ä¸ªåŸºäºå®˜æ–¹ SDK æ¥å£çš„ç¬¬ä¸‰æ–¹å¼€æºåº
             -“
    3          * Copyright (c) 2022 SEEKFREE é€é£ç§‘æŠ€
    4          *
    5          * æœ¬æ–‡ä»¶æ˜¯STC å¼€æºåº“çš„ä¸€éƒ¨åˆ†
    6          *
    7          * STC32G å¼€æºåº“ æ˜¯å…è´¹è½¯ä»¶
    8          * æ‚¨å¯ä»¥æ ¹æ®è‡ªç”±è½¯ä»¶åŸºé‡‘ä¼šå‘å¸ƒçš„ GPLï¼ˆGNU General Public Licenseï¼Œå³ GNUé€šç”¨å…¬å…±è®¸
             -å¯è¯ï¼‰çš„æ¡æ¬¾
    9          * å³ GPL çš„ç¬¬3ç‰ˆï¼ˆå³ GPL3.0ï¼‰æˆ–ï¼ˆæ‚¨é€‰æ‹©çš„ï¼‰ä»»ä½•åæ¥çš„ç‰ˆæœ¬ï¼Œé‡æ–°å‘å¸ƒå’Œ/æˆ–ä¿®æ”
             -¹å®ƒ
   10          *
   11          * æœ¬å¼€æºåº“çš„å‘å¸ƒæ˜¯å¸Œæœ›å®ƒèƒ½å‘æŒ¥ä½œç”¨ï¼Œä½†å¹¶æœªå¯¹å…¶ä½œä»»ä½•çš„ä¿è¯
   12          * ç”šè‡³æ²¡æœ‰éšå«çš„é€‚é”€æ€§æˆ–é€‚åˆç‰¹å®šç”¨é€”çš„ä¿è¯
   13          * æ›´å¤šç»†èŠ‚è¯·å‚è§ GPL
   14          *
   15          * æ‚¨åº”è¯¥åœ¨æ”¶åˆ°æœ¬å¼€æºåº“çš„åŒæ—¶æ”¶åˆ°ä¸€ä»½ GPL çš„å‰¯æœ¬
   16          * å¦‚æœæ²¡æœ‰ï¼Œè¯·å‚é˜…<https://www.gnu.org/licenses/>
   17          *
   18          * é¢å¤–æ³¨æ˜ï¼š
   19          * æœ¬å¼€æºåº“ä½¿ç”¨ GPL3.0 å¼€æºè®¸å¯è¯åè®® ä»¥ä¸Šè®¸å¯ç”³æ˜ä¸ºè¯‘æ–‡ç‰ˆæœ¬
   20          * è®¸å¯ç”³æ˜è‹±æ–‡ç‰ˆåœ¨ libraries/doc æ–‡ä»¶å¤¹ä¸‹çš„ GPL3_permission_statement.txt æ–‡ä»¶ä¸­
   21          * è®¸å¯è¯å‰¯æœ¬åœ¨ libraries æ–‡ä»¶å¤¹ä¸‹ å³è¯¥æ–‡ä»¶å¤¹ä¸‹çš„ LICENSE æ–‡ä»¶
   22          * æ¬¢è¿å„ä½ä½¿ç”¨å¹¶ä¼ æ’­æœ¬ç¨‹åº ä½†ä¿®æ”¹å†…å®¹æ—¶å¿…é¡»ä¿ç•™é€é£ç§‘æŠ€çš„ç‰ˆæƒå£°æ˜ï¼ˆå³æœ¬
             -å£°æ˜ï¼‰
   23          *
   24          * æ–‡ä»¶åç§°          
   25          * å…¬å¸åç§°          æˆéƒ½é€é£ç§‘æŠ€æœ‰é™å…¬å¸
   26          * ç‰ˆæœ¬ä¿¡æ¯          æŸ¥çœ‹ libraries/doc æ–‡ä»¶å¤¹å†… version æ–‡ä»¶ ç‰ˆæœ¬è¯´æ˜
   27          * å¼€å‘ç¯å¢ƒ          MDK FOR C251
   28          * é€‚ç”¨å¹³å°          STC32G
   29          * åº—é“ºé“¾æ¥          https://seekfree.taobao.com/
   30          *
   31          * ä¿®æ”¹è®°å½•
   32          * æ—¥æœŸ              ä½œè€…           å¤‡æ³¨
   33          * 2024-08-01        å¤§W            first version
   34          *********************************************************************************************************
             -***********/
   35          /********************************************************************************************************
             -*************
   36          * æ¥çº¿å®šä¹‰ï¼š
   37          *                   ------------------------------------
   38          *                   æ¨¡å—ç®¡è„š            å•ç‰‡æœºç®¡è„š
   39          *                   // ç¡¬ä»¶ SPI å¼•è„š
   40          *                   SCL/SPC             æŸ¥çœ‹ zf_device_imu963ra.h ä¸­ IMU963RA_SPC_PIN å®å®šä¹‰
   41          *                   SDA/DSI             æŸ¥çœ‹ zf_device_imu963ra.h ä¸­ IMU963RA_SDI_PIN å®å®šä¹‰
   42          *                   SA0/SDO             æŸ¥çœ‹ zf_device_imu963ra.h ä¸­ IMU963RA_SDO_PIN å®å®šä¹‰
   43          *                   CS                  æŸ¥çœ‹ zf_device_imu963ra.h ä¸­ IMU963RA_CS_PIN  å®å®šä¹‰
   44          *                   VCC                 3.3Vç”µæº
   45          *                   GND                 ç”µæºåœ°
   46          *                   å…¶ä½™å¼•è„šæ‚¬ç©º
   47          *
   48          *                   // è½¯ä»¶ IIC å¼•è„š
   49          *                   SCL/SPC             æŸ¥çœ‹ zf_device_imu963ra.h ä¸­ IMU963RA_SCL_PIN å®å®šä¹‰
C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 08/01/26  02:12:47  PAGE 2   

   50          *                   SDA/DSI             æŸ¥çœ‹ zf_device_imu963ra.h ä¸­ IMU963RA_SDA_PIN å®å®šä¹‰
   51          *                   VCC                 3.3Vç”µæº
   52          *                   GND                 ç”µæºåœ°
   53          *                   å…¶ä½™å¼•è„šæ‚¬ç©º
   54          *                   ------------------------------------
   55          *********************************************************************************************************
             -***********/
   56          
   57          #include "zf_common_clock.h"
   58          #include "zf_common_debug.h"
   59          #include "zf_driver_delay.h"
   60          #include "zf_driver_spi.h"
   61          #include "zf_driver_soft_iic.h"
   62          #include "zf_driver_soft_spi.h"
   63          
   64          #include "zf_device_imu963ra.h"
   65          
   66          #pragma warning disable = 183
   67          #pragma warning disable = 177
   68          
   69          int16 imu963ra_gyro_x = 0, imu963ra_gyro_y = 0, imu963ra_gyro_z = 0;
   70          int16 imu963ra_acc_x = 0,  imu963ra_acc_y = 0,  imu963ra_acc_z = 0;
   71          int16 imu963ra_mag_x = 0,  imu963ra_mag_y = 0,  imu963ra_mag_z = 0;
   72          float imu963ra_transition_factor[3] = {4098, 14.3, 3000};
   73          
   74          
   75          #if (IMU963RA_USE_INTERFACE==HARDWARE_SPI)
                 //------------------------------------------------------------------------------------------------------
             --------------
                 // å‡½æ•°ç®€ä»‹     IMU963RA å†™å¯„å­˜å™¨
                 // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
                 // å‚æ•°è¯´æ˜     dat            æ•°æ®
                 // è¿”å›å‚æ•°     void
                 // ä½¿ç”¨ç¤ºä¾‹     imu963ra_write_acc_gyro_register(IMU963RA_SLV0_CONFIG, 0x00);
                 // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
                 //------------------------------------------------------------------------------------------------------
             --------------
                 static void imu963ra_write_acc_gyro_register(uint8 reg, uint8 dat)
                 {
                   IMU963RA_CS(0);
                   spi_write_8bit_register(IMU963RA_SPI, reg | IMU963RA_SPI_W, dat);
                   IMU963RA_CS(1);
                 }
               
                 //------------------------------------------------------------------------------------------------------
             --------------
                 // å‡½æ•°ç®€ä»‹     IMU963RA è¯»å¯„å­˜å™¨
                 // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
                 // è¿”å›å‚æ•°     uint8           æ•°æ®
                 // ä½¿ç”¨ç¤ºä¾‹     imu963ra_read_acc_gyro_register(IMU963RA_STATUS_MASTER);
                 // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
                 //------------------------------------------------------------------------------------------------------
             --------------
                 static uint8 imu963ra_read_acc_gyro_register(uint8 reg)
                 {
                   uint8 dat = 0;
                   IMU963RA_CS(0);
                   dat = spi_read_8bit_register(IMU963RA_SPI, reg | IMU963RA_SPI_R);
                   IMU963RA_CS(1);
                   return dat;
                 }
               
                 //------------------------------------------------------------------------------------------------------
             --------------
                 // å‡½æ•°ç®€ä»‹     IMU963RA è¯»æ•°æ® å†…éƒ¨è°ƒç”¨
                 // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 08/01/26  02:12:47  PAGE 3   

                 // å‚æ•°è¯´æ˜     dat            æ•°æ®ç¼“å†²åŒº
                 // å‚æ•°è¯´æ˜     len             æ•°æ®é•¿åº¦
                 // è¿”å›å‚æ•°     void
                 // ä½¿ç”¨ç¤ºä¾‹     imu963ra_read_acc_gyro_registers(IMU963RA_OUTX_L_A, dat, 6);
                 // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
                 //------------------------------------------------------------------------------------------------------
             --------------
                 static void imu963ra_read_acc_gyro_registers(uint8 reg, uint8 *dat, uint32 len)
                 {
                   IMU963RA_CS(0);
                   spi_read_8bit_registers(IMU963RA_SPI, reg | IMU963RA_SPI_R, dat, len);
                   IMU963RA_CS(1);
                 }
                 
               #elif (IMU963RA_USE_INTERFACE==SOFT_SPI)
  124            
  125            #define IMU963RA_SCK(x)       IMU963RA_SPC_PIN  = x
  126            #define IMU963RA_MOSI(x)      IMU963RA_SDI_PIN = x
  127            #define IMU963RA_CS(x)        IMU963RA_CS_PIN  = x
  128            #define IMU963RA_MISO         IMU963RA_SDO_PIN
  129          
  130            //------------------------------------------------------------------------------------------------------
             --------------
  131            //  @brief      é€šè¿‡SPIå†™ä¸€ä¸ªbyte,åŒæ—¶è¯»å–ä¸€ä¸ªbyte
  132            //  @param      byte        å‘é€çš„æ•°æ®
  133            //  @return     uint8 edata       return è¿”å›statusçŠ¶æ€
  134            //  @since      v1.0
  135            //  Sample usage:
  136            //------------------------------------------------------------------------------------------------------
             --------------
  137            static uint8 imu963ra_simspi_wr_byte(uint8 byte)
  138            {
  139   1          uint8 i;
  140   1          for(i=0; i<8; i++)
  141   1          {
  142   2            IMU963RA_SCK (0);
  143   2            IMU963RA_MOSI(byte&0x80);
  144   2            byte <<= 1;
  145   2            IMU963RA_SCK (1);
  146   2            byte |= IMU963RA_MISO;
  147   2          }
  148   1          IMU963RA_SCK (0);
  149   1          return(byte);
  150   1        }
  151            
  152            
  153            //------------------------------------------------------------------------------------------------------
             --------------
  154            //  @brief      å°†valå†™å…¥cmdå¯¹åº”çš„å¯„å­˜å™¨åœ°å€,åŒæ—¶è¿”å›statuså­—èŠ‚
  155            //  @param      cmd         å‘½ä»¤å­—
  156            //  @param      val         å¾…å†™å…¥å¯„å­˜å™¨çš„æ•°å€¼
  157            //  @since      v1.0
  158            //  Sample usage:
  159            //------------------------------------------------------------------------------------------------------
             --------------
  160            static void imu963ra_simspi_w_reg_byte(uint8 cmd, uint8 val)
  161            {
  162   1          IMU963RA_CS(0);
  163   1          cmd |= IMU963RA_SPI_W;
  164   1          imu963ra_simspi_wr_byte(cmd);
  165   1          imu963ra_simspi_wr_byte(val);
  166   1          IMU963RA_CS(1);
  167   1        }
  168          
  169            //------------------------------------------------------------------------------------------------------
             --------------
C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 08/01/26  02:12:47  PAGE 4   

  170            //  @brief      è¯»å–cmdæ‰€å¯¹åº”çš„å¯„å­˜å™¨åœ°å€
  171            //  @param      cmd         å‘½ä»¤å­—
  172            //  @param      *val        å­˜å‚¨è¯»å–çš„æ•°æ®åœ°å€
  173            //  @since      v1.0
  174            //  Sample usage:
  175            //------------------------------------------------------------------------------------------------------
             --------------
  176            static void imu963ra_simspi_r_reg_byte(uint8 cmd, uint8 *val)
  177            {
  178   1          IMU963RA_CS(0);
  179   1          cmd |= IMU963RA_SPI_R;
  180   1          imu963ra_simspi_wr_byte(cmd);
  181   1          *val = imu963ra_simspi_wr_byte(0);
  182   1          IMU963RA_CS(1);
  183   1        }
  184          
  185            //------------------------------------------------------------------------------------------------------
             --------------
  186            //  @brief      è¯»å–cmdæ‰€å¯¹åº”çš„å¯„å­˜å™¨åœ°å€
  187            //  @param      cmd         å‘½ä»¤å­—
  188            //  @param      *val        å­˜å‚¨è¯»å–çš„æ•°æ®åœ°å€
  189            //  @param      num         è¯»å–çš„æ•°é‡
  190            //  @since      v1.0
  191            //  Sample usage:
  192            //------------------------------------------------------------------------------------------------------
             --------------
  193            static void imu963ra_simspi_r_reg_bytes(uint8 cmd, uint8 *val, uint32 num)
  194            {
  195   1          cmd |= IMU963RA_SPI_R;
  196   1          imu963ra_simspi_wr_byte(cmd);
  197   1          while(num--)
  198   1          {
  199   2            *val++ = imu963ra_simspi_wr_byte(0);
  200   2          }
  201   1        }
  202          
  203            //------------------------------------------------------------------------------------------------------
             --------------
  204            // å‡½æ•°ç®€ä»‹     IMU963RA å†™å¯„å­˜å™¨
  205            // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
  206            // å‚æ•°è¯´æ˜     dat            æ•°æ®
  207            // è¿”å›å‚æ•°     void
  208            // ä½¿ç”¨ç¤ºä¾‹     imu963ra_write_acc_gyro_register(IMU963RA_SLV0_CONFIG, 0x00);
  209            // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  210            //------------------------------------------------------------------------------------------------------
             --------------
  211            static void imu963ra_write_acc_gyro_register(uint8 reg, uint8 dat)
  212            {
  213   1          IMU963RA_CS(0);
  214   1          imu963ra_simspi_w_reg_byte(reg | IMU963RA_SPI_W, dat);
  215   1          IMU963RA_CS(1);
  216   1        }
  217          
  218            //------------------------------------------------------------------------------------------------------
             --------------
  219            // å‡½æ•°ç®€ä»‹     IMU963RA è¯»å¯„å­˜å™¨
  220            // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
  221            // è¿”å›å‚æ•°     uint8 edata           æ•°æ®
  222            // ä½¿ç”¨ç¤ºä¾‹     imu963ra_read_acc_gyro_register(IMU963RA_STATUS_MASTER);
  223            // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  224            //------------------------------------------------------------------------------------------------------
             --------------
  225            static uint8 imu963ra_read_acc_gyro_register(uint8 reg)
  226            {
  227   1          uint8 dat = 0;
  228   1          IMU963RA_CS(0);
C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 08/01/26  02:12:47  PAGE 5   

  229   1          imu963ra_simspi_r_reg_byte(reg | IMU963RA_SPI_R, &dat);
  230   1          IMU963RA_CS(1);
  231   1          return dat;
  232   1        }
  233          
  234            //------------------------------------------------------------------------------------------------------
             --------------
  235            // å‡½æ•°ç®€ä»‹     IMU963RA è¯»æ•°æ® å†…éƒ¨è°ƒç”¨
  236            // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
  237            // å‚æ•°è¯´æ˜     dat            æ•°æ®ç¼“å†²åŒº
  238            // å‚æ•°è¯´æ˜     len             æ•°æ®é•¿åº¦
  239            // è¿”å›å‚æ•°     void
  240            // ä½¿ç”¨ç¤ºä¾‹     imu963ra_read_acc_gyro_registers(IMU963RA_OUTX_L_A, dat, 6);
  241            // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  242            //------------------------------------------------------------------------------------------------------
             --------------
  243            static void imu963ra_read_acc_gyro_registers(uint8 reg, uint8 *dat, uint32 len)
  244            {
  245   1          IMU963RA_CS(0);
  246   1          imu963ra_simspi_r_reg_bytes( reg | IMU963RA_SPI_R, dat, len);
  247   1          IMU963RA_CS(1);
  248   1        }
  249            
  250          #elif (IMU963RA_USE_INTERFACE==SOFT_IIC)
                 static soft_iic_info_struct imu963ra_iic_struct;
               
                 //------------------------------------------------------------------------------------------------------
             --------------
                 // å‡½æ•°ç®€ä»‹     IMU963RA å†™å¯„å­˜å™¨
                 // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
                 // å‚æ•°è¯´æ˜     dat            æ•°æ®
                 // è¿”å›å‚æ•°     void
                 // ä½¿ç”¨ç¤ºä¾‹     imu963ra_write_acc_gyro_register(IMU963RA_SLV0_CONFIG, 0x00);
                 // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
                 //------------------------------------------------------------------------------------------------------
             --------------
                 #define imu963ra_write_acc_gyro_register(reg,dat)       (soft_iic_write_8bit_register(&imu963ra_iic_stru
             -ct,reg,dat))
               
                 //------------------------------------------------------------------------------------------------------
             --------------
                 // å‡½æ•°ç®€ä»‹     IMU963RA è¯»å¯„å­˜å™¨
                 // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
                 // è¿”å›å‚æ•°     uint8           æ•°æ®
                 // ä½¿ç”¨ç¤ºä¾‹     imu963ra_read_acc_gyro_register(IMU963RA_STATUS_MASTER);
                 // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
                 //------------------------------------------------------------------------------------------------------
             --------------
                 #define imu963ra_read_acc_gyro_register(reg)             (soft_iic_sccb_read_register(&imu963ra_iic_stru
             -ct,reg))
               
                 //------------------------------------------------------------------------------------------------------
             --------------
                 // å‡½æ•°ç®€ä»‹     IMU963RA è¯»æ•°æ® å†…éƒ¨è°ƒç”¨
                 // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
                 // å‚æ•°è¯´æ˜     dat            æ•°æ®ç¼“å†²åŒº
                 // å‚æ•°è¯´æ˜     len             æ•°æ®é•¿åº¦
                 // è¿”å›å‚æ•°     void
                 // ä½¿ç”¨ç¤ºä¾‹     imu963ra_read_acc_gyro_registers(IMU963RA_OUTX_L_A, dat, 6);
                 // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
                 //------------------------------------------------------------------------------------------------------
             --------------
                 #define imu963ra_read_acc_gyro_registers(reg,dat,len)   (soft_iic_read_8bit_registers(&imu963ra_iic_stru
             -ct,reg,dat,len))
               #endif
  283          
C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 08/01/26  02:12:47  PAGE 6   

  284          //-------------------------------------------------------------------------------------------------------
             -------------
  285          // å‡½æ•°ç®€ä»‹     IMU963RA ä½œä¸º IIC ä¸»æœºå‘ç£åŠ›è®¡å†™æ•°æ®
  286          // å‚æ•°è¯´æ˜     addr            ç›®æ ‡åœ°å€
  287          // å‚æ•°è¯´æ˜     reg             ç›®æ ‡å¯„å­˜å™¨
  288          // å‚æ•°è¯´æ˜     dat            æ•°æ®
  289          // è¿”å›å‚æ•°     uint8           1-å¤±è´¥ 0-æˆåŠŸ
  290          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_write_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_CONTROL2, 0x80);
  291          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  292          //-------------------------------------------------------------------------------------------------------
             -------------
  293          static uint8 imu963ra_write_mag_register (uint8 addr, uint8 reg, uint8 dat)
  294          {
  295   1          uint8 return_state = 0;
  296   1          uint16 timeout_count = 0;
  297   1          
  298   1          addr = addr << 1;
  299   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_CONFIG, 0x00);               // ä»æœº0é…ç½®æ¸…é™¤
  300   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_ADD, addr | 0);              // è®¾ç½®åœ°ç£è®¡åœ°å€ï
             -¼ˆæ³¨æ„è¿™é‡Œéœ€è¦è®¾ç½®8ä½çš„I2Cåœ°å€ï¼‰ 0x2C
  301   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_SUBADD, reg);                // éœ€è¦å†™å…¥çš„å¯„å­˜å
             -™¨åœ°å€
  302   1          imu963ra_write_acc_gyro_register(IMU963RA_DATAWRITE_SLV0, dat);            // éœ€è¦å†™å…¥çš„æ•°æ®
  303   1          imu963ra_write_acc_gyro_register(IMU963RA_MASTER_CONFIG, 0x4C);             // ä»…åœ¨ç¬¬ä¸€ä¸ªå‘¨æœŸå
             -¯ç”¨é€šè®¯ å¼€å¯ä¸Šæ‹‰ I2Cä¸»æœºä½¿èƒ½
  304   1          
  305   1          // ç­‰å¾…é€šè®¯æˆåŠŸ
  306   1          while(0 == (0x80 & imu963ra_read_acc_gyro_register(IMU963RA_STATUS_MASTER)))
  307   1          {
  308   2              if(IMU963RA_TIMEOUT_COUNT < timeout_count ++)
  309   2              {
  310   3                  return_state = 1;
  311   3                  break;
  312   3              }
  313   2              
  314   2              system_delay_ms(2);
  315   2          }
  316   1          
  317   1          return return_state;
  318   1      }
  319          
  320          //-------------------------------------------------------------------------------------------------------
             -------------
  321          // å‡½æ•°ç®€ä»‹     IMU963RA ä½œä¸º IIC ä¸»æœºå‘ç£åŠ›è®¡è¯»æ•°æ®
  322          // å‚æ•°è¯´æ˜     addr            ç›®æ ‡åœ°å€
  323          // å‚æ•°è¯´æ˜     reg             ç›®æ ‡å¯„å­˜å™¨
  324          // è¿”å›å‚æ•°     uint8           è¯»å–çš„æ•°æ®
  325          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_read_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_CHIP_ID);
  326          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  327          //-------------------------------------------------------------------------------------------------------
             -------------
  328          static uint8 imu963ra_read_mag_register (uint8 addr, uint8 reg)
  329          {
  330   1          uint16 timeout_count = 0;
  331   1          
  332   1          addr = addr << 1;
  333   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_ADD, addr | 1);              // è®¾ç½®åœ°ç£è®¡åœ°å€ï
             -¼ˆæ³¨æ„è¿™é‡Œéœ€è¦è®¾ç½®8ä½çš„I2Cåœ°å€ï¼‰ 0x2C
  334   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_SUBADD, reg);                // éœ€è¦è¯»å–çš„å¯„å­˜å
             -™¨åœ°å€
  335   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_CONFIG, 0x01);
  336   1          imu963ra_write_acc_gyro_register(IMU963RA_MASTER_CONFIG, 0x4C);             // ä»…åœ¨ç¬¬ä¸€ä¸ªå‘¨æœŸå
             -¯ç”¨é€šè®¯ å¼€å¯ä¸Šæ‹‰ I2Cä¸»æœºä½¿èƒ½
  337   1          
  338   1          // ç­‰å¾…é€šè®¯æˆåŠŸ
  339   1          while(0 == (0x01 & imu963ra_read_acc_gyro_register(IMU963RA_STATUS_MASTER)))
C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 08/01/26  02:12:47  PAGE 7   

  340   1          {
  341   2              if(IMU963RA_TIMEOUT_COUNT < timeout_count ++)
  342   2              {
  343   3                  break;
  344   3              }
  345   2              
  346   2              system_delay_ms(2);
  347   2          }
  348   1          
  349   1          return (imu963ra_read_acc_gyro_register(IMU963RA_SENSOR_HUB_1));            // è¿”å›è¯»å–åˆ°çš„æ•°æ
             -®
  350   1      }
  351          
  352          //-------------------------------------------------------------------------------------------------------
             -------------
  353          // å‡½æ•°ç®€ä»‹     IMU963RA ä½œä¸º IIC ä¸»æœºå‘ç£åŠ›è®¡è‡ªåŠ¨å†™æ•°æ®
  354          // å‚æ•°è¯´æ˜     addr            ç›®æ ‡åœ°å€
  355          // å‚æ•°è¯´æ˜     reg             ç›®æ ‡å¯„å­˜å™¨
  356          // è¿”å›å‚æ•°     void
  357          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_connect_mag(IMU963RA_MAG_ADDR, IMU963RA_MAG_OUTX_L);
  358          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  359          //-------------------------------------------------------------------------------------------------------
             -------------
  360          static void imu963ra_connect_mag (uint8 addr, uint8 reg)
  361          {
  362   1          addr = addr << 1;
  363   1          
  364   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_ADD, addr | 1);              // è®¾ç½®åœ°ç£è®¡åœ°å€ï
             -¼ˆæ³¨æ„è¿™é‡Œéœ€è¦è®¾ç½®8ä½çš„I2Cåœ°å€ï¼‰ 0x2C
  365   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_SUBADD, reg);                // éœ€è¦è¯»å–çš„å¯„å­˜å
             -™¨åœ°å€
  366   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_CONFIG, 0x06);
  367   1          imu963ra_write_acc_gyro_register(IMU963RA_MASTER_CONFIG, 0x6C);             // ä»…åœ¨ç¬¬ä¸€ä¸ªå‘¨æœŸå
             -¯ç”¨é€šè®¯ å¼€å¯ä¸Šæ‹‰ I2Cä¸»æœºä½¿èƒ½
  368   1      }
  369          
  370          
  371          //-------------------------------------------------------------------------------------------------------
             -------------
  372          // å‡½æ•°ç®€ä»‹     IMU963RA å…­è½´è‡ªæ£€ å†…éƒ¨è°ƒç”¨
  373          // å‚æ•°è¯´æ˜     void
  374          // è¿”å›å‚æ•°     uint8           1-è‡ªæ£€å¤±è´¥ 0-è‡ªæ£€æˆåŠŸ
  375          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_acc_gyro_self_check();
  376          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  377          //-------------------------------------------------------------------------------------------------------
             -------------
  378          static uint8 imu963ra_acc_gyro_self_check (void)
  379          {
  380   1          uint8 return_state = 0;
  381   1          uint8 dat = 0;
  382   1          uint16 timeout_count = 0;
  383   1          
  384   1          while(0x6B != dat)                                                          // åˆ¤æ–­ ID æ˜¯å¦æ­£ç¡®
  385   1          {
  386   2              if(IMU963RA_TIMEOUT_COUNT < timeout_count ++)
  387   2              {
  388   3                  return_state = 1;
  389   3                  break;
  390   3              }
  391   2              
  392   2              dat = imu963ra_read_acc_gyro_register(IMU963RA_WHO_AM_I);
  393   2          printf("dat = %d\r\n", dat);
  394   2              system_delay_ms(10);
  395   2          }
  396   1          
  397   1          return return_state;
C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 08/01/26  02:12:47  PAGE 8   

  398   1      }
  399          
  400          //-------------------------------------------------------------------------------------------------------
             -------------
  401          // å‡½æ•°ç®€ä»‹     IMU963RA ç£åŠ›è®¡è‡ªæ£€ å†…éƒ¨è°ƒç”¨
  402          // å‚æ•°è¯´æ˜     void
  403          // è¿”å›å‚æ•°     uint8           1-è‡ªæ£€å¤±è´¥ 0-è‡ªæ£€æˆåŠŸ
  404          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_mag_self_check();
  405          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  406          //-------------------------------------------------------------------------------------------------------
             -------------
  407          static uint8 imu963ra_mag_self_check (void)
  408          {
  409   1          uint8 return_state = 0;
  410   1          uint8 dat = 0;
  411   1          uint16 timeout_count = 0;
  412   1          
  413   1          while(0xff != dat)                                                          // åˆ¤æ–­ ID æ˜¯å¦æ­£ç¡®
  414   1          {
  415   2              if(IMU963RA_TIMEOUT_COUNT < timeout_count ++)
  416   2              {
  417   3                  return_state = 1;
  418   3                  break;
  419   3              }
  420   2              
  421   2              dat = imu963ra_read_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_CHIP_ID);
  422   2              system_delay_ms(10);
  423   2          }
  424   1          
  425   1          return return_state;
  426   1      }
  427          
  428          //-------------------------------------------------------------------------------------------------------
             -------------
  429          // å‡½æ•°ç®€ä»‹     è·å– IMU963RA åŠ é€Ÿåº¦è®¡æ•°æ®
  430          // å‚æ•°è¯´æ˜     void
  431          // è¿”å›å‚æ•°     void
  432          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_get_acc();
  433          // å¤‡æ³¨ä¿¡æ¯     æ‰§è¡Œè¯¥å‡½æ•°åï¼Œç›´æ¥æŸ¥çœ‹å¯¹åº”çš„å˜é‡å³å¯
  434          //-------------------------------------------------------------------------------------------------------
             -------------
  435          void imu963ra_get_acc (void)
  436          {
  437   1          uint8 dat[6];
  438   1          
  439   1          imu963ra_read_acc_gyro_registers(IMU963RA_OUTX_L_A, dat, 6);
  440   1          imu963ra_acc_x = (int16)(((uint16)dat[1] << 8 | dat[0]));
  441   1          imu963ra_acc_y = (int16)(((uint16)dat[3] << 8 | dat[2]));
  442   1          imu963ra_acc_z = (int16)(((uint16)dat[5] << 8 | dat[4]));
  443   1      }
  444          
  445          
  446          //-------------------------------------------------------------------------------------------------------
             -------------
  447          // å‡½æ•°ç®€ä»‹     è·å–IMU963RAé™€èºä»ªæ•°æ®
  448          // å‚æ•°è¯´æ˜     void
  449          // è¿”å›å‚æ•°     void
  450          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_get_gyro();
  451          // å¤‡æ³¨ä¿¡æ¯     æ‰§è¡Œè¯¥å‡½æ•°åï¼Œç›´æ¥æŸ¥çœ‹å¯¹åº”çš„å˜é‡å³å¯
  452          //-------------------------------------------------------------------------------------------------------
             -------------
  453          void imu963ra_get_gyro (void)
  454          {
  455   1          uint8 dat[6];
  456   1          
  457   1          imu963ra_read_acc_gyro_registers(IMU963RA_OUTX_L_G, dat, 6);
C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 08/01/26  02:12:47  PAGE 9   

  458   1          imu963ra_gyro_x = (int16)(((uint16)dat[1] << 8 | dat[0]));
  459   1          imu963ra_gyro_y = (int16)(((uint16)dat[3] << 8 | dat[2]));
  460   1          imu963ra_gyro_z = (int16)(((uint16)dat[5] << 8 | dat[4]));
  461   1      }
  462          
  463          
  464          //-------------------------------------------------------------------------------------------------------
             -------------
  465          // å‡½æ•°ç®€ä»‹     è·å– IMU963RA ç£åŠ›è®¡æ•°æ®
  466          // å‚æ•°è¯´æ˜     void
  467          // è¿”å›å‚æ•°     void
  468          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_get_mag();
  469          // å¤‡æ³¨ä¿¡æ¯     æ‰§è¡Œè¯¥å‡½æ•°åï¼Œç›´æ¥æŸ¥çœ‹å¯¹åº”çš„å˜é‡å³å¯
  470          //-------------------------------------------------------------------------------------------------------
             -------------
  471          void imu963ra_get_mag (void)
  472          {
  473   1          uint8 temp_status;
  474   1          uint8 dat[6];
  475   1          
  476   1          imu963ra_write_acc_gyro_register(IMU963RA_FUNC_CFG_ACCESS, 0x40);
  477   1          temp_status = imu963ra_read_acc_gyro_register(IMU963RA_STATUS_MASTER);
  478   1          
  479   1          if(0x01 & temp_status)
  480   1          {
  481   2              imu963ra_read_acc_gyro_registers(IMU963RA_SENSOR_HUB_1, dat, 6);
  482   2              imu963ra_mag_x = (int16)(((uint16)dat[1] << 8 | dat[0]));
  483   2              imu963ra_mag_y = (int16)(((uint16)dat[3] << 8 | dat[2]));
  484   2              imu963ra_mag_z = (int16)(((uint16)dat[5] << 8 | dat[4]));
  485   2          }
  486   1          
  487   1          imu963ra_write_acc_gyro_register(IMU963RA_FUNC_CFG_ACCESS, 0x00);
  488   1      }
  489          
  490          //-------------------------------------------------------------------------------------------------------
             -------------
  491          // å‡½æ•°ç®€ä»‹     åˆå§‹åŒ– IMU963RA
  492          // å‚æ•°è¯´æ˜     void
  493          // è¿”å›å‚æ•°     uint8           1-åˆå§‹åŒ–å¤±è´¥ 0-åˆå§‹åŒ–æˆåŠŸ
  494          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_init();
  495          // å¤‡æ³¨ä¿¡æ¯
  496          //-------------------------------------------------------------------------------------------------------
             -------------
  497          uint8 imu963ra_init (void)
  498          {
  499   1          uint8 return_state = 0;
  500   1          system_delay_ms(10);                                                        // ä¸Šç”µå»¶æ—¶
  501   1          
  502   1      #if (IMU963RA_USE_INTERFACE==HARDWARE_SPI)
                 
                 spi_init(IMU963RA_SPI, SPI_MODE0, IMU963RA_SPI_SPEED, IMU963RA_SPC_PIN, IMU963RA_SDI_PIN, IMU963RA_SDO_P
             -IN, SPI_CS_NULL);
                   gpio_init(IMU963RA_CS_PIN, GPO, GPIO_HIGH, GPO_PUSH_PULL);
                 
               #elif (IMU963RA_USE_INTERFACE==SOFT_SPI)
  508   1        
  509   1      // é»˜è®¤ä½¿ç”¨åŒå‘IOï¼Œä¸éœ€è¦åˆå§‹åŒ–ã€‚
  510   1      //  soft_spi_init(IMU963RA_SPI, SPI_MODE0, 0, IMU963RA_SPC_PIN, IMU963RA_SDI_PIN, IMU963RA_SDO_PIN, IMU963
             -RA_CS_PIN);
  511   1        
  512   1      #elif (IMU963RA_USE_INTERFACE==SOFT_IIC)
                 
                 soft_iic_init(&imu963ra_iic_struct, IMU963RA_DEV_ADDR, IMU963RA_SOFT_IIC_DELAY, IMU963RA_SCL_PIN, IMU963
             -RA_SDA_PIN);
                 
               #endif
C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 08/01/26  02:12:47  PAGE 10  

  517   1        
  518   1          do
  519   1          {
  520   2              imu963ra_write_acc_gyro_register(IMU963RA_FUNC_CFG_ACCESS, 0x00);       // å…³é—­HUBå¯„å­˜å™¨è®¿é
             -—®
  521   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL3_C, 0x01);               // å¤ä½è®¾å¤‡
  522   2              system_delay_ms(2);
  523   2              imu963ra_write_acc_gyro_register(IMU963RA_FUNC_CFG_ACCESS, 0x00);       // å…³é—­HUBå¯„å­˜å™¨è®¿é
             -—®
  524   2              
  525   2              if(imu963ra_acc_gyro_self_check())
  526   2              {
  527   3                  printf( "IMU963RA acc and gyro self check error.");
  528   3                  return_state = 1;
  529   3                  break;
  530   3              }
  531   2              
  532   2              imu963ra_write_acc_gyro_register(IMU963RA_INT1_CTRL, 0x03);             // å¼€å¯é™€èºä»ª åŠ é€Ÿ
             -åº¦æ•°æ®å°±ç»ªä¸­æ–­
  533   2              
  534   2              // IMU963RA_CTRL1_XL å¯„å­˜å™¨
  535   2              // è®¾ç½®ä¸º 0x30 åŠ é€Ÿåº¦é‡ç¨‹ä¸º Â±2  G    è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ®é™¤ä»¥ 16393  å¯ä»¥
             -è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ g(m/s^2)
  536   2              // è®¾ç½®ä¸º 0x38 åŠ é€Ÿåº¦é‡ç¨‹ä¸º Â±4  G    è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ®é™¤ä»¥ 8197   å¯ä»¥
             -è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ g(m/s^2)
  537   2              // è®¾ç½®ä¸º 0x3C åŠ é€Ÿåº¦é‡ç¨‹ä¸º Â±8  G    è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ®é™¤ä»¥ 4098   å¯ä»¥
             -è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ g(m/s^2)
  538   2              // è®¾ç½®ä¸º 0x34 åŠ é€Ÿåº¦é‡ç¨‹ä¸º Â±16 G    è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ®é™¤ä»¥ 2049   å¯ä»¥
             -è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ g(m/s^2)
  539   2              switch(IMU963RA_ACC_SAMPLE_DEFAULT)
  540   2              {
  541   3                  default:
  542   3                  {
  543   4                      printf( "IMU963RA_ACC_SAMPLE_DEFAULT set error.\r\n");
  544   4                      return_state = 1;
  545   4                  }
  546   3                  break;
  547   3                  
  548   3                  case IMU963RA_ACC_SAMPLE_SGN_2G:
  549   3                  {
  550   4                      imu963ra_write_acc_gyro_register(IMU963RA_CTRL1_XL, 0x30);
  551   4                      imu963ra_transition_factor[0] = 16393;
  552   4                  }
  553   3                  break;
  554   3                  
  555   3                  case IMU963RA_ACC_SAMPLE_SGN_4G:
  556   3                  {
  557   4                      imu963ra_write_acc_gyro_register(IMU963RA_CTRL1_XL, 0x38);
  558   4                      imu963ra_transition_factor[0] = 8197;
  559   4                  }
  560   3                  break;
  561   3                  
  562   3                  case IMU963RA_ACC_SAMPLE_SGN_8G:
  563   3                  {
  564   4                      imu963ra_write_acc_gyro_register(IMU963RA_CTRL1_XL, 0x3C);
  565   4                      imu963ra_transition_factor[0] = 4098;
  566   4                  }
  567   3                  break;
  568   3                  
  569   3                  case IMU963RA_ACC_SAMPLE_SGN_16G:
  570   3                  {
  571   4                      imu963ra_write_acc_gyro_register(IMU963RA_CTRL1_XL, 0x34);
  572   4                      imu963ra_transition_factor[0] = 2049;
  573   4                  }
  574   3                  break;
  575   3              }
C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 08/01/26  02:12:47  PAGE 11  

  576   2              
  577   2              if(1 == return_state)
  578   2              {
  579   3                  break;
  580   3              }
  581   2              
  582   2              // IMU963RA_CTRL2_G å¯„å­˜å™¨
  583   2              // è®¾ç½®ä¸º 0x52 é™€èºä»ªé‡ç¨‹ä¸º Â±125  dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 228.6   å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸º Â°/s
  584   2              // è®¾ç½®ä¸º 0x50 é™€èºä»ªé‡ç¨‹ä¸º Â±250  dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 114.3   å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸º Â°/s
  585   2              // è®¾ç½®ä¸º 0x54 é™€èºä»ªé‡ç¨‹ä¸º Â±500  dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 57.1    å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸º Â°/s
  586   2              // è®¾ç½®ä¸º 0x58 é™€èºä»ªé‡ç¨‹ä¸º Â±1000 dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 28.6    å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸º Â°/s
  587   2              // è®¾ç½®ä¸º 0x5C é™€èºä»ªé‡ç¨‹ä¸º Â±2000 dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 14.3    å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸º Â°/s
  588   2              // è®¾ç½®ä¸º 0x51 é™€èºä»ªé‡ç¨‹ä¸º Â±4000 dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 7.1     å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸º Â°/s
  589   2              switch(IMU963RA_GYRO_SAMPLE_DEFAULT)
  590   2              {
  591   3                  default:
  592   3                  {
  593   4                      printf( "IMU963RA_GYRO_SAMPLE_DEFAULT set error.\r\n");
  594   4                      return_state = 1;
  595   4                  }
  596   3                  break;
  597   3                  
  598   3                  case IMU963RA_GYRO_SAMPLE_SGN_125DPS:
  599   3                  {
  600   4                      imu963ra_write_acc_gyro_register(IMU963RA_CTRL2_G, 0x52);
  601   4                      imu963ra_transition_factor[1] = 228.6;
  602   4                  }
  603   3                  break;
  604   3                  
  605   3                  case IMU963RA_GYRO_SAMPLE_SGN_250DPS:
  606   3                  {
  607   4                      imu963ra_write_acc_gyro_register(IMU963RA_CTRL2_G, 0x50);
  608   4                      imu963ra_transition_factor[1] = 114.3;
  609   4                  }
  610   3                  break;
  611   3                  
  612   3                  case IMU963RA_GYRO_SAMPLE_SGN_500DPS:
  613   3                  {
  614   4                      imu963ra_write_acc_gyro_register(IMU963RA_CTRL2_G, 0x54);
  615   4                      imu963ra_transition_factor[1] = 57.1;
  616   4                  }
  617   3                  break;
  618   3                  
  619   3                  case IMU963RA_GYRO_SAMPLE_SGN_1000DPS:
  620   3                  {
  621   4                      imu963ra_write_acc_gyro_register(IMU963RA_CTRL2_G, 0x58);
  622   4                      imu963ra_transition_factor[1] = 28.6;
  623   4                  }
  624   3                  break;
  625   3                  
  626   3                  case IMU963RA_GYRO_SAMPLE_SGN_2000DPS:
  627   3                  {
  628   4                      imu963ra_write_acc_gyro_register(IMU963RA_CTRL2_G, 0x5C);
  629   4                      imu963ra_transition_factor[1] = 14.3;
  630   4                  }
  631   3                  break;
  632   3                  
  633   3                  case IMU963RA_GYRO_SAMPLE_SGN_4000DPS:
  634   3                  {
  635   4                      imu963ra_write_acc_gyro_register(IMU963RA_CTRL2_G, 0x51);
C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 08/01/26  02:12:47  PAGE 12  

  636   4                      imu963ra_transition_factor[1] = 7.1;
  637   4                  }
  638   3                  break;
  639   3              }
  640   2              
  641   2              if(1 == return_state)
  642   2              {
  643   3                  break;
  644   3              }
  645   2              
  646   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL3_C, 0x44);               // ä½¿èƒ½é™€èºä»ªæ•°å­—ä
             -½é€šæ»¤æ³¢å™¨
  647   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL4_C, 0x02);               // ä½¿èƒ½æ•°å­—ä½é€šæ»¤æ
             -³¢å™¨
  648   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL5_C, 0x00);               // åŠ é€Ÿåº¦è®¡ä¸é™€èºä
             -»ªå››èˆäº”å…¥
  649   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL6_C, 0x00);               // å¼€å¯åŠ é€Ÿåº¦è®¡é«˜æ
             -€§èƒ½æ¨¡å¼ é™€èºä»ªä½é€šæ»¤æ³¢ 133hz
  650   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL7_G, 0x00);               // å¼€å¯é™€èºä»ªé«˜æ€§è
             -ƒ½æ¨¡å¼ å…³é—­é«˜é€šæ»¤æ³¢
  651   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL9_XL, 0x01);              // å…³é—­I3Cæ¥å£
  652   2              
  653   2              imu963ra_write_acc_gyro_register(IMU963RA_FUNC_CFG_ACCESS, 0x40);       // å¼€å¯HUBå¯„å­˜å™¨è®¿é
             -—® ç”¨äºé…ç½®åœ°ç£è®¡
  654   2              imu963ra_write_acc_gyro_register(IMU963RA_MASTER_CONFIG, 0x80);         // å¤ä½I2Cä¸»æœº
  655   2              system_delay_ms(2);
  656   2              imu963ra_write_acc_gyro_register(IMU963RA_MASTER_CONFIG, 0x00);         // æ¸…é™¤å¤ä½æ ‡å¿—
  657   2              system_delay_ms(2);
  658   2              
  659   2              imu963ra_write_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_CONTROL2, 0x80);// å¤ä½è¿æ¥çš„å¤–
             -è®¾
  660   2              system_delay_ms(2);
  661   2              imu963ra_write_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_CONTROL2, 0x00);
  662   2              system_delay_ms(2);
  663   2              
  664   2              if(imu963ra_mag_self_check())
  665   2              {
  666   3                  printf( "IMU963RA mag self check error.\r\n");
  667   3                  return_state = 1;
  668   3                  break;
  669   3              }
  670   2              
  671   2              // IMU963RA_MAG_ADDR å¯„å­˜å™¨
  672   2              // è®¾ç½®ä¸º 0x09 ç£åŠ›è®¡é‡ç¨‹ä¸º 2G   è·å–åˆ°çš„ç£åŠ›è®¡æ•°æ®é™¤ä»¥ 12000   å¯ä»¥è½¬åŒ–ä
             -¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ G(é«˜æ–¯)
  673   2              // è®¾ç½®ä¸º 0x19 ç£åŠ›è®¡é‡ç¨‹ä¸º 8G   è·å–åˆ°çš„ç£åŠ›è®¡æ•°æ®é™¤ä»¥ 3000    å¯ä»¥è½¬åŒ–ä
             -¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ G(é«˜æ–¯)
  674   2              switch(IMU963RA_MAG_SAMPLE_DEFAULT)
  675   2              {
  676   3                  default:
  677   3                  {
  678   4                      printf( "IMU963RA_MAG_SAMPLE_DEFAULT set error.\r\n");
  679   4                      return_state = 1;
  680   4                  }
  681   3                  break;
  682   3                  
  683   3                  case IMU963RA_MAG_SAMPLE_2G:
  684   3                  {
  685   4                      imu963ra_write_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_CONTROL1, 0x09);
  686   4                      imu963ra_transition_factor[2] = 12000;
  687   4                  }
  688   3                  break;
  689   3                  
  690   3                  case IMU963RA_MAG_SAMPLE_8G:
  691   3                  {
  692   4                      imu963ra_write_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_CONTROL1, 0x19);
C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 08/01/26  02:12:47  PAGE 13  

  693   4                      imu963ra_transition_factor[2] = 3000;
  694   4                  }
  695   3                  break;
  696   3              }
  697   2              
  698   2              if(1 == return_state)
  699   2              {
  700   3                  break;
  701   3              }
  702   2              
  703   2              imu963ra_write_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_FBR, 0x01);
  704   2              imu963ra_connect_mag(IMU963RA_MAG_ADDR, IMU963RA_MAG_OUTX_L);
  705   2              
  706   2              imu963ra_write_acc_gyro_register(IMU963RA_FUNC_CFG_ACCESS, 0x00);       // å…³é—­HUBå¯„å­˜å™¨è®¿é
             -—®
  707   2              
  708   2              system_delay_ms(20);                                                    // ç­‰å¾…ç£åŠ›è®¡è·å–æ
             -•°æ®
  709   2          }
  710   1          while(0);
  711   1          
  712   1          return return_state;
  713   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1118     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        30         25
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       288     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
