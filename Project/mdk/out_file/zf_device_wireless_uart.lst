C251 COMPILER V5.60.0,  zf_device_wireless_uart                                            08/01/26  02:12:48  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_device_wireless_uart
OBJECT MODULE PLACED IN .\out_file\zf_device_wireless_uart.obj
COMPILER INVOKED BY: E:\Tools\keil5\Keil_v5\C251\BIN\C251.EXE ..\..\libraries\zf_device\zf_device_wireless_uart.c LARGE 
                    -NOALIAS WARNINGLEVEL(3) OPTIMIZE(SIZE) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libra
                    -ries\zf_device;..\..\libraries\zf_driver;..\user;..\code) DEBUG PRINT(.\out_file\zf_device_wireless_uart.lst) TABS(2) OB
                    -JECT(.\out_file\zf_device_wireless_uart.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * STC32G Opensourec Library ¼´£¨STC32G ¿ªÔ´¿â£©ÊÇÒ»¸ö»ùÓÚ¹Ù·½ SDK ½Ó¿ÚµÄµÚÈý·½¿ªÔ´¿â
    3          * Copyright (c) 2022 SEEKFREE Öð·É¿Æ¼¼
    4          *
    5          * ±¾ÎÄ¼þÊÇSTC ¿ªÔ´¿âµÄÒ»²¿·Ö
    6          *
    7          * STC32G ¿ªÔ´¿â ÊÇÃâ·ÑÈí¼þ
    8          * Äú¿ÉÒÔ¸ù¾Ý×ÔÓÉÈí¼þ»ù½ð»á·¢²¼µÄ GPL£¨GNU General Public License£¬¼´ GNUÍ¨ÓÃ¹«¹²Ðí¿ÉÖ¤£©µÄÌõ¿î
    9          * ¼´ GPL µÄµÚ3°æ£¨¼´ GPL3.0£©»ò£¨ÄúÑ¡ÔñµÄ£©ÈÎºÎºóÀ´µÄ°æ±¾£¬ÖØÐÂ·¢²¼ºÍ/»òÐÞ¸ÄËü
   10          *
   11          * ±¾¿ªÔ´¿âµÄ·¢²¼ÊÇÏ£ÍûËüÄÜ·¢»Ó×÷ÓÃ£¬µ«²¢Î´¶ÔÆä×÷ÈÎºÎµÄ±£Ö¤
   12          * ÉõÖÁÃ»ÓÐÒþº¬µÄÊÊÏúÐÔ»òÊÊºÏÌØ¶¨ÓÃÍ¾µÄ±£Ö¤
   13          * ¸ü¶àÏ¸½ÚÇë²Î¼û GPL
   14          *
   15          * ÄúÓ¦¸ÃÔÚÊÕµ½±¾¿ªÔ´¿âµÄÍ¬Ê±ÊÕµ½Ò»·Ý GPL µÄ¸±±¾
   16          * Èç¹ûÃ»ÓÐ£¬Çë²ÎÔÄ<https://www.gnu.org/licenses/>
   17          *
   18          * ¶îÍâ×¢Ã÷£º
   19          * ±¾¿ªÔ´¿âÊ¹ÓÃ GPL3.0 ¿ªÔ´Ðí¿ÉÖ¤Ð­Òé ÒÔÉÏÐí¿ÉÉêÃ÷ÎªÒëÎÄ°æ±¾
   20          * Ðí¿ÉÉêÃ÷Ó¢ÎÄ°æÔÚ libraries/doc ÎÄ¼þ¼ÐÏÂµÄ GPL3_permission_statement.txt ÎÄ¼þÖÐ
   21          * Ðí¿ÉÖ¤¸±±¾ÔÚ libraries ÎÄ¼þ¼ÐÏÂ ¼´¸ÃÎÄ¼þ¼ÐÏÂµÄ LICENSE ÎÄ¼þ
   22          * »¶Ó­¸÷Î»Ê¹ÓÃ²¢´«²¥±¾³ÌÐò µ«ÐÞ¸ÄÄÚÈÝÊ±±ØÐë±£ÁôÖð·É¿Æ¼¼µÄ°æÈ¨ÉùÃ÷£¨¼´±¾ÉùÃ÷£©
   23          *
   24          * ÎÄ¼þÃû³Æ          
   25          * ¹«Ë¾Ãû³Æ          ³É¶¼Öð·É¿Æ¼¼ÓÐÏÞ¹«Ë¾
   26          * °æ±¾ÐÅÏ¢          ²é¿´ libraries/doc ÎÄ¼þ¼ÐÄÚ version ÎÄ¼þ °æ±¾ËµÃ÷
   27          * ¿ª·¢»·¾³          MDK FOR C251
   28          * ÊÊÓÃÆ½Ì¨          STC32G
   29          * µêÆÌÁ´½Ó          https://seekfree.taobao.com/
   30          *
   31          * ÐÞ¸Ä¼ÇÂ¼
   32          * ÈÕÆÚ              ×÷Õß           ±¸×¢
   33          * 2024-08-01        ´óW            first version
   34          *********************************************************************************************************
             -***********/
   35          /********************************************************************************************************
             -*************
   36          * ½ÓÏß¶¨Òå£º
   37          *                   ------------------------------------
   38          *                   Ä£¿é¹Ü½Å            µ¥Æ¬»ú¹Ü½Å
   39          *                   RX                  ²é¿´ zf_device_wireless_uart.h ÖÐ WIRELESS_UART_RX_PIN  ºê¶¨Òå
   40          *                   TX                  ²é¿´ zf_device_wireless_uart.h ÖÐ WIRELESS_UART_TX_PIN  ºê¶¨Òå
   41          *                   RTS                 ²é¿´ zf_device_wireless_uart.h ÖÐ WIRELESS_UART_RTS_PIN ºê¶¨Òå
   42          *                   VCC                 3.3VµçÔ´
   43          *                   GND                 µçÔ´µØ
   44          *                   ÆäÓàÒý½ÅÐü¿Õ
   45          *                   ------------------------------------
   46          *********************************************************************************************************
             -************/
   47          
   48          #include "zf_common_clock.h"
   49          #include "zf_common_debug.h"
   50          #include "zf_common_fifo.h"
   51          #include "zf_driver_delay.h"
   52          #include "zf_driver_gpio.h"
C251 COMPILER V5.60.0,  zf_device_wireless_uart                                            08/01/26  02:12:48  PAGE 2   

   53          #include "zf_driver_uart.h"
   54          #include "zf_device_wireless_uart.h"
   55          #include "zf_device_type.h"
   56          
   57          #pragma warning disable = 183
   58          #pragma warning disable = 177
   59          
   60          
   61          static  fifo_struct                                     wireless_uart_fifo;
   62          static  uint8                                           wireless_uart_buffer[WIRELESS_UART_BUFFER_SIZE];
   63          
   64          //static          uint8                                   wireless_uart_data          = 0;
   65          #if (1 == WIRELESS_UART_AUTO_BAUD_RATE)
               static volatile wireless_uart_auto_baudrate_state_enum  wireless_auto_baud_flag     = WIRELESS_UART_AUTO_
             -BAUD_RATE_INIT;
               static volatile uint8                                   wireless_auto_baud_data[3]  = {0x00, 0x01, 0x03};
               #endif
   69          
   70          //-------------------------------------------------------------------------------------------------------
             -------------
   71          // º¯Êý¼ò½é     ÎÞÏß×ª´®¿ÚÄ£¿é ·¢ËÍÊý¾Ý
   72          // ²ÎÊýËµÃ÷     data            8bit Êý¾Ý
   73          // ·µ»Ø²ÎÊý     uint32          Ê£Óà·¢ËÍ³¤¶È 0-·¢ËÍÍê±Ï 1-Î´·¢ËÍÍê³É
   74          // Ê¹ÓÃÊ¾Àý     wireless_uart_send_byte(data);
   75          // ±¸×¢ÐÅÏ¢
   76          //-------------------------------------------------------------------------------------------------------
             -------------
   77          uint32 wireless_uart_send_byte (const uint8 dat)
   78          {
   79   1        uint16 time_cnt = WIRELESS_UART_TIMEOUT_COUNT;
   80   1        
   81   1        while (time_cnt && gpio_get_level(WIRELESS_UART_RTS_PIN)) 
   82   1        {
   83   2          system_delay_ms(1);
   84   2          time_cnt--;
   85   2        }
   86   1        
   87   1        if (time_cnt) 
   88   1        {
   89   2          uart_write_byte(WIRELESS_UART_INDEX, dat);
   90   2        }
   91   1        
   92   1        return time_cnt == 0;
   93   1      }
   94          
   95          //-------------------------------------------------------------------------------------------------------
             -------------
   96          // º¯Êý¼ò½é     ÎÞÏß×ª´®¿ÚÄ£¿é ·¢ËÍÊý¾Ý¿é
   97          // ²ÎÊýËµÃ÷     *buff           ·¢ËÍ»º³åÇø
   98          // ²ÎÊýËµÃ÷     len             ·¢ËÍÊý¾Ý³¤¶È
   99          // ·µ»Ø²ÎÊý     uint32          Ê£Óà·¢ËÍ³¤¶È
  100          // Ê¹ÓÃÊ¾Àý     wireless_uart_send_buffer(buff, 64);
  101          // ±¸×¢ÐÅÏ¢
  102          //-------------------------------------------------------------------------------------------------------
             -------------
  103          uint32 wireless_uart_send_buffer(const uint8 *buff, uint32 len)
  104          {
  105   1          #define WIRELESS_PACKET_SIZE 30
  106   1          #define DELAY_MS 1
  107   1          
  108   1          uint16 time_cnt = 0;
  109   1        uint16 send_len = 0;
  110   1          zf_assert(NULL != buff);  // È·±£»º³åÇø·Ç¿Õ
  111   1      
  112   1          while (len && time_cnt < WIRELESS_UART_TIMEOUT_COUNT)
  113   1          {
C251 COMPILER V5.60.0,  zf_device_wireless_uart                                            08/01/26  02:12:48  PAGE 3   

  114   2              if (!gpio_get_level(WIRELESS_UART_RTS_PIN))  // RTSµÍµçÆ½£¬¿É·¢ËÍ
  115   2              {
  116   3                  send_len = len < WIRELESS_PACKET_SIZE ? len : WIRELESS_PACKET_SIZE;
  117   3                  uart_write_buffer(WIRELESS_UART_INDEX, buff, send_len);
  118   3                  buff += send_len;
  119   3                  len -= send_len;
  120   3                  time_cnt = 0;  // ÖØÖÃ³¬Ê±¼ÆÊý
  121   3              }
  122   2              else  // RTS¸ßµçÆ½£¬Ä£¿éÃ¦
  123   2              {
  124   3                  system_delay_ms(DELAY_MS);
  125   3                  time_cnt++;
  126   3              }
  127   2          }
  128   1      
  129   1          return len;  // ·µ»ØÎ´·¢ËÍµÄ×Ö½ÚÊý
  130   1      }
  131          
  132          //-------------------------------------------------------------------------------------------------------
             -------------
  133          // º¯Êý¼ò½é     ÎÞÏß×ª´®¿ÚÄ£¿é ·¢ËÍ×Ö·û´®
  134          // ²ÎÊýËµÃ÷     *str            Òª·¢ËÍµÄ×Ö·û´®µØÖ·
  135          // ·µ»Ø²ÎÊý     uint32          Ê£Óà·¢ËÍ³¤¶È
  136          // Ê¹ÓÃÊ¾Àý     wireless_uart_send_string("Believe in yourself.");
  137          // ±¸×¢ÐÅÏ¢
  138          //-------------------------------------------------------------------------------------------------------
             -------------
  139          uint32 wireless_uart_send_string (const char *str)
  140          {
  141   1          uint32 len = strlen(str);
  142   1          zf_assert(NULL != str);
  143   1        
  144   1          return  wireless_uart_send_buffer(str, len);
  145   1      }
  146          
  147          
  148          //-------------------------------------------------------------------------------------------------------
             -------------
  149          // º¯Êý¼ò½é     ÎÞÏß×ª´®¿ÚÄ£¿é ¶ÁÈ¡»º³å
  150          // ²ÎÊýËµÃ÷     *buff           ½ÓÊÕ»º³åÇø
  151          // ²ÎÊýËµÃ÷     len             ¶ÁÈ¡Êý¾Ý³¤¶È
  152          // ·µ»Ø²ÎÊý     uint32          Êµ¼Ê¶ÁÈ¡Êý¾Ý³¤¶È
  153          // Ê¹ÓÃÊ¾Àý     wireless_uart_read_buffer(buff, 32);
  154          // ±¸×¢ÐÅÏ¢
  155          //-------------------------------------------------------------------------------------------------------
             -------------
  156          uint32 wireless_uart_read_buffer (uint8 *buff, uint32 len)
  157          {
  158   1          uint32 data_len = len;
  159   1          zf_assert(NULL != buff);
  160   1          fifo_read_buffer(&wireless_uart_fifo, buff, &data_len, FIFO_READ_AND_CLEAN);
  161   1          return data_len;
  162   1      }
  163          
  164          //-------------------------------------------------------------------------------------------------------
             -------------
  165          // º¯Êý¼ò½é     ÎÞÏß×ª´®¿ÚÄ£¿é ´®¿ÚÖÐ¶Ï»Øµ÷º¯Êý
  166          // ²ÎÊýËµÃ÷     void
  167          // ·µ»Ø²ÎÊý     void
  168          // Ê¹ÓÃÊ¾Àý     wireless_uart_callback();
  169          // ±¸×¢ÐÅÏ¢     ¸Ãº¯ÊýÔÚ ISR ÎÄ¼þ ´®¿ÚÖÐ¶Ï³ÌÐò±»µ÷ÓÃ
  170          //              ÓÉ´®¿ÚÖÐ¶Ï·þÎñº¯Êýµ÷ÓÃ wireless_module_uart_handler() º¯Êý
  171          //              ÔÙÓÉ wireless_module_uart_handler() º¯Êýµ÷ÓÃ±¾º¯Êý
  172          //-------------------------------------------------------------------------------------------------------
             -------------
  173          void wireless_uart_callback (uint8 uart_dat)
C251 COMPILER V5.60.0,  zf_device_wireless_uart                                            08/01/26  02:12:48  PAGE 4   

  174          {
  175   1      //    uart_query_byte(WIRELESS_UART_INDEX, &uart_dat);
  176   1          fifo_write_buffer(&wireless_uart_fifo, &uart_dat, 1);
  177   1      #if WIRELESS_UART_AUTO_BAUD_RATE                                                // ¿ªÆô×Ô¶¯²¨ÌØÂÊ
                   
                   if(WIRELESS_UART_AUTO_BAUD_RATE_START == wireless_auto_baud_flag && 3 == fifo_used(&wireless_uart_fif
             -o))
                   {
                       uint32 wireless_auto_baud_count = 3;
                       wireless_auto_baud_flag = WIRELESS_UART_AUTO_BAUD_RATE_GET_ACK;
                       fifo_read_buffer(&wireless_uart_fifo, (uint8 *)wireless_auto_baud_data, (uint32 *)&wireless_auto_
             -baud_count, FIFO_READ_AND_CLEAN);
                   }
                   
               #endif
  187   1      }
  188          
  189          //-------------------------------------------------------------------------------------------------------
             -------------
  190          // º¯Êý¼ò½é     ÎÞÏß×ª´®¿ÚÄ£¿é ³õÊ¼»¯
  191          // ²ÎÊýËµÃ÷     void
  192          // ·µ»Ø²ÎÊý     void
  193          // Ê¹ÓÃÊ¾Àý     wireless_uart_init();
  194          // ±¸×¢ÐÅÏ¢
  195          //-------------------------------------------------------------------------------------------------------
             -------------
  196          uint8 wireless_uart_init (void)
  197          {
  198   1          uint8 return_state = 0;
  199   1          set_wireless_type(WIRELESS_UART, WIRELESS_UART_INDEX, wireless_uart_callback);
  200   1          
  201   1          fifo_init(&wireless_uart_fifo, FIFO_DATA_8BIT, wireless_uart_buffer, WIRELESS_UART_BUFFER_SIZE);
  202   1          gpio_init(WIRELESS_UART_RTS_PIN, GPIO, GPIO_HIGH, GPIO_NO_PULL);
  203   1      #if(0 == WIRELESS_UART_AUTO_BAUD_RATE)                                          // ¹Ø±Õ×Ô¶¯²¨ÌØÂÊ
  204   1          // ±¾º¯ÊýÊ¹ÓÃµÄ²¨ÌØÂÊÎª115200 ÎªÎÞÏß×ª´®¿ÚÄ£¿éµÄÄ¬ÈÏ²¨ÌØÂÊ ÈçÐèÆäËû²¨ÌØÂÊÇë×ÔÐÐÅäÖÃÄ£¿é²¢ÐÞ¸Ä´®¿ÚµÄ²¨
             -ÌØÂÊ
  205   1          uart_init (WIRELESS_UART_INDEX, WIRELESS_UART_BUAD_RATE, WIRELESS_UART_RX_PIN, WIRELESS_UART_TX_PIN);
             -   // ³õÊ¼»¯´®¿Ú
  206   1          uart_rx_interrupt(WIRELESS_UART_INDEX, 1);
  207   1      #elif(1 == WIRELESS_UART_AUTO_BAUD_RATE)                                        // ¿ªÆô×Ô¶¯²¨ÌØÂÊ
                   uint8 rts_init_status = 0;
                   uint16 time_count = 0;
                   
                   wireless_auto_baud_flag = WIRELESS_UART_AUTO_BAUD_RATE_INIT;
                   wireless_auto_baud_data[0] = 0;
                   wireless_auto_baud_data[1] = 1;
                   wireless_auto_baud_data[2] = 3;
                   
                   rts_init_status = gpio_get_level(WIRELESS_UART_RTS_PIN);
                   gpio_init(WIRELESS_UART_RTS_PIN, GPO, rts_init_status, GPO_PUSH_PULL);      // ³õÊ¼»¯Á÷¿ØÒý½Å
                   
                   uart_init (WIRELESS_UART_INDEX, WIRELESS_UART_BUAD_RATE, WIRELESS_UART_RX_PIN, WIRELESS_UART_TX_PIN);
             -   // ³õÊ¼»¯´®¿Ú
                   uart_rx_interrupt(WIRELESS_UART_INDEX, 1);
                   
                   system_delay_ms(5);                                                         // Ä£¿éÉÏµçÖ®ºóÐèÒªÑÓÊ±µÈ
             -´ý
                   gpio_set_level(WIRELESS_UART_RTS_PIN, !rts_init_status);                    // RTSÒý½ÅÀ­¸ß£¬½øÈë×Ô¶¯²
             -¨ÌØÂÊÄ£Ê½
                   system_delay_ms(100);                                                       // RTSÀ­¸ßÖ®ºó±ØÐëÑÓÊ±20m
             -s
                   gpio_toggle_level(WIRELESS_UART_RTS_PIN);                                   // RTSÒý½ÅÈ¡·´
                   
                   do
                   {
                       wireless_auto_baud_flag = WIRELESS_UART_AUTO_BAUD_RATE_START;
C251 COMPILER V5.60.0,  zf_device_wireless_uart                                            08/01/26  02:12:48  PAGE 5   

                       uart_write_byte(WIRELESS_UART_INDEX, wireless_auto_baud_data[0]);       // ·¢ËÍÌØ¶¨Êý¾Ý ÓÃÓÚÄ£¿é×
             -Ô¶¯ÅÐ¶Ï²¨ÌØÂÊ
                       uart_write_byte(WIRELESS_UART_INDEX, wireless_auto_baud_data[1]);       // ·¢ËÍÌØ¶¨Êý¾Ý ÓÃÓÚÄ£¿é×
             -Ô¶¯ÅÐ¶Ï²¨ÌØÂÊ
                       uart_write_byte(WIRELESS_UART_INDEX, wireless_auto_baud_data[2]);       // ·¢ËÍÌØ¶¨Êý¾Ý ÓÃÓÚÄ£¿é×
             -Ô¶¯ÅÐ¶Ï²¨ÌØÂÊ
                       system_delay_ms(20);
                       
                       if(WIRELESS_UART_AUTO_BAUD_RATE_GET_ACK != wireless_auto_baud_flag)     // ¼ìÑé×Ô¶¯²¨ÌØÂÊÊÇ·ñÍê³É
                       {
                           return_state = 1;                                                   // Èç¹û³ÌÐò½øÈëµ½´ËÓï¾äÄÚ
             - ËµÃ÷×Ô¶¯²¨ÌØÂÊÊ§°ÜÁË
                           break;
                       }
                       
                       time_count = 0;
                       
                       if( 0xa5 != wireless_auto_baud_data[0] &&                               // ¼ìÑé×Ô¶¯²¨ÌØÂÊÊÇ·ñÕýÈ·
                               0xff != wireless_auto_baud_data[1] &&                               // ¼ìÑé×Ô¶¯²¨ÌØÂÊÊÇ·ñ
             -ÕýÈ·
                               0xff != wireless_auto_baud_data[2] )                                // ¼ìÑé×Ô¶¯²¨ÌØÂÊÊÇ·ñ
             -ÕýÈ·
                       {
                           return_state = 1;                                                   // Èç¹û³ÌÐò½øÈëµ½´ËÓï¾äÄÚ
             - ËµÃ÷×Ô¶¯²¨ÌØÂÊÊ§°ÜÁË
                           break;
                       }
                       
                       wireless_auto_baud_flag = WIRELESS_UART_AUTO_BAUD_RATE_SUCCESS;
                       
                       gpio_init(WIRELESS_UART_RTS_PIN, GPI, 0, GPI_PULL_UP);                  // ³õÊ¼»¯Á÷¿ØÒý½Å
                       system_delay_ms(10);                                                    // ÑÓÊ±µÈ´ý Ä£¿é×¼±¸¾ÍÐ÷
                   }
                   while(0);
                   
               #endif
  259   1          return return_state;
  260   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       562     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        87         17
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        52     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
