C251 COMPILER V5.60.0,  zf_device_icm20602                                                 08/01/26  02:12:47  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_device_icm20602
OBJECT MODULE PLACED IN .\out_file\zf_device_icm20602.obj
COMPILER INVOKED BY: E:\Tools\keil5\Keil_v5\C251\BIN\C251.EXE ..\..\libraries\zf_device\zf_device_icm20602.c LARGE NOALI
                    -AS WARNINGLEVEL(3) OPTIMIZE(SIZE) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\
                    -zf_device;..\..\libraries\zf_driver;..\user;..\code) DEBUG PRINT(.\out_file\zf_device_icm20602.lst) TABS(2) OBJECT(.\out
                    -_file\zf_device_icm20602.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * STC32G Opensourec Library å³ï¼ˆSTC32G å¼€æºåº“ï¼‰æ˜¯ä¸€ä¸ªåŸºäºå®˜æ–¹ SDK æ¥å£çš„ç¬¬ä¸‰æ–¹å¼€æºåº
             -“
    3          * Copyright (c) 2022 SEEKFREE é€é£ç§‘æŠ€
    4          *
    5          * æœ¬æ–‡ä»¶æ˜¯STC å¼€æºåº“çš„ä¸€éƒ¨åˆ†
    6          *
    7          * STC32G å¼€æºåº“ æ˜¯å…è´¹è½¯ä»¶
    8          * æ‚¨å¯ä»¥æ ¹æ®è‡ªç”±è½¯ä»¶åŸºé‡‘ä¼šå‘å¸ƒçš„ GPLï¼ˆGNU General Public Licenseï¼Œå³ GNUé€šç”¨å…¬å…±è®¸
             -å¯è¯ï¼‰çš„æ¡æ¬¾
    9          * å³ GPL çš„ç¬¬3ç‰ˆï¼ˆå³ GPL3.0ï¼‰æˆ–ï¼ˆæ‚¨é€‰æ‹©çš„ï¼‰ä»»ä½•åæ¥çš„ç‰ˆæœ¬ï¼Œé‡æ–°å‘å¸ƒå’Œ/æˆ–ä¿®æ”
             -¹å®ƒ
   10          *
   11          * æœ¬å¼€æºåº“çš„å‘å¸ƒæ˜¯å¸Œæœ›å®ƒèƒ½å‘æŒ¥ä½œç”¨ï¼Œä½†å¹¶æœªå¯¹å…¶ä½œä»»ä½•çš„ä¿è¯
   12          * ç”šè‡³æ²¡æœ‰éšå«çš„é€‚é”€æ€§æˆ–é€‚åˆç‰¹å®šç”¨é€”çš„ä¿è¯
   13          * æ›´å¤šç»†èŠ‚è¯·å‚è§ GPL
   14          *
   15          * æ‚¨åº”è¯¥åœ¨æ”¶åˆ°æœ¬å¼€æºåº“çš„åŒæ—¶æ”¶åˆ°ä¸€ä»½ GPL çš„å‰¯æœ¬
   16          * å¦‚æœæ²¡æœ‰ï¼Œè¯·å‚é˜…<https://www.gnu.org/licenses/>
   17          *
   18          * é¢å¤–æ³¨æ˜ï¼š
   19          * æœ¬å¼€æºåº“ä½¿ç”¨ GPL3.0 å¼€æºè®¸å¯è¯åè®® ä»¥ä¸Šè®¸å¯ç”³æ˜ä¸ºè¯‘æ–‡ç‰ˆæœ¬
   20          * è®¸å¯ç”³æ˜è‹±æ–‡ç‰ˆåœ¨ libraries/doc æ–‡ä»¶å¤¹ä¸‹çš„ GPL3_permission_statement.txt æ–‡ä»¶ä¸­
   21          * è®¸å¯è¯å‰¯æœ¬åœ¨ libraries æ–‡ä»¶å¤¹ä¸‹ å³è¯¥æ–‡ä»¶å¤¹ä¸‹çš„ LICENSE æ–‡ä»¶
   22          * æ¬¢è¿å„ä½ä½¿ç”¨å¹¶ä¼ æ’­æœ¬ç¨‹åº ä½†ä¿®æ”¹å†…å®¹æ—¶å¿…é¡»ä¿ç•™é€é£ç§‘æŠ€çš„ç‰ˆæƒå£°æ˜ï¼ˆå³æœ¬
             -å£°æ˜ï¼‰
   23          *
   24          * æ–‡ä»¶åç§°          
   25          * å…¬å¸åç§°          æˆéƒ½é€é£ç§‘æŠ€æœ‰é™å…¬å¸
   26          * ç‰ˆæœ¬ä¿¡æ¯          æŸ¥çœ‹ libraries/doc æ–‡ä»¶å¤¹å†… version æ–‡ä»¶ ç‰ˆæœ¬è¯´æ˜
   27          * å¼€å‘ç¯å¢ƒ          MDK FOR C251
   28          * é€‚ç”¨å¹³å°          STC32G
   29          * åº—é“ºé“¾æ¥          https://seekfree.taobao.com/
   30          *
   31          * ä¿®æ”¹è®°å½•
   32          * æ—¥æœŸ              ä½œè€…           å¤‡æ³¨
   33          * 2024-08-01        å¤§W            first version
   34          *********************************************************************************************************
             -***********/
   35          /********************************************************************************************************
             -*************
   36          * æ¥çº¿å®šä¹‰:
   37          *                   ------------------------------------
   38          *                   æ¨¡å—ç®¡è„š                                        å•ç‰‡æœºç®¡è„š
   39          *                   //------------------ç¡¬ä»¶ SPI å¼•è„š------------------//
   40          *                   SCL/SPC             æŸ¥çœ‹ zf_device_icm20602.h ä¸­ ICM20602_SPC_PIN å®å®šä¹‰
   41          *                   SDA/DSI             æŸ¥çœ‹ zf_device_icm20602.h ä¸­ ICM20602_SDI_PIN å®å®šä¹‰
   42          *                   SA0/SDO             æŸ¥çœ‹ zf_device_icm20602.h ä¸­ ICM20602_SDO_PIN å®å®šä¹‰
   43          *                   CS                  æŸ¥çœ‹ zf_device_icm20602.h ä¸­ IPS114_CS_PIN å®å®šä¹‰
   44          *                   //------------------ç¡¬ä»¶ SPI å¼•è„š------------------//
   45          *                   //------------------è½¯ä»¶ IIC å¼•è„š------------------//
   46          *                   SCL/SPC             æŸ¥çœ‹ zf_device_icm20602.h ä¸­ ICM20602_SCL_PIN å®å®šä¹‰
   47          *                   SDA/DSI             æŸ¥çœ‹ zf_device_icm20602.h ä¸­ ICM20602_SDA_PIN å®å®šä¹‰
   48          *                   //------------------è½¯ä»¶ IIC å¼•è„š------------------//
   49          *                   ç”µæºå¼•è„š
C251 COMPILER V5.60.0,  zf_device_icm20602                                                 08/01/26  02:12:47  PAGE 2   

   50          *                   VCC                 3.3Vç”µæº
   51          *                   GND                 ç”µæºåœ°
   52          *                   ------------------------------------
   53          *********************************************************************************************************
             -***********/
   54          
   55          #include "zf_common_clock.h"
   56          #include "zf_common_debug.h"
   57          #include "zf_driver_delay.h"
   58          #include "zf_driver_spi.h"
   59          #include "zf_driver_soft_iic.h"
   60          #include "zf_driver_soft_spi.h"
   61          
   62          #include "zf_device_icm20602.h"
   63          
   64          #pragma warning disable = 183
   65          #pragma warning disable = 177
   66          
   67          int16 icm20602_gyro_x = 0, icm20602_gyro_y = 0, icm20602_gyro_z = 0;            // ä¸‰è½´é™€èºä»ªæ•°æ® 
             -     gyro (é™€èºä»ª)
   68          int16 icm20602_acc_x = 0, icm20602_acc_y = 0, icm20602_acc_z = 0;               // ä¸‰è½´åŠ é€Ÿåº¦è®¡æ•°æ
             -®    acc (accelerometer åŠ é€Ÿåº¦è®¡)
   69          float icm20602_transition_factor[2] = {4096, 16.4};
   70          
   71          #if (ICM20602_USE_INTERFACE==HARDWARE_SPI)                               // è¿™ä¸¤æ®µ é¢œè‰²æ­£å¸¸çš„æ‰æ
             -˜¯æ­£ç¡®çš„ é¢œè‰²ç°çš„å°±æ˜¯æ²¡æœ‰ç”¨çš„
               
                 //------------------------------------------------------------------------------------------------------
             --------------
                 // å‡½æ•°ç®€ä»‹     ICM20602 å†™å¯„å­˜å™¨
                 // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
                 // å‚æ•°è¯´æ˜     data            æ•°æ®
                 // è¿”å›å‚æ•°     void
                 // ä½¿ç”¨ç¤ºä¾‹     icm20602_write_register(ICM20602_PWR_MGMT_1, 0x80);
                 // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
                 //------------------------------------------------------------------------------------------------------
             --------------
                 static void icm20602_write_register (uint8 reg, uint8 dat)
                 {
                   ICM20602_CS(0);
                   spi_write_8bit_register(ICM20602_SPI, reg | ICM20602_SPI_W, dat);
                   ICM20602_CS(1);
                 }
               
                 //------------------------------------------------------------------------------------------------------
             --------------
                 // å‡½æ•°ç®€ä»‹     ICM20602 è¯»å¯„å­˜å™¨
                 // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
                 // è¿”å›å‚æ•°     uint8           æ•°æ®
                 // ä½¿ç”¨ç¤ºä¾‹     icm20602_read_register(ICM20602_WHO_AM_I);
                 // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
                 //------------------------------------------------------------------------------------------------------
             --------------
                 static uint8 icm20602_read_register (uint8 reg)
                 {
                   uint8 dat = 0;
                   ICM20602_CS(0);
                   dat = spi_read_8bit_register(ICM20602_SPI, reg | ICM20602_SPI_R);
                   ICM20602_CS(1);
                   return dat;
                 }
               
                 //------------------------------------------------------------------------------------------------------
             --------------
                 // å‡½æ•°ç®€ä»‹     ICM20602 è¯»æ•°æ®
                 // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
C251 COMPILER V5.60.0,  zf_device_icm20602                                                 08/01/26  02:12:47  PAGE 3   

                 // å‚æ•°è¯´æ˜     data            æ•°æ®ç¼“å†²åŒº
                 // å‚æ•°è¯´æ˜     len             æ•°æ®é•¿åº¦
                 // è¿”å›å‚æ•°     void
                 // ä½¿ç”¨ç¤ºä¾‹     icm20602_read_registers(ICM20602_ACCEL_XOUT_H, dat, 6);
                 // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
                 //------------------------------------------------------------------------------------------------------
             --------------
                 static void icm20602_read_registers (uint8 reg, uint8 *dat, uint32 len)
                 {
                   ICM20602_CS(0);
                   spi_read_8bit_registers(ICM20602_SPI, reg | ICM20602_SPI_R, dat, len);
                   ICM20602_CS(1);
                 }
               
               #elif (ICM20602_USE_INTERFACE==SOFT_SPI)
  121            #define ICM20602_SCK(x)       (ICM20602_SPC_PIN   = x)
  122            #define ICM20602_MOSI(x)      (ICM20602_SDI_PIN   = x)
  123            #define ICM20602_MISO         (ICM20602_SDO_PIN    )
  124            #define ICM20602_CS(x)              (ICM20602_CS_PIN  = x)
  125            //------------------------------------------------------------------------------------------------------
             --------------
  126            //  @brief      é€šè¿‡SPIå†™ä¸€ä¸ªbyte,åŒæ—¶è¯»å–ä¸€ä¸ªbyte
  127            //  @param      byte        å‘é€çš„æ•°æ®
  128            //  @return     uint8 edata       return è¿”å›statusçŠ¶æ€
  129            //  @since      v1.0
  130            //  Sample usage:
  131            //------------------------------------------------------------------------------------------------------
             --------------
  132            static uint8 icm20602_simspi_wr_byte(uint8 byte)
  133            {
  134   1          uint8 i;
  135   1          for(i=0; i<8; i++)
  136   1          {
  137   2            ICM20602_SCK (0);
  138   2            ICM20602_MOSI(byte&0x80);
  139   2            byte <<= 1;
  140   2            ICM20602_SCK (1);
  141   2            byte |= ICM20602_MISO;
  142   2          }
  143   1          return(byte);
  144   1        }
  145            
  146            //------------------------------------------------------------------------------------------------------
             --------------
  147            //  @brief      å°†valå†™å…¥cmdå¯¹åº”çš„å¯„å­˜å™¨åœ°å€,åŒæ—¶è¿”å›statuså­—èŠ‚
  148            //  @param      cmd         å‘½ä»¤å­—
  149            //  @param      val         å¾…å†™å…¥å¯„å­˜å™¨çš„æ•°å€¼
  150            //  @since      v1.0
  151            //  Sample usage:
  152            //------------------------------------------------------------------------------------------------------
             --------------
  153            static void icm20602_simspi_w_reg_byte(uint8 cmd, uint8 val)
  154            {
  155   1          cmd |= ICM20602_SPI_W;
  156   1          icm20602_simspi_wr_byte(cmd);
  157   1          icm20602_simspi_wr_byte(val);
  158   1        }
  159          
  160            //------------------------------------------------------------------------------------------------------
             --------------
  161            //  @brief      è¯»å–cmdæ‰€å¯¹åº”çš„å¯„å­˜å™¨åœ°å€
  162            //  @param      cmd         å‘½ä»¤å­—
  163            //  @param      *val        å­˜å‚¨è¯»å–çš„æ•°æ®åœ°å€
  164            //  @since      v1.0
  165            //  Sample usage:
  166            //------------------------------------------------------------------------------------------------------
C251 COMPILER V5.60.0,  zf_device_icm20602                                                 08/01/26  02:12:47  PAGE 4   

             --------------
  167            static void icm20602_simspi_r_reg_byte(uint8 cmd, uint8 *val)
  168            {
  169   1          cmd |= ICM20602_SPI_R;
  170   1          icm20602_simspi_wr_byte(cmd);
  171   1          *val = icm20602_simspi_wr_byte(0);
  172   1        }
  173          
  174            //------------------------------------------------------------------------------------------------------
             --------------
  175            //  @brief      è¯»å–cmdæ‰€å¯¹åº”çš„å¯„å­˜å™¨åœ°å€
  176            //  @param      cmd         å‘½ä»¤å­—
  177            //  @param      *val        å­˜å‚¨è¯»å–çš„æ•°æ®åœ°å€
  178            //  @param      num         è¯»å–çš„æ•°é‡
  179            //  @since      v1.0
  180            //  Sample usage:
  181            //------------------------------------------------------------------------------------------------------
             --------------
  182            static void icm20602_simspi_r_reg_bytes(uint8 cmd, uint8 *val, uint32 num)
  183            {
  184   1          uint32 edata i = 0;
  185   1          cmd |= ICM20602_SPI_R;
  186   1          icm20602_simspi_wr_byte(cmd);
  187   1          while(num--)
  188   1          {
  189   2            *val++ = icm20602_simspi_wr_byte(0);
  190   2          }
  191   1        }
  192          
  193            //------------------------------------------------------------------------------------------------------
             --------------
  194            // å‡½æ•°ç®€ä»‹     IMU660RA å†™å¯„å­˜å™¨
  195            // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
  196            // å‚æ•°è¯´æ˜     dat            æ•°æ®
  197            // è¿”å›å‚æ•°     void
  198            // ä½¿ç”¨ç¤ºä¾‹     icm20602_write_register(ICM20602_PWR_CONF, 0x00);                   // å…³é—­é«˜çº§ç
             -œç”µæ¨¡å¼
  199            // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  200            //------------------------------------------------------------------------------------------------------
             --------------
  201            static void icm20602_write_register(uint8 reg, uint8 dat)
  202            {
  203   1          ICM20602_CS(0);
  204   1          icm20602_simspi_w_reg_byte(reg | ICM20602_SPI_W, dat);
  205   1          ICM20602_CS(1);
  206   1        }
  207          
  208            //------------------------------------------------------------------------------------------------------
             --------------
  209            // å‡½æ•°ç®€ä»‹     IMU660RA è¯»å¯„å­˜å™¨
  210            // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
  211            // è¿”å›å‚æ•°     uint8 edata           æ•°æ®
  212            // ä½¿ç”¨ç¤ºä¾‹     icm20602_read_register(ICM20602_CHIP_ID);
  213            // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  214            //------------------------------------------------------------------------------------------------------
             --------------
  215            static uint8 icm20602_read_register(uint8 reg)
  216            {
  217   1          uint8 dat;
  218   1          ICM20602_CS(0);
  219   1          icm20602_simspi_r_reg_byte(reg | ICM20602_SPI_R, &dat);
  220   1          ICM20602_CS(1);
  221   1          return dat;
  222   1        }
  223          
  224            //------------------------------------------------------------------------------------------------------
C251 COMPILER V5.60.0,  zf_device_icm20602                                                 08/01/26  02:12:47  PAGE 5   

             --------------
  225            // å‡½æ•°ç®€ä»‹     IMU660RA è¯»æ•°æ®
  226            // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
  227            // å‚æ•°è¯´æ˜     dat            æ•°æ®ç¼“å†²åŒº
  228            // å‚æ•°è¯´æ˜     len             æ•°æ®é•¿åº¦
  229            // è¿”å›å‚æ•°     void
  230            // ä½¿ç”¨ç¤ºä¾‹     icm20602_read_registers(ICM20602_ACC_ADDRESS, dat, 6);
  231            // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  232            //------------------------------------------------------------------------------------------------------
             --------------
  233            static void icm20602_read_registers(uint8 reg, uint8 *dat, uint32 len)
  234            {
  235   1          ICM20602_CS(0);
  236   1          icm20602_simspi_r_reg_bytes(reg | ICM20602_SPI_R, dat, len);
  237   1          ICM20602_CS(1);
  238   1        }
  239          
  240          #elif (ICM20602_USE_INTERFACE==SOFT_IIC)
               
                 static soft_iic_info_struct icm20602_iic_struct;
               
                 //------------------------------------------------------------------------------------------------------
             --------------
                 // å‡½æ•°ç®€ä»‹     ICM20602 å†™å¯„å­˜å™¨
                 // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
                 // å‚æ•°è¯´æ˜     dat            æ•°æ®
                 // è¿”å›å‚æ•°     void
                 // ä½¿ç”¨ç¤ºä¾‹     icm20602_write_register(ICM20602_PWR_MGMT_1, 0x80);
                 // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
                 //------------------------------------------------------------------------------------------------------
             --------------
                 #define icm20602_write_register(reg, dat)      (soft_iic_write_8bit_register(&icm20602_iic_struct, (reg)
             -, (dat)))
               
                 //------------------------------------------------------------------------------------------------------
             --------------
                 // å‡½æ•°ç®€ä»‹     ICM20602 è¯»å¯„å­˜å™¨
                 // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
                 // è¿”å›å‚æ•°     uint8           æ•°æ®
                 // ä½¿ç”¨ç¤ºä¾‹     icm20602_read_register(ICM20602_WHO_AM_I);
                 // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
                 //------------------------------------------------------------------------------------------------------
             --------------
                 #define icm20602_read_register(reg)             (soft_iic_read_8bit_register(&icm20602_iic_struct, (reg)
             -))
               
                 //------------------------------------------------------------------------------------------------------
             --------------
                 // å‡½æ•°ç®€ä»‹     ICM20602 è¯»æ•°æ®
                 // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
                 // å‚æ•°è¯´æ˜     dat            æ•°æ®ç¼“å†²åŒº
                 // å‚æ•°è¯´æ˜     len             æ•°æ®é•¿åº¦
                 // è¿”å›å‚æ•°     void
                 // ä½¿ç”¨ç¤ºä¾‹     icm20602_read_registers(ICM20602_ACCEL_XOUT_H, dat, 6);
                 // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
                 //------------------------------------------------------------------------------------------------------
             --------------
                 #define icm20602_read_registers(reg, dat, len) (soft_iic_read_8bit_registers(&icm20602_iic_struct, (reg)
             -, (dat), (len)))
               
               #endif
  275          
  276          
  277          //-------------------------------------------------------------------------------------------------------
             -------------
  278          // å‡½æ•°ç®€ä»‹     ICM20602 è‡ªæ£€
C251 COMPILER V5.60.0,  zf_device_icm20602                                                 08/01/26  02:12:47  PAGE 6   

  279          // å‚æ•°è¯´æ˜     void
  280          // è¿”å›å‚æ•°     uint8           1-è‡ªæ£€å¤±è´¥ 0-è‡ªæ£€æˆåŠŸ
  281          // ä½¿ç”¨ç¤ºä¾‹     icm20602_self_check();
  282          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  283          //-------------------------------------------------------------------------------------------------------
             -------------
  284          static uint8 icm20602_self_check (void)
  285          {
  286   1          uint8 dat = 0, return_state = 0;
  287   1          uint16 timeout_count = 0;
  288   1          
  289   1          while(0x12 != dat)                                                          // åˆ¤æ–­ ID æ˜¯å¦æ­£ç¡®
  290   1          {
  291   2              if(ICM20602_TIMEOUT_COUNT < timeout_count ++)
  292   2              {
  293   3                  return_state =  1;
  294   3                  break;
  295   3              }
  296   2              
  297   2              dat = icm20602_read_register(ICM20602_WHO_AM_I);
  298   2              system_delay_ms(10);
  299   2          }
  300   1          
  301   1          return return_state;
  302   1      }
  303          
  304          //-------------------------------------------------------------------------------------------------------
             -------------
  305          // å‡½æ•°ç®€ä»‹     è·å– ICM20602 åŠ é€Ÿåº¦è®¡æ•°æ®
  306          // å‚æ•°è¯´æ˜     void
  307          // è¿”å›å‚æ•°     void
  308          // ä½¿ç”¨ç¤ºä¾‹     icm20602_get_acc();                                             // æ‰§è¡Œè¯¥å‡½æ•°å
             -ï¼Œç›´æ¥æŸ¥çœ‹å¯¹åº”çš„å˜é‡å³å¯
  309          // å¤‡æ³¨ä¿¡æ¯
  310          //-------------------------------------------------------------------------------------------------------
             -------------
  311          void icm20602_get_acc (void)
  312          {
  313   1          uint8 dat[6];
  314   1          
  315   1          icm20602_read_registers(ICM20602_ACCEL_XOUT_H, dat, 6);
  316   1          icm20602_acc_x = (int16)(((uint16)dat[0] << 8 | dat[1]));
  317   1          icm20602_acc_y = (int16)(((uint16)dat[2] << 8 | dat[3]));
  318   1          icm20602_acc_z = (int16)(((uint16)dat[4] << 8 | dat[5]));
  319   1      }
  320          
  321          //-------------------------------------------------------------------------------------------------------
             -------------
  322          // å‡½æ•°ç®€ä»‹     è·å–ICM20602é™€èºä»ªæ•°æ®
  323          // å‚æ•°è¯´æ˜     void
  324          // è¿”å›å‚æ•°     void
  325          // ä½¿ç”¨ç¤ºä¾‹     icm20602_get_gyro();                                            // æ‰§è¡Œè¯¥å‡½æ•°å
             -ï¼Œç›´æ¥æŸ¥çœ‹å¯¹åº”çš„å˜é‡å³å¯
  326          // å¤‡æ³¨ä¿¡æ¯
  327          //-------------------------------------------------------------------------------------------------------
             -------------
  328          void icm20602_get_gyro (void)
  329          {
  330   1          uint8 dat[6];
  331   1          
  332   1          icm20602_read_registers(ICM20602_GYRO_XOUT_H, dat, 6);
  333   1          icm20602_gyro_x = (int16)(((uint16)dat[0] << 8 | dat[1]));
  334   1          icm20602_gyro_y = (int16)(((uint16)dat[2] << 8 | dat[3]));
  335   1          icm20602_gyro_z = (int16)(((uint16)dat[4] << 8 | dat[5]));
  336   1      }
  337          
C251 COMPILER V5.60.0,  zf_device_icm20602                                                 08/01/26  02:12:47  PAGE 7   

  338          //-------------------------------------------------------------------------------------------------------
             -------------
  339          // å‡½æ•°ç®€ä»‹     åˆå§‹åŒ– ICM20602
  340          // å‚æ•°è¯´æ˜     void
  341          // è¿”å›å‚æ•°     uint8           1-åˆå§‹åŒ–å¤±è´¥ 0-åˆå§‹åŒ–æˆåŠŸ
  342          // ä½¿ç”¨ç¤ºä¾‹     icm20602_init();
  343          // å¤‡æ³¨ä¿¡æ¯
  344          //-------------------------------------------------------------------------------------------------------
             -------------
  345          uint8 icm20602_init (void)
  346          {
  347   1          uint8 val = 0x0, return_state = 0;
  348   1          uint16 timeout_count = 0;
  349   1          
  350   1          system_delay_ms(10);                                                        // ä¸Šç”µå»¶æ—¶
  351   1          
  352   1      #if (ICM20602_USE_INTERFACE==HARDWARE_SPI)
                 
                 spi_init(ICM20602_SPI, SPI_MODE0, ICM20602_SPI_SPEED, ICM20602_SPC_PIN, ICM20602_SDI_PIN, ICM20602_SDO_P
             -IN, SPI_CS_NULL);
                   gpio_init(ICM20602_CS_PIN, GPO, GPIO_HIGH, GPO_PUSH_PULL);
                 
               #elif (ICM20602_USE_INTERFACE==SOFT_SPI)
  358   1        
  359   1        // é»˜è®¤ä½¿ç”¨åŒå‘IOï¼Œä¸éœ€è¦åˆå§‹åŒ–ã€‚
  360   1      //  soft_spi_init(ICM20602_SPI, SPI_MODE0, 0, ICM20602_SPC_PIN, ICM20602_SDI_PIN, ICM20602_SDO_PIN, ICM206
             -02_CS_PIN);
  361   1      
  362   1      #elif (ICM20602_USE_INTERFACE==SOFT_IIC)
                 
                 soft_iic_init(&icm20602_iic_struct, ICM20602_DEV_ADDR, ICM20602_SOFT_IIC_DELAY, ICM20602_SCL_PIN, ICM206
             -02_SDA_PIN);
               
               #endif
  367   1        
  368   1          
  369   1          do
  370   1          {
  371   2              if(icm20602_self_check())
  372   2              {
  373   3                  // å¦‚æœç¨‹åºåœ¨è¾“å‡ºäº†æ–­è¨€ä¿¡æ¯ å¹¶ä¸”æç¤ºå‡ºé”™ä½ç½®åœ¨è¿™é‡Œ
  374   3                  // é‚£ä¹ˆå°±æ˜¯ ICM20602 è‡ªæ£€å‡ºé”™å¹¶è¶…æ—¶é€€å‡ºäº†
  375   3                  // æ£€æŸ¥ä¸€ä¸‹æ¥çº¿æœ‰æ²¡æœ‰é—®é¢˜ å¦‚æœæ²¡é—®é¢˜å¯èƒ½å°±æ˜¯åäº†
  376   3                  printf( "icm20602 self check error.\r\n");
  377   3                  return_state = 1;
  378   3                  break;
  379   3              }
  380   2              
  381   2              icm20602_write_register(ICM20602_PWR_MGMT_1, 0x80);                     // å¤ä½è®¾å¤‡
  382   2              system_delay_ms(2);
  383   2              
  384   2              do
  385   2              {
  386   3                  // ç­‰å¾…å¤ä½æˆåŠŸ
  387   3                  val = icm20602_read_register(ICM20602_PWR_MGMT_1);
  388   3                  
  389   3                  if(ICM20602_TIMEOUT_COUNT < timeout_count ++)
  390   3                  {
  391   4                      // å¦‚æœç¨‹åºåœ¨è¾“å‡ºäº†æ–­è¨€ä¿¡æ¯ å¹¶ä¸”æç¤ºå‡ºé”™ä½ç½®åœ¨è¿™é‡Œ
  392   4                      // é‚£ä¹ˆå°±æ˜¯ ICM20602 è‡ªæ£€å‡ºé”™å¹¶è¶…æ—¶é€€å‡ºäº†
  393   4                      // æ£€æŸ¥ä¸€ä¸‹æ¥çº¿æœ‰æ²¡æœ‰é—®é¢˜ å¦‚æœæ²¡é—®é¢˜å¯èƒ½å°±æ˜¯åäº†
  394   4                      printf( "icm20602 reset error.\r\n");
  395   4                      return_state = 1;
  396   4                      break;
  397   4                  }
  398   3              }
C251 COMPILER V5.60.0,  zf_device_icm20602                                                 08/01/26  02:12:47  PAGE 8   

  399   2              while(0x41 != val);
  400   2              
  401   2              if(1 == return_state)
  402   2              {
  403   3                  break;
  404   3              }
  405   2              
  406   2              icm20602_write_register(ICM20602_PWR_MGMT_1,     0x01);                 // æ—¶é’Ÿè®¾ç½®
  407   2              icm20602_write_register(ICM20602_PWR_MGMT_2,     0x00);                 // å¼€å¯é™€èºä»ªå’ŒåŠ é
             -€Ÿåº¦è®¡
  408   2              icm20602_write_register(ICM20602_CONFIG,         0x01);                 // 176HZ 1KHZ
  409   2              icm20602_write_register(ICM20602_SMPLRT_DIV,     0x07);                 // é‡‡æ ·é€Ÿç‡ SAMPLE_RA
             -TE = INTERNAL_SAMPLE_RATE / (1 + SMPLRT_DIV)
  410   2              
  411   2              // ICM20602_ACCEL_CONFIG å¯„å­˜å™¨
  412   2              // è®¾ç½®ä¸º 0x00 åŠ é€Ÿåº¦è®¡é‡ç¨‹ä¸º Â±2  g   è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ®é™¤ä»¥ 16384  å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ g(m/s^2)
  413   2              // è®¾ç½®ä¸º 0x08 åŠ é€Ÿåº¦è®¡é‡ç¨‹ä¸º Â±4  g   è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ®é™¤ä»¥ 8192   å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ g(m/s^2)
  414   2              // è®¾ç½®ä¸º 0x10 åŠ é€Ÿåº¦è®¡é‡ç¨‹ä¸º Â±8  g   è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ®é™¤ä»¥ 4096   å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ g(m/s^2)
  415   2              // è®¾ç½®ä¸º 0x18 åŠ é€Ÿåº¦è®¡é‡ç¨‹ä¸º Â±16 g   è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ®é™¤ä»¥ 2048   å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ g(m/s^2)
  416   2              switch(ICM20602_ACC_SAMPLE_DEFAULT)
  417   2              {
  418   3                  default:
  419   3                  {
  420   4                      printf( "ICM20602_ACC_SAMPLE_DEFAULT set error.\r\n");
  421   4                      return_state = 1;
  422   4                  }
  423   3                  break;
  424   3                  
  425   3                  case ICM20602_ACC_SAMPLE_SGN_2G:
  426   3                  {
  427   4                      icm20602_write_register(ICM20602_ACCEL_CONFIG, 0x00);
  428   4                      icm20602_transition_factor[0] = 16384;
  429   4                  }
  430   3                  break;
  431   3                  
  432   3                  case ICM20602_ACC_SAMPLE_SGN_4G:
  433   3                  {
  434   4                      icm20602_write_register(ICM20602_ACCEL_CONFIG, 0x08);
  435   4                      icm20602_transition_factor[0] = 8192;
  436   4                  }
  437   3                  break;
  438   3                  
  439   3                  case ICM20602_ACC_SAMPLE_SGN_8G:
  440   3                  {
  441   4                      icm20602_write_register(ICM20602_ACCEL_CONFIG, 0x10);
  442   4                      icm20602_transition_factor[0] = 4096;
  443   4                  }
  444   3                  break;
  445   3                  
  446   3                  case ICM20602_ACC_SAMPLE_SGN_16G:
  447   3                  {
  448   4                      icm20602_write_register(ICM20602_ACCEL_CONFIG, 0x18);
  449   4                      icm20602_transition_factor[0] = 2048;
  450   4                  }
  451   3                  break;
  452   3              }
  453   2              
  454   2              if(1 == return_state)
  455   2              {
  456   3                  break;
  457   3              }
  458   2              
C251 COMPILER V5.60.0,  zf_device_icm20602                                                 08/01/26  02:12:47  PAGE 9   

  459   2              // ICM20602_GYRO_CONFIG å¯„å­˜å™¨
  460   2              // è®¾ç½®ä¸º 0x00 é™€èºä»ªé‡ç¨‹ä¸º Â±250  dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 131     å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸º Â°/s
  461   2              // è®¾ç½®ä¸º 0x08 é™€èºä»ªé‡ç¨‹ä¸º Â±500  dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 65.5    å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸º Â°/s
  462   2              // è®¾ç½®ä¸º 0x10 é™€èºä»ªé‡ç¨‹ä¸º Â±1000 dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 32.8    å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸º Â°/s
  463   2              // è®¾ç½®ä¸º 0x18 é™€èºä»ªé‡ç¨‹ä¸º Â±2000 dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 16.4    å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸º Â°/s
  464   2              switch(ICM20602_GYRO_SAMPLE_DEFAULT)
  465   2              {
  466   3                  default:
  467   3                  {
  468   4                      printf( "ICM20602_GYRO_SAMPLE_DEFAULT set error.\r\n");
  469   4                      return_state = 1;
  470   4                  }
  471   3                  break;
  472   3                  
  473   3                  case ICM20602_GYRO_SAMPLE_SGN_250DPS:
  474   3                  {
  475   4                      icm20602_write_register(ICM20602_GYRO_CONFIG, 0x00);
  476   4                      icm20602_transition_factor[1] = 131.0;
  477   4                  }
  478   3                  break;
  479   3                  
  480   3                  case ICM20602_GYRO_SAMPLE_SGN_500DPS:
  481   3                  {
  482   4                      icm20602_write_register(ICM20602_GYRO_CONFIG, 0x08);
  483   4                      icm20602_transition_factor[1] = 65.5;
  484   4                  }
  485   3                  break;
  486   3                  
  487   3                  case ICM20602_GYRO_SAMPLE_SGN_1000DPS:
  488   3                  {
  489   4                      icm20602_write_register(ICM20602_GYRO_CONFIG, 0x10);
  490   4                      icm20602_transition_factor[1] = 32.8;
  491   4                  }
  492   3                  break;
  493   3                  
  494   3                  case ICM20602_GYRO_SAMPLE_SGN_2000DPS:
  495   3                  {
  496   4                      icm20602_write_register(ICM20602_GYRO_CONFIG, 0x18);
  497   4                      icm20602_transition_factor[1] = 16.4;
  498   4                  }
  499   3                  break;
  500   3              }
  501   2              
  502   2              if(1 == return_state)
  503   2              {
  504   3                  break;
  505   3              }
  506   2              
  507   2              icm20602_write_register(ICM20602_ACCEL_CONFIG_2, 0x03);                 // Average 4 samples   44
             -.8HZ   //0x23 Average 16 samples
  508   2          }
  509   1          while(0);
  510   1          
  511   1          return return_state;
  512   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       581     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
C251 COMPILER V5.60.0,  zf_device_icm20602                                                 08/01/26  02:12:47  PAGE 10  

  pdata size           =    ------     ------
  xdata size           =        20         17
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       191     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
