C251 COMPILER V5.60.0,  zf_device_imu660rb                                                 08/01/26  02:12:47  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_device_imu660rb
OBJECT MODULE PLACED IN .\out_file\zf_device_imu660rb.obj
COMPILER INVOKED BY: E:\Tools\keil5\Keil_v5\C251\BIN\C251.EXE ..\..\libraries\zf_device\zf_device_imu660rb.c LARGE NOALI
                    -AS WARNINGLEVEL(3) OPTIMIZE(SIZE) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\
                    -zf_device;..\..\libraries\zf_driver;..\user;..\code) DEBUG PRINT(.\out_file\zf_device_imu660rb.lst) TABS(2) OBJECT(.\out
                    -_file\zf_device_imu660rb.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * STC32G Opensourec Library ¼´£¨STC32G ¿ªÔ´¿â£©ÊÇÒ»¸ö»ùÓÚ¹Ù·½ SDK ½Ó¿ÚµÄµÚÈý·½¿ªÔ´¿â
    3          * Copyright (c) 2022 SEEKFREE Öð·É¿Æ¼¼
    4          *
    5          * ±¾ÎÄ¼þÊÇSTC ¿ªÔ´¿âµÄÒ»²¿·Ö
    6          *
    7          * STC32G ¿ªÔ´¿â ÊÇÃâ·ÑÈí¼þ
    8          * Äú¿ÉÒÔ¸ù¾Ý×ÔÓÉÈí¼þ»ù½ð»á·¢²¼µÄ GPL£¨GNU General Public License£¬¼´ GNUÍ¨ÓÃ¹«¹²Ðí¿ÉÖ¤£©µÄÌõ¿î
    9          * ¼´ GPL µÄµÚ3°æ£¨¼´ GPL3.0£©»ò£¨ÄúÑ¡ÔñµÄ£©ÈÎºÎºóÀ´µÄ°æ±¾£¬ÖØÐÂ·¢²¼ºÍ/»òÐÞ¸ÄËü
   10          *
   11          * ±¾¿ªÔ´¿âµÄ·¢²¼ÊÇÏ£ÍûËüÄÜ·¢»Ó×÷ÓÃ£¬µ«²¢Î´¶ÔÆä×÷ÈÎºÎµÄ±£Ö¤
   12          * ÉõÖÁÃ»ÓÐÒþº¬µÄÊÊÏúÐÔ»òÊÊºÏÌØ¶¨ÓÃÍ¾µÄ±£Ö¤
   13          * ¸ü¶àÏ¸½ÚÇë²Î¼û GPL
   14          *
   15          * ÄúÓ¦¸ÃÔÚÊÕµ½±¾¿ªÔ´¿âµÄÍ¬Ê±ÊÕµ½Ò»·Ý GPL µÄ¸±±¾
   16          * Èç¹ûÃ»ÓÐ£¬Çë²ÎÔÄ<https://www.gnu.org/licenses/>
   17          *
   18          * ¶îÍâ×¢Ã÷£º
   19          * ±¾¿ªÔ´¿âÊ¹ÓÃ GPL3.0 ¿ªÔ´Ðí¿ÉÖ¤Ð­Òé ÒÔÉÏÐí¿ÉÉêÃ÷ÎªÒëÎÄ°æ±¾
   20          * Ðí¿ÉÉêÃ÷Ó¢ÎÄ°æÔÚ libraries/doc ÎÄ¼þ¼ÐÏÂµÄ GPL3_permission_statement.txt ÎÄ¼þÖÐ
   21          * Ðí¿ÉÖ¤¸±±¾ÔÚ libraries ÎÄ¼þ¼ÐÏÂ ¼´¸ÃÎÄ¼þ¼ÐÏÂµÄ LICENSE ÎÄ¼þ
   22          * »¶Ó­¸÷Î»Ê¹ÓÃ²¢´«²¥±¾³ÌÐò µ«ÐÞ¸ÄÄÚÈÝÊ±±ØÐë±£ÁôÖð·É¿Æ¼¼µÄ°æÈ¨ÉùÃ÷£¨¼´±¾ÉùÃ÷£©
   23          *
   24          * ÎÄ¼þÃû³Æ          
   25          * ¹«Ë¾Ãû³Æ          ³É¶¼Öð·É¿Æ¼¼ÓÐÏÞ¹«Ë¾
   26          * °æ±¾ÐÅÏ¢          ²é¿´ libraries/doc ÎÄ¼þ¼ÐÄÚ version ÎÄ¼þ °æ±¾ËµÃ÷
   27          * ¿ª·¢»·¾³          MDK FOR C251
   28          * ÊÊÓÃÆ½Ì¨          STC32G
   29          * µêÆÌÁ´½Ó          https://seekfree.taobao.com/
   30          *
   31          * ÐÞ¸Ä¼ÇÂ¼
   32          * ÈÕÆÚ              ×÷Õß           ±¸×¢
   33          * 2024-08-01        ´óW            first version
   34          *********************************************************************************************************
             -***********/
   35          /********************************************************************************************************
             -*************
   36          * ½ÓÏß¶¨Òå£º
   37          *                   ------------------------------------
   38          *                   Ä£¿é¹Ü½Å            µ¥Æ¬»ú¹Ü½Å
   39          *                   // Ó²¼þ SPI Òý½Å
   40          *                   SCL/SPC           ²é¿´ zf_device_imu660rb.h ÖÐ IMU660RB_SPC_PIN ºê¶¨Òå
   41          *                   SDA/DSI           ²é¿´ zf_device_imu660rb.h ÖÐ IMU660RB_SDI_PIN ºê¶¨Òå
   42          *                   SA0/SDO           ²é¿´ zf_device_imu660rb.h ÖÐ IMU660RB_SDO_PIN ºê¶¨Òå
   43          *                   CS                ²é¿´ zf_device_imu660rb.h ÖÐ IMU660RB_CS_PIN ºê¶¨Òå
   44          *                   VCC               3.3VµçÔ´
   45          *                   GND               µçÔ´µØ
   46          *                   ÆäÓàÒý½ÅÐü¿Õ
   47          *
   48          *                   // Èí¼þ IIC Òý½Å
   49          *                   SCL/SPC           ²é¿´ zf_device_imu660rb.h ÖÐ IMU660RB_SCL_PIN ºê¶¨Òå
   50          *                   SDA/DSI           ²é¿´ zf_device_imu660rb.h ÖÐ IMU660RB_SDA_PIN ºê¶¨Òå
   51          *                   VCC               3.3VµçÔ´
   52          *                   GND               µçÔ´µØ
   53          *                   ÆäÓàÒý½ÅÐü¿Õ
C251 COMPILER V5.60.0,  zf_device_imu660rb                                                 08/01/26  02:12:47  PAGE 2   

   54          *                   ------------------------------------
   55          *********************************************************************************************************
             -***********/
   56          
   57          #include "zf_common_debug.h"
   58          #include "zf_driver_delay.h"
   59          #include "zf_driver_spi.h"
   60          #include "zf_driver_gpio.h"
   61          #include "zf_driver_soft_iic.h"
   62          #include "zf_device_config.h"
   63          #include "zf_device_imu660rb.h"
   64          
   65          #pragma warning disable = 177
   66          #pragma warning disable = 183
   67          
   68          int16 imu660rb_gyro_x = 0, imu660rb_gyro_y = 0, imu660rb_gyro_z = 0;            // ÈýÖáÍÓÂÝÒÇÊý¾Ý   gyro 
             -(ÍÓÂÝÒÇ)
   69          int16 imu660rb_acc_x = 0, imu660rb_acc_y = 0, imu660rb_acc_z = 0;               // ÈýÖá¼ÓËÙ¶È¼ÆÊý¾Ý acc  
             -(accelerometer ¼ÓËÙ¶È¼Æ)
   70          
   71          
   72          #if (IMU660RB_USE_INTERFACE==HARDWARE_SPI) 
               
                 //------------------------------------------------------------------------------------------------------
             --------------
                 // º¯Êý¼ò½é     IMU660RB Ð´¼Ä´æÆ÷
                 // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
                 // ²ÎÊýËµÃ÷     dat            Êý¾Ý
                 // ·µ»Ø²ÎÊý     void
                 // Ê¹ÓÃÊ¾Àý     imu660rb_write_register(IMU660RB_PWR_CONF, 0x00);                   // ¹Ø±Õ¸ß¼¶Ê¡µçÄ£Ê½
                 // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
                 //------------------------------------------------------------------------------------------------------
             --------------
                 static void imu660rb_write_register(uint8 reg, uint8 dat)
                 {
                   IMU660RB_CS(0);
                   spi_write_8bit_register(IMU660RB_SPI, reg | IMU660RB_SPI_W, dat);
                   IMU660RB_CS(1);
                 }
               
                 //------------------------------------------------------------------------------------------------------
             --------------
                 // º¯Êý¼ò½é     IMU660RB Ð´Êý¾Ý
                 // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
                 // ²ÎÊýËµÃ÷     dat            Êý¾Ý
                 // ·µ»Ø²ÎÊý     void
                 // Ê¹ÓÃÊ¾Àý     imu660rb_write_registers(IMU660RB_INIT_DATA, imu660rb_config_file, sizeof(imu660rb_confi
             -g_file));
                 // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
                 //------------------------------------------------------------------------------------------------------
             --------------
                 // static void imu660rb_write_registers(uint8 reg, const uint8 *dat, uint32 len)
                 // {
                 //     IMU660RB_CS(0);
                 //     spi_write_8bit_registers(IMU660RB_SPI, reg | IMU660RB_SPI_W, dat, len);
                 //     IMU660RB_CS(1);
                 // }
               
                 //------------------------------------------------------------------------------------------------------
             --------------
                 // º¯Êý¼ò½é     IMU660RB ¶Á¼Ä´æÆ÷
                 // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
                 // ·µ»Ø²ÎÊý     uint8           Êý¾Ý
                 // Ê¹ÓÃÊ¾Àý     imu660rb_read_register(IMU660RB_CHIP_ID);
                 // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
                 //------------------------------------------------------------------------------------------------------
C251 COMPILER V5.60.0,  zf_device_imu660rb                                                 08/01/26  02:12:47  PAGE 3   

             --------------
                 static uint8 imu660rb_read_register(uint8 reg)
                 {
                   uint8 dat;
                   IMU660RB_CS(0);
                   dat = spi_read_8bit_register(IMU660RB_SPI, reg | IMU660RB_SPI_R);
                   IMU660RB_CS(1);
                   return dat;
                 }
               
                 //------------------------------------------------------------------------------------------------------
             --------------
                 // º¯Êý¼ò½é     IMU660RB ¶ÁÊý¾Ý
                 // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
                 // ²ÎÊýËµÃ÷     dat            Êý¾Ý»º³åÇø
                 // ²ÎÊýËµÃ÷     len             Êý¾Ý³¤¶È
                 // ·µ»Ø²ÎÊý     void
                 // Ê¹ÓÃÊ¾Àý     imu660rb_read_registers(IMU660RB_ACC_ADDRESS, dat, 6);
                 // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
                 //------------------------------------------------------------------------------------------------------
             --------------
                 static void imu660rb_read_registers(uint8 reg, uint8 *dat, uint32 len)
                 {
                   IMU660RB_CS(0);
                   spi_read_8bit_registers(IMU660RB_SPI, reg | IMU660RB_SPI_R, dat, len);
                   IMU660RB_CS(1);
               
                 }
               
               #elif (IMU660RB_USE_INTERFACE==SOFT_SPI)
  138            
  139            
  140            #define IMU660RB_SCK(x)       IMU660RB_SPC_PIN  = x
  141            #define IMU660RB_MOSI(x)      IMU660RB_SDI_PIN = x
  142            #define IMU660RB_MISO         IMU660RB_SDO_PIN
  143            #define IMU660RB_CS(x)        IMU660RB_CS_PIN  = x
  144          
  145            //------------------------------------------------------------------------------------------------------
             --------------
  146            //  @brief      Í¨¹ýSPIÐ´Ò»¸öbyte,Í¬Ê±¶ÁÈ¡Ò»¸öbyte
  147            //  @param      byte        ·¢ËÍµÄÊý¾Ý
  148            //  @return     uint8 edata       return ·µ»Østatus×´Ì¬
  149            //  @since      v1.0
  150            //  Sample usage:
  151            //------------------------------------------------------------------------------------------------------
             --------------
  152            static uint8 imu660rb_simspi_wr_byte(uint8 byte)
  153            {
  154   1          uint8 i;
  155   1          for(i=0; i<8; i++)
  156   1          {
  157   2            IMU660RB_SCK (0);
  158   2            IMU660RB_MOSI(byte&0x80);
  159   2            byte <<= 1;
  160   2            IMU660RB_SCK (1);
  161   2            byte |= IMU660RB_MISO;
  162   2          }
  163   1          IMU660RB_SCK (0);
  164   1          return(byte);
  165   1        }
  166            
  167            //------------------------------------------------------------------------------------------------------
             --------------
  168            //  @brief      ½«valÐ´Èëcmd¶ÔÓ¦µÄ¼Ä´æÆ÷µØÖ·,Í¬Ê±·µ»Østatus×Ö½Ú
  169            //  @param      cmd         ÃüÁî×Ö
  170            //  @param      val         ´ýÐ´Èë¼Ä´æÆ÷µÄÊýÖµ
C251 COMPILER V5.60.0,  zf_device_imu660rb                                                 08/01/26  02:12:47  PAGE 4   

  171            //  @since      v1.0
  172            //  Sample usage:
  173            //------------------------------------------------------------------------------------------------------
             --------------
  174            static void imu660rb_simspi_w_reg_byte(uint8 cmd, uint8 val)
  175            {
  176   1          cmd |= IMU660RB_SPI_W;
  177   1          imu660rb_simspi_wr_byte(cmd);
  178   1          imu660rb_simspi_wr_byte(val);
  179   1        }
  180          
  181            //------------------------------------------------------------------------------------------------------
             --------------
  182            //  @brief      ¶ÁÈ¡cmdËù¶ÔÓ¦µÄ¼Ä´æÆ÷µØÖ·
  183            //  @param      cmd         ÃüÁî×Ö
  184            //  @param      *val        ´æ´¢¶ÁÈ¡µÄÊý¾ÝµØÖ·
  185            //  @since      v1.0
  186            //  Sample usage:
  187            //------------------------------------------------------------------------------------------------------
             --------------
  188            static void imu660rb_simspi_r_reg_byte(uint8 cmd, uint8 *val)
  189            {
  190   1          IMU660RB_SCK(0);
  191   1          cmd |= IMU660RB_SPI_R;
  192   1          imu660rb_simspi_wr_byte(cmd);
  193   1          *val = imu660rb_simspi_wr_byte(0);
  194   1          IMU660RB_SCK(1);
  195   1        }
  196            
  197          
  198          //  //----------------------------------------------------------------------------------------------------
             ----------------
  199          //  //  @brief      ½«valÐ´Èëcmd¶ÔÓ¦µÄ¼Ä´æÆ÷µØÖ·
  200          //  //  @param      cmd         ÃüÁî×Ö
  201          //  //  @param      val         ´ýÐ´Èë¼Ä´æÆ÷µÄÊýÖµ
  202          //  //  @since      v1.0
  203          //  //  Sample usage:
  204          //  //----------------------------------------------------------------------------------------------------
             ----------------
  205          //  static void imu660rb_simspi_w_reg_bytes(uint8 cmd, uint8 *dat_addr, uint32 len)
  206          //  {
  207          //    cmd |= IMU660RB_SPI_W;
  208          //    imu660rb_simspi_wr_byte(cmd);
  209          //    while(len--)
  210          //    {
  211          //      imu660rb_simspi_wr_byte(*dat_addr++);
  212          //    }
  213          //  }
  214          
  215            //------------------------------------------------------------------------------------------------------
             --------------
  216            //  @brief      ¶ÁÈ¡cmdËù¶ÔÓ¦µÄ¼Ä´æÆ÷µØÖ·
  217            //  @param      cmd         ÃüÁî×Ö
  218            //  @param      *val        ´æ´¢¶ÁÈ¡µÄÊý¾ÝµØÖ·
  219            //  @param      num         ¶ÁÈ¡µÄÊýÁ¿
  220            //  @since      v1.0
  221            //  Sample usage:
  222            //------------------------------------------------------------------------------------------------------
             --------------
  223            static void imu660rb_simspi_r_reg_bytes(uint8 cmd, uint8 *val, uint32 num)
  224            {
  225   1          cmd |= IMU660RB_SPI_R;
  226   1          imu660rb_simspi_wr_byte(cmd);
  227   1          while(num--)
  228   1          {
  229   2            *val++ = imu660rb_simspi_wr_byte(0);
C251 COMPILER V5.60.0,  zf_device_imu660rb                                                 08/01/26  02:12:47  PAGE 5   

  230   2          }
  231   1        }
  232            
  233            //------------------------------------------------------------------------------------------------------
             --------------
  234            // º¯Êý¼ò½é     IMU660RB Ð´¼Ä´æÆ÷
  235            // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
  236            // ²ÎÊýËµÃ÷     dat            Êý¾Ý
  237            // ·µ»Ø²ÎÊý     void
  238            // Ê¹ÓÃÊ¾Àý     imu660rb_write_register(IMU660RB_PWR_CONF, 0x00);                   // ¹Ø±Õ¸ß¼¶Ê¡µçÄ£Ê½
  239            // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
  240            //------------------------------------------------------------------------------------------------------
             --------------
  241            static void imu660rb_write_register(uint8 reg, uint8 dat)
  242            {
  243   1          IMU660RB_CS(0);
  244   1          imu660rb_simspi_w_reg_byte(reg | IMU660RB_SPI_W, dat);
  245   1          IMU660RB_CS(1);
  246   1        }
  247          
  248            //------------------------------------------------------------------------------------------------------
             --------------
  249            // º¯Êý¼ò½é     IMU660RB ¶Á¼Ä´æÆ÷
  250            // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
  251            // ·µ»Ø²ÎÊý     uint8           Êý¾Ý
  252            // Ê¹ÓÃÊ¾Àý     imu660rb_read_register(IMU660RB_CHIP_ID);
  253            // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
  254            //------------------------------------------------------------------------------------------------------
             --------------
  255            static uint8 imu660rb_read_register(uint8 reg)
  256            {
  257   1          uint8 dat;
  258   1          IMU660RB_CS(0);
  259   1          imu660rb_simspi_r_reg_byte(reg | IMU660RB_SPI_R, &dat);
  260   1          IMU660RB_CS(1);
  261   1          return dat;
  262   1        }
  263          
  264            //------------------------------------------------------------------------------------------------------
             --------------
  265            // º¯Êý¼ò½é     IMU660RB ¶ÁÊý¾Ý
  266            // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
  267            // ²ÎÊýËµÃ÷     dat            Êý¾Ý»º³åÇø
  268            // ²ÎÊýËµÃ÷     len             Êý¾Ý³¤¶È
  269            // ·µ»Ø²ÎÊý     void
  270            // Ê¹ÓÃÊ¾Àý     imu660rb_read_registers(IMU660RB_ACC_ADDRESS, dat, 6);
  271            // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
  272            //------------------------------------------------------------------------------------------------------
             --------------
  273            static void imu660rb_read_registers(uint8 reg, uint8 *dat, uint32 len)
  274            {
  275   1          IMU660RB_CS(0);
  276   1          imu660rb_simspi_r_reg_bytes(reg | IMU660RB_SPI_R, dat, len);
  277   1          IMU660RB_CS(1);
  278   1        }
  279            
  280            
  281          
  282          #elif (IMU660RB_USE_INTERFACE==SOFT_IIC)
                 
                 static soft_iic_info_struct imu660rb_iic_struct;
               
                 #define imu660rb_write_register(reg, dat)        (soft_iic_write_8bit_register (&imu660rb_iic_struct, (r
             -eg), (dat)))
                 #define imu660rb_write_registers(reg, dat, len)  (soft_iic_write_8bit_registers(&imu660rb_iic_struct, (r
             -eg), (dat), (len)))
C251 COMPILER V5.60.0,  zf_device_imu660rb                                                 08/01/26  02:12:47  PAGE 6   

                 #define imu660rb_read_register(reg)               (soft_iic_read_8bit_register  (&imu660rb_iic_struct, (
             -reg)))
                 #define imu660rb_read_registers(reg, dat, len)   (soft_iic_read_8bit_registers (&imu660rb_iic_struct, (r
             -eg), (dat), (len)))
               
               #endif
  292          
  293          //-------------------------------------------------------------------------------------------------------
             -------------
  294          // º¯Êý¼ò½é     IMU660RB ×Ô¼ì
  295          // ²ÎÊýËµÃ÷     void
  296          // ·µ»Ø²ÎÊý     uint8           1-×Ô¼ìÊ§°Ü 0-×Ô¼ì³É¹¦
  297          // Ê¹ÓÃÊ¾Àý     imu660rb_self_check();
  298          // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
  299          //-------------------------------------------------------------------------------------------------------
             -------------
  300          static uint8 imu660rb_self_check (void)
  301          {
  302   1          uint8 dat = 0, return_state = 0;
  303   1          uint16 timeout_count = 0;
  304   1          do
  305   1          {
  306   2              if(timeout_count ++ > IMU660RB_TIMEOUT_COUNT)
  307   2              {
  308   3                  return_state =  1;
  309   3                  break;
  310   3              }
  311   2              dat = imu660rb_read_register(IMU660RB_CHIP_ID);
  312   2              system_delay_ms(1);
  313   2          }while(0x6B != dat);                                                        // ¶ÁÈ¡Éè±¸IDÊÇ·ñµÈÓÚ0X24
             -£¬Èç¹û²»ÊÇ0X24ÔòÈÏÎªÃ»¼ì²âµ½Éè±¸
  314   1          return return_state;
  315   1      }
  316          
  317          //-------------------------------------------------------------------------------------------------------
             -------------
  318          // º¯Êý¼ò½é     »ñÈ¡ IMU660RB ¼ÓËÙ¶È¼ÆÊý¾Ý
  319          // ²ÎÊýËµÃ÷     void
  320          // ·µ»Ø²ÎÊý     void
  321          // Ê¹ÓÃÊ¾Àý     imu660rb_get_acc();                                             // Ö´ÐÐ¸Ãº¯Êýºó£¬Ö±½Ó²é¿´
             -¶ÔÓ¦µÄ±äÁ¿¼´¿É
  322          // ±¸×¢ÐÅÏ¢     Ê¹ÓÃ SPI µÄ²É¼¯Ê±¼äÎª69us
  323          //             Ê¹ÓÃ IIC µÄ²É¼¯Ê±¼äÎª126us        ²É¼¯¼ÓËÙ¶È¼ÆµÄÊ±¼äÓë²É¼¯ÍÓÂÝÒÇµÄÊ±¼äÒ»ÖÂµÄÔ­ÒòÊÇ¶¼Ö»ÊÇ¶Á
             -È¡¼Ä´æÆ÷Êý¾Ý
  324          //-------------------------------------------------------------------------------------------------------
             -------------
  325          void imu660rb_get_acc (void)
  326          {
  327   1          uint8 dat[6];
  328   1      
  329   1          imu660rb_read_registers(IMU660RB_ACC_ADDRESS, dat, 6);
  330   1          imu660rb_acc_x = (int16)(((uint16)dat[1]<<8 | dat[0]));
  331   1          imu660rb_acc_y = (int16)(((uint16)dat[3]<<8 | dat[2]));
  332   1          imu660rb_acc_z = (int16)(((uint16)dat[5]<<8 | dat[4]));
  333   1      }
  334          //-------------------------------------------------------------------------------------------------------
             -------------
  335          // º¯Êý¼ò½é     »ñÈ¡ IMU660RB ÍÓÂÝÒÇÊý¾Ý
  336          // ²ÎÊýËµÃ÷     void
  337          // ·µ»Ø²ÎÊý     void
  338          // Ê¹ÓÃÊ¾Àý     imu660rb_get_gyro();                                            // Ö´ÐÐ¸Ãº¯Êýºó£¬Ö±½Ó²é¿´
             -¶ÔÓ¦µÄ±äÁ¿¼´¿É
  339          // ±¸×¢ÐÅÏ¢     Ê¹ÓÃ SPI µÄ²É¼¯Ê±¼äÎª69us
  340          //             Ê¹ÓÃ IIC µÄ²É¼¯Ê±¼äÎª126us
  341          //-------------------------------------------------------------------------------------------------------
             -------------
C251 COMPILER V5.60.0,  zf_device_imu660rb                                                 08/01/26  02:12:47  PAGE 7   

  342          void imu660rb_get_gyro (void)
  343          {
  344   1          uint8 dat[6];
  345   1      
  346   1          imu660rb_read_registers(IMU660RB_GYRO_ADDRESS, dat, 6);
  347   1          imu660rb_gyro_x = (int16)(((uint16)dat[1]<<8 | dat[0]));
  348   1          imu660rb_gyro_y = (int16)(((uint16)dat[3]<<8 | dat[2]));
  349   1          imu660rb_gyro_z = (int16)(((uint16)dat[5]<<8 | dat[4]));
  350   1      }
  351          
  352          //-------------------------------------------------------------------------------------------------------
             -------------
  353          // º¯Êý¼ò½é     ½« IMU660RB ¼ÓËÙ¶È¼ÆÊý¾Ý×ª»»ÎªÊµ¼ÊÎïÀíÊý¾Ý
  354          // ²ÎÊýËµÃ÷     gyro_value      ÈÎÒâÖáµÄ¼ÓËÙ¶È¼ÆÊý¾Ý
  355          // ·µ»Ø²ÎÊý     void
  356          // Ê¹ÓÃÊ¾Àý     float dat = imu660rb_acc_transition(imu660rb_acc_x);           // µ¥Î»Îª g(m/s^2)
  357          // ±¸×¢ÐÅÏ¢
  358          //-------------------------------------------------------------------------------------------------------
             -------------
  359          float imu660rb_acc_transition (int16 acc_value)
  360          {
  361   1          float acc_data = 0;
  362   1          switch(IMU660RB_ACC_SAMPLE)
  363   1          {
  364   2              case 0x30: acc_data = (float)acc_value / 16393; break;                  // 0x30 ¼ÓËÙ¶ÈÁ¿³ÌÎª:¡À2G
             -      »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý ³ýÒÔ 16393 £¬¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£¬µ¥Î»£ºg(m/s^2)
  365   2              case 0x38: acc_data = (float)acc_value / 8197;  break;                  // 0x38 ¼ÓËÙ¶ÈÁ¿³ÌÎª:¡À4G
             -      »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý ³ýÒÔ 8197 £¬ ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£¬µ¥Î»£ºg(m/s^2)
  366   2              case 0x3C: acc_data = (float)acc_value / 4098;  break;                  // 0x3C ¼ÓËÙ¶ÈÁ¿³ÌÎª:¡À8G
             -      »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý ³ýÒÔ 4098 £¬ ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£¬µ¥Î»£ºg(m/s^2)
  367   2              case 0x34: acc_data = (float)acc_value / 2049;  break;                  // 0x34 ¼ÓËÙ¶ÈÁ¿³ÌÎª:¡À16
             -G     »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý ³ýÒÔ 2049 £¬ ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£¬µ¥Î»£ºg(m/s^2)
  368   2              default: break;
  369   2          }
  370   1          return acc_data;
  371   1      }
  372          
  373          //-------------------------------------------------------------------------------------------------------
             -------------
  374          // º¯Êý¼ò½é     ½« IMU660RB ÍÓÂÝÒÇÊý¾Ý×ª»»ÎªÊµ¼ÊÎïÀíÊý¾Ý
  375          // ²ÎÊýËµÃ÷     gyro_value      ÈÎÒâÖáµÄÍÓÂÝÒÇÊý¾Ý
  376          // ·µ»Ø²ÎÊý     void
  377          // Ê¹ÓÃÊ¾Àý     float dat = imu660rb_gyro_transition(imu660rb_gyro_x);         // µ¥Î»Îª¡ã/s
  378          // ±¸×¢ÐÅÏ¢
  379          //-------------------------------------------------------------------------------------------------------
             -------------
  380          float imu660rb_gyro_transition (int16 gyro_value)
  381          {
  382   1          float gyro_data = 0;
  383   1          switch(IMU660RB_GYR_SAMPLE)
  384   1          {
  385   2              case 0x52: gyro_data = (float)gyro_value / 228.6f;  break;              //  0x52 ÍÓÂÝÒÇÁ¿³ÌÎª:¡À1
             -25dps  »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ 228.6£¬   ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£¬µ¥Î»Îª£º¡ã/s
  386   2              case 0x50: gyro_data = (float)gyro_value / 114.3f;  break;              //  0x50 ÍÓÂÝÒÇÁ¿³ÌÎª:¡À2
             -50dps  »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ 114.3£¬   ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£¬µ¥Î»Îª£º¡ã/s
  387   2              case 0x54: gyro_data = (float)gyro_value / 57.1f;   break;              //  0x54 ÍÓÂÝÒÇÁ¿³ÌÎª:¡À5
             -00dps  »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ 57.1£¬    ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£¬µ¥Î»Îª£º¡ã/s
  388   2              case 0x58: gyro_data = (float)gyro_value / 28.6f;   break;              //  0x58 ÍÓÂÝÒÇÁ¿³ÌÎª:¡À1
             -000dps »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ 28.6£¬    ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£¬µ¥Î»Îª£º¡ã/s
  389   2              case 0x5C: gyro_data = (float)gyro_value / 14.3f;   break;              //  0x5C ÍÓÂÝÒÇÁ¿³ÌÎª:¡À2
             -000dps »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ 14.3£¬    ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£¬µ¥Î»Îª£º¡ã/s
  390   2              case 0x51: gyro_data = (float)gyro_value / 7.1f;    break;              //  0x51 ÍÓÂÝÒÇÁ¿³ÌÎª:¡À4
             -000dps »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ 7.1£¬     ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£¬µ¥Î»Îª£º¡ã/s
  391   2              default: break;
  392   2          }
  393   1          return gyro_data;
C251 COMPILER V5.60.0,  zf_device_imu660rb                                                 08/01/26  02:12:47  PAGE 8   

  394   1      }
  395          
  396          //-------------------------------------------------------------------------------------------------------
             -------------
  397          // º¯Êý¼ò½é     ³õÊ¼»¯ IMU660RB
  398          // ²ÎÊýËµÃ÷     void
  399          // ·µ»Ø²ÎÊý     uint8           1-³õÊ¼»¯Ê§°Ü 0-³õÊ¼»¯³É¹¦
  400          // Ê¹ÓÃÊ¾Àý     imu660rb_init();
  401          // ±¸×¢ÐÅÏ¢
  402          //-------------------------------------------------------------------------------------------------------
             -------------
  403          uint8 imu660rb_init (void)
  404          {
  405   1          uint8 return_state = 0;
  406   1          system_delay_ms(20);                                                        // µÈ´ýÉè±¸ÉÏµç³É¹¦
  407   1      
  408   1      #if (IMU660RB_USE_INTERFACE==HARDWARE_SPI)
                 
                   spi_init(IMU660RB_SPI, SPI_MODE0, IMU660RB_SPI_SPEED, IMU660RB_SPC_PIN, IMU660RB_SDI_PIN, IMU660RB_SD
             -O_PIN, SPI_CS_NULL);   // ÅäÖÃ IMU660RB µÄ SPI ¶Ë¿Ú
                   gpio_init(IMU660RB_CS_PIN, GPO, GPIO_HIGH, GPO_PUSH_PULL);                  // ÅäÖÃ IMU660RB µÄ CS ¶Ë
             -¿Ú
               //    imu660rb_read_register(IMU660RB_CHIP_ID);                                   // ¶ÁÈ¡Ò»ÏÂÉè±¸ID ½«Éè±
             -¸ÉèÖÃÎªSPIÄ£Ê½
                 
               #elif (IMU660RB_USE_INTERFACE==SOFT_SPI)
  415   1        
  416   1      // Ä¬ÈÏÊ¹ÓÃË«ÏòIO£¬²»ÐèÒª³õÊ¼»¯¡£
  417   1      //  soft_spi_init(IMU660RB_SPI, SPI_MODE0, 0, IMU963RA_SPC_PIN, IMU963RA_SDI_PIN, IMU963RA_SDO_PIN, IMU963
             -RA_CS_PIN);
  418   1        
  419   1      #elif (IMU660RB_USE_INTERFACE==SOFT_IIC)
                 
                 soft_iic_init(&imu660rb_iic_struct, IMU660RB_DEV_ADDR, IMU660RB_SOFT_IIC_DELAY, IMU660RB_SCL_PIN, IMU660
             -RB_SDA_PIN);        // ÅäÖÃ IMU660RB µÄ IIC ¶Ë¿Ú
                 
               #endif
  424   1        
  425   1        
  426   1          do{
  427   2              if(imu660rb_self_check())                                               // IMU660RB ×Ô¼ì
  428   2              {
  429   3                  // Èç¹û³ÌÐòÔÚÊä³öÁË¶ÏÑÔÐÅÏ¢ ²¢ÇÒÌáÊ¾³ö´íÎ»ÖÃÔÚÕâÀï
  430   3                  // ÄÇÃ´¾ÍÊÇ IMU660RB ×Ô¼ì³ö´í²¢³¬Ê±ÍË³öÁË
  431   3                  // ¼ì²éÒ»ÏÂ½ÓÏßÓÐÃ»ÓÐÎÊÌâ Èç¹ûÃ»ÎÊÌâ¿ÉÄÜ¾ÍÊÇ»µÁË
  432   3                  printf("imu660rb self check error.");
  433   3                  return_state = 1;
  434   3                  break;
  435   3              }
  436   2      
  437   2              imu660rb_write_register(IMU660RB_INT1_CTRL, 0x03);                      // ¿ªÆôÍÓÂÝÒÇ ¼ÓËÙ¶ÈÊý¾Ý¾
             -ÍÐ÷ÖÐ¶Ï
  438   2              imu660rb_write_register(IMU660RB_CTRL1_XL, IMU660RB_ACC_SAMPLE);        // ÉèÖÃ¼ÓËÙ¶È¼ÆÁ¿³Ì ¡À8G 
             -ÒÔ¼°Êý¾ÝÊä³öËÙÂÊ 52hz ÒÔ¼°¼ÓËÙ¶ÈÐÅÏ¢´ÓµÚÒ»¼¶ÂË²¨Æ÷Êä³ö
  439   2              // IMU660RB_CTRL1_XL ¼Ä´æÆ÷
  440   2              // ÉèÖÃÎª:0x30 ¼ÓËÙ¶ÈÁ¿³ÌÎª:¡À2G      »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý ³ýÒÔ16393£¬¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£
             -¬µ¥Î»£ºg(m/s^2)
  441   2              // ÉèÖÃÎª:0x38 ¼ÓËÙ¶ÈÁ¿³ÌÎª:¡À4G      »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý ³ýÒÔ8197£¬ ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£
             -¬µ¥Î»£ºg(m/s^2)
  442   2              // ÉèÖÃÎª:0x3C ¼ÓËÙ¶ÈÁ¿³ÌÎª:¡À8G      »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý ³ýÒÔ4098£¬ ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£
             -¬µ¥Î»£ºg(m/s^2)
  443   2              // ÉèÖÃÎª:0x34 ¼ÓËÙ¶ÈÁ¿³ÌÎª:¡À16G     »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý ³ýÒÔ2049£¬ ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£
             -¬µ¥Î»£ºg(m/s^2)
  444   2      
  445   2              imu660rb_write_register(IMU660RB_CTRL2_G, IMU660RB_GYR_SAMPLE);         // ÉèÖÃÍÓÂÝÒÇ¼ÆÁ¿³Ì ¡À200
             -0dps ÒÔ¼°Êý¾ÝÊä³öËÙÂÊ 208hz
C251 COMPILER V5.60.0,  zf_device_imu660rb                                                 08/01/26  02:12:47  PAGE 9   

  446   2              // IMU660RB_CTRL2_G ¼Ä´æÆ÷
  447   2              // ÉèÖÃÎª:0x52 ÍÓÂÝÒÇÁ¿³ÌÎª:¡À125dps  »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ228.6£¬   ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£
             -¬µ¥Î»Îª£º¡ã/s
  448   2              // ÉèÖÃÎª:0x50 ÍÓÂÝÒÇÁ¿³ÌÎª:¡À250dps  »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ114.3£¬   ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£
             -¬µ¥Î»Îª£º¡ã/s
  449   2              // ÉèÖÃÎª:0x54 ÍÓÂÝÒÇÁ¿³ÌÎª:¡À500dps  »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ57.1£¬    ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£
             -¬µ¥Î»Îª£º¡ã/s
  450   2              // ÉèÖÃÎª:0x58 ÍÓÂÝÒÇÁ¿³ÌÎª:¡À1000dps »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ28.6£¬    ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£
             -¬µ¥Î»Îª£º¡ã/s
  451   2              // ÉèÖÃÎª:0x5C ÍÓÂÝÒÇÁ¿³ÌÎª:¡À2000dps »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ14.3£¬    ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£
             -¬µ¥Î»Îª£º¡ã/s
  452   2              // ÉèÖÃÎª:0x51 ÍÓÂÝÒÇÁ¿³ÌÎª:¡À4000dps »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ7.1£¬     ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£
             -¬µ¥Î»Îª£º¡ã/s
  453   2      
  454   2              imu660rb_write_register(IMU660RB_CTRL3_C, 0x44);                        // Ê¹ÄÜÍÓÂÝÒÇÊý×ÖµÍÍ¨ÂË²¨
             -Æ÷
  455   2              imu660rb_write_register(IMU660RB_CTRL4_C, 0x02);                        // Ê¹ÄÜÊý×ÖµÍÍ¨ÂË²¨Æ÷
  456   2              imu660rb_write_register(IMU660RB_CTRL5_C, 0x00);                        // ¼ÓËÙ¶È¼ÆÓëÍÓÂÝÒÇËÄÉáÎå
             -Èë
  457   2              imu660rb_write_register(IMU660RB_CTRL6_C, 0x00);                        // ¿ªÆô¼ÓËÙ¶È¼Æ¸ßÐÔÄÜÄ£Ê½
             - ÍÓÂÝÒÇµÍÍ¨ÂË²¨ 133hz
  458   2              imu660rb_write_register(IMU660RB_CTRL7_G, 0x00);                        // ¿ªÆôÍÓÂÝÒÇ¸ßÐÔÄÜÄ£Ê½ ¹
             -Ø±Õ¸ßÍ¨ÂË²¨
  459   2              imu660rb_write_register(IMU660RB_CTRL9_XL, 0x01);                       // ¹Ø±ÕI3C½Ó¿Ú
  460   2      
  461   2          }while(0);
  462   1          return return_state;
  463   1      }
  464          
  465          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       532     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        12         17
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        69     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
