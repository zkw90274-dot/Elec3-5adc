C251 COMPILER V5.60.0,  zf_device_ips114                                                   08/01/26  02:12:47  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_device_ips114
OBJECT MODULE PLACED IN .\out_file\zf_device_ips114.obj
COMPILER INVOKED BY: E:\Tools\keil5\Keil_v5\C251\BIN\C251.EXE ..\..\libraries\zf_device\zf_device_ips114.c LARGE NOALIAS
                    - WARNINGLEVEL(3) OPTIMIZE(SIZE) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf
                    -_device;..\..\libraries\zf_driver;..\user;..\code) DEBUG PRINT(.\out_file\zf_device_ips114.lst) TABS(2) OBJECT(.\out_fil
                    -e\zf_device_ips114.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * STC32G Opensourec Library å³ï¼ˆSTC32G å¼€æºåº“ï¼‰æ˜¯ä¸€ä¸ªåŸºäºå®˜æ–¹ SDK æ¥å£çš„ç¬¬ä¸‰æ–¹å¼€æºåº
             -“
    3          * Copyright (c) 2022 SEEKFREE é€é£ç§‘æŠ€
    4          *
    5          * æœ¬æ–‡ä»¶æ˜¯STC å¼€æºåº“çš„ä¸€éƒ¨åˆ†
    6          *
    7          * STC32G å¼€æºåº“ æ˜¯å…è´¹è½¯ä»¶
    8          * æ‚¨å¯ä»¥æ ¹æ®è‡ªç”±è½¯ä»¶åŸºé‡‘ä¼šå‘å¸ƒçš„ GPLï¼ˆGNU General Public Licenseï¼Œå³ GNUé€šç”¨å…¬å…±è®¸
             -å¯è¯ï¼‰çš„æ¡æ¬¾
    9          * å³ GPL çš„ç¬¬3ç‰ˆï¼ˆå³ GPL3.0ï¼‰æˆ–ï¼ˆæ‚¨é€‰æ‹©çš„ï¼‰ä»»ä½•åæ¥çš„ç‰ˆæœ¬ï¼Œé‡æ–°å‘å¸ƒå’Œ/æˆ–ä¿®æ”
             -¹å®ƒ
   10          *
   11          * æœ¬å¼€æºåº“çš„å‘å¸ƒæ˜¯å¸Œæœ›å®ƒèƒ½å‘æŒ¥ä½œç”¨ï¼Œä½†å¹¶æœªå¯¹å…¶ä½œä»»ä½•çš„ä¿è¯
   12          * ç”šè‡³æ²¡æœ‰éšå«çš„é€‚é”€æ€§æˆ–é€‚åˆç‰¹å®šç”¨é€”çš„ä¿è¯
   13          * æ›´å¤šç»†èŠ‚è¯·å‚è§ GPL
   14          *
   15          * æ‚¨åº”è¯¥åœ¨æ”¶åˆ°æœ¬å¼€æºåº“çš„åŒæ—¶æ”¶åˆ°ä¸€ä»½ GPL çš„å‰¯æœ¬
   16          * å¦‚æœæ²¡æœ‰ï¼Œè¯·å‚é˜…<https://www.gnu.org/licenses/>
   17          *
   18          * é¢å¤–æ³¨æ˜ï¼š
   19          * æœ¬å¼€æºåº“ä½¿ç”¨ GPL3.0 å¼€æºè®¸å¯è¯åè®® ä»¥ä¸Šè®¸å¯ç”³æ˜ä¸ºè¯‘æ–‡ç‰ˆæœ¬
   20          * è®¸å¯ç”³æ˜è‹±æ–‡ç‰ˆåœ¨ libraries/doc æ–‡ä»¶å¤¹ä¸‹çš„ GPL3_permission_statement.txt æ–‡ä»¶ä¸­
   21          * è®¸å¯è¯å‰¯æœ¬åœ¨ libraries æ–‡ä»¶å¤¹ä¸‹ å³è¯¥æ–‡ä»¶å¤¹ä¸‹çš„ LICENSE æ–‡ä»¶
   22          * æ¬¢è¿å„ä½ä½¿ç”¨å¹¶ä¼ æ’­æœ¬ç¨‹åº ä½†ä¿®æ”¹å†…å®¹æ—¶å¿…é¡»ä¿ç•™é€é£ç§‘æŠ€çš„ç‰ˆæƒå£°æ˜ï¼ˆå³æœ¬
             -å£°æ˜ï¼‰
   23          *
   24          * æ–‡ä»¶åç§°          
   25          * å…¬å¸åç§°          æˆéƒ½é€é£ç§‘æŠ€æœ‰é™å…¬å¸
   26          * ç‰ˆæœ¬ä¿¡æ¯          æŸ¥çœ‹ libraries/doc æ–‡ä»¶å¤¹å†… version æ–‡ä»¶ ç‰ˆæœ¬è¯´æ˜
   27          * å¼€å‘ç¯å¢ƒ          MDK FOR C251
   28          * é€‚ç”¨å¹³å°          STC32G
   29          * åº—é“ºé“¾æ¥          https://seekfree.taobao.com/
   30          *
   31          * ä¿®æ”¹è®°å½•
   32          * æ—¥æœŸ              ä½œè€…           å¤‡æ³¨
   33          * 2024-08-01        å¤§W            first version
   34          *********************************************************************************************************
             -***********/
   35          /********************************************************************************************************
             -*************
   36          * æ¥çº¿å®šä¹‰ï¼š
   37          *                   ------------------------------------
   38          *                   æ¨¡å—ç®¡è„š             å•ç‰‡æœºç®¡è„š
   39          *                   SCL                  æŸ¥çœ‹ zf_device_ips114.h ä¸­ IPS114_SCL_PIN å®å®šä¹‰
   40          *                   SDA                  æŸ¥çœ‹ zf_device_ips114.h ä¸­ IPS114_SDA_PIN å®å®šä¹‰
   41          *                   RST                  æŸ¥çœ‹ zf_device_ips114.h ä¸­ IPS114_RST_PIN å®å®šä¹‰
   42          *                   DC                   æŸ¥çœ‹ zf_device_ips114.h ä¸­ IPS114_DC_PIN  å®å®šä¹‰
   43          *                   CS                   æŸ¥çœ‹ zf_device_ips114.h ä¸­ IPS114_CS_PIN  å®å®šä¹‰
   44          *                   BLK                  æŸ¥çœ‹ zf_device_ips114.h ä¸­ IPS114_BLK_PIN å®å®šä¹‰
   45          *                   VCC                 3.3Vç”µæº
   46          *                   GND                 ç”µæºåœ°
   47          *                   æœ€å¤§åˆ†è¾¨ç‡ 135 * 240
   48          *                   ------------------------------------
   49          *********************************************************************************************************
C251 COMPILER V5.60.0,  zf_device_ips114                                                   08/01/26  02:12:47  PAGE 2   

             -***********/
   50          
   51          #include "zf_common_clock.h"
   52          #include "zf_common_debug.h"
   53          #include "zf_common_font.h"
   54          #include "zf_common_function.h"
   55          #include "zf_driver_delay.h"
   56          #include "zf_driver_spi.h"
   57          
   58          #include "zf_device_ips114.h"
   59          
   60          #define IPS_LEN   240
   61          #define IPS_WIGHT 135
   62          
   63          uint16 ips114_pencolor = IPS114_DEFAULT_PENCOLOR;
   64          uint16 ips114_bgcolor = IPS114_DEFAULT_BGCOLOR;
   65          
   66          ips114_dir_enum ips114_display_dir = IPS114_DEFAULT_DISPLAY_DIR;
   67          uint8 ips114_x_max = IPS_LEN;
   68          uint8 ips114_y_max = IPS_WIGHT;
   69          
   70          #if (IPS114_USE_INTERFACE==SOFT_SPI)
                 static soft_spi_info_struct             ips114_spi;
                 #define ips114_write_8bit_data(dat)    soft_spi_write_8bit(&ips114_spi, dat)
                 #define ips114_write_16bit_data(dat)   soft_spi_write_16bit(&ips114_spi, dat)
               #elif (IPS114_USE_INTERFACE==HARDWARE_SPI)
   75            #define ips114_write_8bit_data(dat)    spi_write_8bit(IPS114_SPI, dat)
   76            #define ips114_write_16bit_data(dat)   spi_write_16bit(IPS114_SPI, dat)
   77          #endif
   78          
   79          //-------------------------------------------------------------------------------------------------------
             -------------
   80          // å‡½æ•°ç®€ä»‹       å†™å‘½ä»¤ å†…éƒ¨è°ƒç”¨
   81          // @note        å†…éƒ¨è°ƒç”¨ ç”¨æˆ·æ— éœ€å…³å¿ƒ
   82          //-------------------------------------------------------------------------------------------------------
             -------------
   83          static void ips114_write_index (uint8 dat)
   84          {
   85   1          IPS114_CS(1);
   86   1          IPS114_CS(0);
   87   1          IPS114_DC(0);
   88   1          ips114_write_8bit_data(dat);
   89   1          IPS114_DC(1);
   90   1          IPS114_CS(1);
   91   1          IPS114_CS(0);
   92   1      }
   93          
   94          //-------------------------------------------------------------------------------------------------------
             -------------
   95          // å‡½æ•°ç®€ä»‹       è®¾ç½®æ˜¾ç¤ºåŒºåŸŸ å†…éƒ¨è°ƒç”¨
   96          // å‚æ•°è¯´æ˜       x1              èµ·å§‹xè½´åæ ‡
   97          // å‚æ•°è¯´æ˜       y1              èµ·å§‹yè½´åæ ‡
   98          // å‚æ•°è¯´æ˜       x2              ç»“æŸxè½´åæ ‡
   99          // å‚æ•°è¯´æ˜       y2              ç»“æŸyè½´åæ ‡
  100          // è¿”å›å‚æ•°      void
  101          // @note        å†…éƒ¨è°ƒç”¨ ç”¨æˆ·æ— éœ€å…³å¿ƒ
  102          //-------------------------------------------------------------------------------------------------------
             -------------
  103          static void ips114_set_region (uint16 x1, uint16 y1, uint16 x2, uint16 y2)
  104          {
  105   1          zf_assert(x1 < ips114_x_max);
  106   1          zf_assert(y1 < ips114_y_max);
  107   1          zf_assert(x2 < ips114_x_max);
  108   1          zf_assert(y2 < ips114_y_max);
  109   1      
  110   1          if(ips114_display_dir==IPS114_PORTAIT)
C251 COMPILER V5.60.0,  zf_device_ips114                                                   08/01/26  02:12:47  PAGE 3   

  111   1          {
  112   2              ips114_write_index(0x2a);                                               // åˆ—åœ°å€è®¾ç½®
  113   2              ips114_write_16bit_data(x1+52);
  114   2              ips114_write_16bit_data(x2+52);
  115   2              ips114_write_index(0x2b);                                               // è¡Œåœ°å€è®¾ç½®
  116   2              ips114_write_16bit_data(y1+40);
  117   2              ips114_write_16bit_data(y2+40);
  118   2              ips114_write_index(0x2c);                                               // å‚¨å­˜å™¨å†™
  119   2          }
  120   1          else if(ips114_display_dir==IPS114_PORTAIT_180)
  121   1          {
  122   2              ips114_write_index(0x2a);                                               // åˆ—åœ°å€è®¾ç½®
  123   2              ips114_write_16bit_data(x1+53);
  124   2              ips114_write_16bit_data(x2+53);
  125   2              ips114_write_index(0x2b);                                               // è¡Œåœ°å€è®¾ç½®
  126   2              ips114_write_16bit_data(y1+40);
  127   2              ips114_write_16bit_data(y2+40);
  128   2              ips114_write_index(0x2c);                                               // å‚¨å­˜å™¨å†™
  129   2          }
  130   1          else if(ips114_display_dir==IPS114_CROSSWISE)
  131   1          {
  132   2              ips114_write_index(0x2a);                                               // åˆ—åœ°å€è®¾ç½®
  133   2              ips114_write_16bit_data(x1+40);
  134   2              ips114_write_16bit_data(x2+40);
  135   2              ips114_write_index(0x2b);                                               // è¡Œåœ°å€è®¾ç½®
  136   2              ips114_write_16bit_data(y1+53);
  137   2              ips114_write_16bit_data(y2+53);
  138   2              ips114_write_index(0x2c);                                               // å‚¨å­˜å™¨å†™
  139   2          }
  140   1          else
  141   1          {
  142   2              ips114_write_index(0x2a);                                               // åˆ—åœ°å€è®¾ç½®
  143   2              ips114_write_16bit_data(x1+40);
  144   2              ips114_write_16bit_data(x2+40);
  145   2              ips114_write_index(0x2b);                                               // è¡Œåœ°å€è®¾ç½®
  146   2              ips114_write_16bit_data(y1+52);
  147   2              ips114_write_16bit_data(y2+52);
  148   2              ips114_write_index(0x2c);                                               // å‚¨å­˜å™¨å†™
  149   2          }
  150   1      }
  151          
  152          //-------------------------------------------------------------------------------------------------------
             -------------
  153          // å‡½æ•°ç®€ä»‹       æ¶²æ™¶æ¸…å±å‡½æ•°
  154          // å‚æ•°è¯´æ˜       color           é¢œè‰²æ ¼å¼ RGB565 æˆ–è€…å¯ä»¥ä½¿ç”¨ zf_common_font.h å†…å¸¸ç”¨é¢
             -œè‰²å®å®šä¹‰
  155          // è¿”å›å‚æ•°      void
  156          // ä½¿ç”¨ç¤ºä¾‹                ips114_clear(YELLOW);
  157          //-------------------------------------------------------------------------------------------------------
             -------------
  158          void ips114_clear (uint16 color)
  159          {
  160   1          uint16 i, j;
  161   1          ips114_set_region(0, 0, ips114_x_max - 1, ips114_y_max - 1);
  162   1        
  163   1        for(i = 0; i < ips114_x_max; i ++)
  164   1          {
  165   2              for (j = 0; j < ips114_y_max; j ++)
  166   2              {
  167   3                  ips114_write_16bit_data(color);              
  168   3              }
  169   2          }
  170   1      }
  171          
  172          //-------------------------------------------------------------------------------------------------------
             -------------
C251 COMPILER V5.60.0,  zf_device_ips114                                                   08/01/26  02:12:47  PAGE 4   

  173          // å‡½æ•°ç®€ä»‹       è®¾ç½®æ˜¾ç¤ºæ–¹å‘ è¿™ä¸ªå‡½æ•°åªæœ‰åœ¨åˆå§‹åŒ–å±å¹•ä¹‹å‰è°ƒç”¨æ‰ç”Ÿæ•ˆ
  174          // å‚æ•°è¯´æ˜       dir             æ˜¾ç¤ºæ–¹å‘  å‚ç…§ zf_device_ips114.h å†… ips114_dir_enum æšä¸¾ä
             -½“å®šä¹‰
  175          // è¿”å›å‚æ•°      void
  176          // ä½¿ç”¨ç¤ºä¾‹                ips114_set_dir(IPS114_CROSSWISE);
  177          //-------------------------------------------------------------------------------------------------------
             -------------
  178          void ips114_set_dir (ips114_dir_enum dir)
  179          {
  180   1          ips114_display_dir = dir;
  181   1          if(dir < 2)
  182   1          {
  183   2              ips114_x_max = IPS_WIGHT;
  184   2              ips114_y_max = IPS_LEN;
  185   2          }
  186   1          else
  187   1          {
  188   2              ips114_x_max = IPS_LEN;
  189   2              ips114_y_max = IPS_WIGHT;
  190   2          }
  191   1      }
  192          
  193          //-------------------------------------------------------------------------------------------------------
             -------------
  194          // å‡½æ•°ç®€ä»‹       è®¾ç½®æ˜¾ç¤ºé¢œè‰²
  195          // å‚æ•°è¯´æ˜       pen             é¢œè‰²æ ¼å¼ RGB565 æˆ–è€…å¯ä»¥ä½¿ç”¨ zf_common_font.h å†…å¸¸ç”¨é¢
             -œè‰²å®å®šä¹‰
  196          // å‚æ•°è¯´æ˜       bgcolor         é¢œè‰²æ ¼å¼ RGB565 æˆ–è€…å¯ä»¥ä½¿ç”¨ zf_common_font.h å†…å¸¸ç”¨é¢
             -œè‰²å®å®šä¹‰
  197          // è¿”å›å‚æ•°      void
  198          // ä½¿ç”¨ç¤ºä¾‹                ips114_set_color(WHITE,BLACK);
  199          //-------------------------------------------------------------------------------------------------------
             -------------
  200          void ips114_set_color (uint16 pen, uint16 bgcolor)
  201          {
  202   1          ips114_pencolor = pen;
  203   1          ips114_bgcolor = bgcolor;
  204   1      }
  205          
  206          //-------------------------------------------------------------------------------------------------------
             -------------
  207          // å‡½æ•°ç®€ä»‹       æ¶²æ™¶ç”»ç‚¹
  208          // å‚æ•°è¯´æ˜       x               åæ ‡xæ–¹å‘çš„èµ·ç‚¹ å‚æ•°èŒƒå›´ [0, ips114_x_max-1]
  209          // å‚æ•°è¯´æ˜       y               åæ ‡yæ–¹å‘çš„èµ·ç‚¹ å‚æ•°èŒƒå›´ [0, ips114_y_max-1]
  210          // å‚æ•°è¯´æ˜       dat             éœ€è¦æ˜¾ç¤ºçš„é¢œè‰²
  211          // è¿”å›å‚æ•°      void
  212          // ä½¿ç”¨ç¤ºä¾‹                ips114_draw_point(0,0,RED);                     // åæ ‡ 0,0 ç”»ä¸€ä¸ªçº¢
             -è‰²çš„ç‚¹
  213          //-------------------------------------------------------------------------------------------------------
             -------------
  214          void ips114_draw_point (uint16 x,uint16 y,uint16 color)
  215          {
  216   1          zf_assert(x < ips114_x_max);
  217   1          zf_assert(y < ips114_y_max);
  218   1      
  219   1          ips114_set_region(x,y,x,y);
  220   1          ips114_write_16bit_data(color);
  221   1      }
  222          
  223          //-------------------------------------------------------------------------------------------------------
             -------------
  224          // å‡½æ•°ç®€ä»‹       æ¶²æ™¶æ˜¾ç¤ºå­—ç¬¦
  225          // å‚æ•°è¯´æ˜       x               åæ ‡xæ–¹å‘çš„èµ·ç‚¹ å‚æ•°èŒƒå›´ [0, ips114_x_max-1]
  226          // å‚æ•°è¯´æ˜       y               åæ ‡yæ–¹å‘çš„èµ·ç‚¹ å‚æ•°èŒƒå›´ [0, ips114_y_max-1]
  227          // å‚æ•°è¯´æ˜       dat             éœ€è¦æ˜¾ç¤ºçš„å­—ç¬¦
  228          // è¿”å›å‚æ•°      void
C251 COMPILER V5.60.0,  zf_device_ips114                                                   08/01/26  02:12:47  PAGE 5   

  229          // ä½¿ç”¨ç¤ºä¾‹                ips114_show_char(0,0,'x');                      // åæ ‡ 0,0 å†™ä¸€ä¸ªå­—
             -ç¬¦ x
  230          //-------------------------------------------------------------------------------------------------------
             -------------
  231          void ips114_show_char (uint16 x,uint16 y,const char dat)
  232          {
  233   1          uint8 i,j;
  234   1          uint8 temp;
  235   1        
  236   1        zf_assert(x < ips114_x_max);
  237   1          zf_assert(y < ips114_y_max);
  238   1        
  239   1          for(i=0; i<16; i++)
  240   1          {
  241   2              ips114_set_region(x,y+i,x+7,y+i);
  242   2              temp = ascii_font_8x16[dat-32][i];                                            //å‡ 32 å› ä¸ºæ˜¯å
             -–æ¨¡æ˜¯ä»ç©ºæ ¼å¼€å§‹å–å¾— ç©ºæ ¼åœ¨ ascii ä¸­åºå·æ˜¯ 32
  243   2              for(j=0; j<8; j++)
  244   2              {
  245   3                  if(temp&0x01)   
  246   3                      ips114_write_16bit_data(ips114_pencolor);
  247   3                  else
  248   3                      ips114_write_16bit_data(ips114_bgcolor);
  249   3                  temp>>=1;
  250   3              }
  251   2          }
  252   1      }
  253          
  254          //-------------------------------------------------------------------------------------------------------
             -------------
  255          // å‡½æ•°ç®€ä»‹       æ¶²æ™¶æ˜¾ç¤ºå­—ç¬¦ä¸²
  256          // å‚æ•°è¯´æ˜       x               åæ ‡xæ–¹å‘çš„èµ·ç‚¹ å‚æ•°èŒƒå›´ [0, ips114_x_max-1]
  257          // å‚æ•°è¯´æ˜       y               åæ ‡yæ–¹å‘çš„èµ·ç‚¹ å‚æ•°èŒƒå›´ [0, ips114_y_max-1]
  258          // å‚æ•°è¯´æ˜       dat             éœ€è¦æ˜¾ç¤ºçš„å­—ç¬¦ä¸²
  259          // è¿”å›å‚æ•°      void
  260          // ä½¿ç”¨ç¤ºä¾‹                ips114_show_string(0,0,"seekfree");
  261          //-------------------------------------------------------------------------------------------------------
             -------------
  262          void ips114_show_string (uint16 x,uint16 y,const char dat[])
  263          {
  264   1        uint16 j = 0;
  265   1        
  266   1          zf_assert(x < ips114_x_max);
  267   1          zf_assert(y < ips114_y_max);
  268   1      
  269   1          while(dat[j] != '\0')
  270   1          {
  271   2              ips114_show_char(x+8*j,y,dat[j]);
  272   2              j++;
  273   2          }
  274   1      }
  275          
  276          //-------------------------------------------------------------------------------------------------------
             -------------
  277          //  @brief      æ¶²æ™¶æ˜¾ç¤º8ä½æœ‰ç¬¦å·
  278          // å‚æ•°è¯´æ˜       x               åæ ‡xæ–¹å‘çš„èµ·ç‚¹ å‚æ•°èŒƒå›´ [0, ips114_x_max-1]
  279          // å‚æ•°è¯´æ˜       y               åæ ‡yæ–¹å‘çš„èµ·ç‚¹ å‚æ•°èŒƒå›´ [0, ips114_y_max-1]
  280          //  @param      dat             éœ€è¦æ˜¾ç¤ºçš„å˜é‡ï¼Œæ•°æ®ç±»å‹int8
  281          //  @return     void
  282          //  Sample usage:               ips114_show_int8(0,0,x);                        // xä¸º int8 ç±»å‹
  283          //-------------------------------------------------------------------------------------------------------
             -------------
  284          void ips114_show_int8(uint16 x,uint16 y,int8 dat)
  285          {
  286   1        uint8 a[3];
  287   1          uint8 i;
C251 COMPILER V5.60.0,  zf_device_ips114                                                   08/01/26  02:12:47  PAGE 6   

  288   1        
  289   1          zf_assert(x < ips114_x_max);
  290   1          zf_assert(y < ips114_y_max);
  291   1      
  292   1          if(dat<0)
  293   1          {
  294   2              ips114_show_char(x,y,'-');
  295   2              dat = -dat;
  296   2          }
  297   1          else
  298   1              ips114_show_char(x,y,' ');
  299   1          
  300   1          a[0] = dat/100;
  301   1          a[1] = dat/10%10;
  302   1          a[2] = dat%10;
  303   1          i = 0;
  304   1          while(i<3)
  305   1          {
  306   2              ips114_show_char(x+(8*(i+1)),y,(uint8)('0' + a[i]));
  307   2              i++;
  308   2          }
  309   1      }
  310          
  311          //-------------------------------------------------------------------------------------------------------
             -------------
  312          // å‡½æ•°ç®€ä»‹       æ¶²æ™¶æ˜¾ç¤º8ä½æ— ç¬¦å·
  313          // å‚æ•°è¯´æ˜       x               åæ ‡xæ–¹å‘çš„èµ·ç‚¹ å‚æ•°èŒƒå›´ [0, ips114_x_max-1]
  314          // å‚æ•°è¯´æ˜       y               åæ ‡yæ–¹å‘çš„èµ·ç‚¹ å‚æ•°èŒƒå›´ [0, ips114_y_max-1]
  315          // å‚æ•°è¯´æ˜       dat             éœ€è¦æ˜¾ç¤ºçš„å˜é‡ æ•°æ®ç±»å‹uint8
  316          // è¿”å›å‚æ•°      void
  317          // ä½¿ç”¨ç¤ºä¾‹                ips114_show_uint8(0,0,x);                       // x ä¸º uint8 ç±»å‹
  318          //-------------------------------------------------------------------------------------------------------
             -------------
  319          void ips114_show_uint8(uint16 x,uint16 y,uint8 dat)
  320          {
  321   1          uint8 a[3];
  322   1          uint8 i;
  323   1        
  324   1          zf_assert(x < ips114_x_max);
  325   1          zf_assert(y < ips114_y_max);
  326   1        
  327   1          a[0] = dat/100;
  328   1          a[1] = dat/10%10;
  329   1          a[2] = dat%10;
  330   1          i = 0;
  331   1          while(i<3)
  332   1          {
  333   2              ips114_show_char(x+(8*i),y,(uint8)('0' + a[i]));
  334   2              i++;
  335   2          }
  336   1          
  337   1      }
  338          
  339          //-------------------------------------------------------------------------------------------------------
             -------------
  340          // å‡½æ•°ç®€ä»‹       æ¶²æ™¶æ˜¾ç¤º16ä½æœ‰ç¬¦å·
  341          // å‚æ•°è¯´æ˜       x               åæ ‡xæ–¹å‘çš„èµ·ç‚¹ å‚æ•°èŒƒå›´ [0, ips114_x_max-1]
  342          // å‚æ•°è¯´æ˜       y               åæ ‡yæ–¹å‘çš„èµ·ç‚¹ å‚æ•°èŒƒå›´ [0, ips114_y_max-1]
  343          // å‚æ•°è¯´æ˜       dat             éœ€è¦æ˜¾ç¤ºçš„å˜é‡ æ•°æ®ç±»å‹int16
  344          // è¿”å›å‚æ•°      void
  345          // ä½¿ç”¨ç¤ºä¾‹                ips114_show_int16(0,0,x);                       // x ä¸º int16 ç±»å‹
  346          //-------------------------------------------------------------------------------------------------------
             -------------
  347          void ips114_show_int16(uint16 x,uint16 y,int16 dat)
  348          {
  349   1          uint8 a[5];
C251 COMPILER V5.60.0,  zf_device_ips114                                                   08/01/26  02:12:47  PAGE 7   

  350   1          uint8 i;
  351   1        
  352   1          zf_assert(x < ips114_x_max);
  353   1          zf_assert(y < ips114_y_max);
  354   1      
  355   1          if(dat<0)
  356   1          {
  357   2              ips114_show_char(x,y,'-');
  358   2              dat = -dat;
  359   2          }
  360   1          else    ips114_show_char(x,y,' ');
  361   1      
  362   1          a[0] = dat/10000;
  363   1          a[1] = dat/1000%10;
  364   1          a[2] = dat/100%10;
  365   1          a[3] = dat/10%10;
  366   1          a[4] = dat%10;
  367   1          
  368   1          i = 0;
  369   1          while(i<5)
  370   1          {
  371   2              ips114_show_char(x+(8*(i+1)),y,(uint8)('0' + a[i]));
  372   2              i++;
  373   2          }
  374   1      }
  375          
  376          //-------------------------------------------------------------------------------------------------------
             -------------
  377          // å‡½æ•°ç®€ä»‹       æ¶²æ™¶æ˜¾ç¤º16ä½æ— ç¬¦å·
  378          // å‚æ•°è¯´æ˜       x               åæ ‡xæ–¹å‘çš„èµ·ç‚¹ å‚æ•°èŒƒå›´ [0, ips114_x_max-1]
  379          // å‚æ•°è¯´æ˜       y               åæ ‡yæ–¹å‘çš„èµ·ç‚¹ å‚æ•°èŒƒå›´ [0, ips114_y_max-1]
  380          // å‚æ•°è¯´æ˜       dat             éœ€è¦æ˜¾ç¤ºçš„å˜é‡ï¼Œæ•°æ®ç±»å‹uint16
  381          // è¿”å›å‚æ•°      void
  382          // ä½¿ç”¨ç¤ºä¾‹                ips114_show_uint16(0,0,x);                      // x ä¸º uint16 ç±»å‹
  383          //-------------------------------------------------------------------------------------------------------
             -------------
  384          void ips114_show_uint16(uint16 x,uint16 y,uint16 dat)
  385          {
  386   1          uint8 a[5];
  387   1          uint8 i;
  388   1        
  389   1          zf_assert(x < ips114_x_max);
  390   1          zf_assert(y < ips114_y_max);
  391   1        
  392   1          a[0] = dat/10000;
  393   1          a[1] = dat/1000%10;
  394   1          a[2] = dat/100%10;
  395   1          a[3] = dat/10%10;
  396   1          a[4] = dat%10;
  397   1          
  398   1          i = 0;
  399   1          while(i<5)
  400   1          {
  401   2              ips114_show_char(x+(8*i),y,(uint8)('0' + a[i]));
  402   2              i++;
  403   2          }
  404   1      }
  405          
  406          //-------------------------------------------------------------------------------------------------------
             -------------
  407          // å‡½æ•°ç®€ä»‹       æ¶²æ™¶æ˜¾ç¤º32ä½æœ‰ç¬¦å·(å»é™¤æ•´æ•°éƒ¨åˆ†æ— æ•ˆçš„0)
  408          // å‚æ•°è¯´æ˜       x               åæ ‡xæ–¹å‘çš„èµ·ç‚¹ å‚æ•°èŒƒå›´ [0, ips114_x_max-1]
  409          // å‚æ•°è¯´æ˜       y               åæ ‡yæ–¹å‘çš„èµ·ç‚¹ å‚æ•°èŒƒå›´ [0, ips114_y_max-1]
  410          // å‚æ•°è¯´æ˜       dat             éœ€è¦æ˜¾ç¤ºçš„å˜é‡ï¼Œæ•°æ®ç±»å‹uint32
  411          // å‚æ•°è¯´æ˜       num             éœ€è¦æ˜¾ç¤ºçš„ä½æ•° æœ€é«˜10ä½  ä¸åŒ…å«æ­£è´Ÿå·
  412          // è¿”å›å‚æ•°      void
C251 COMPILER V5.60.0,  zf_device_ips114                                                   08/01/26  02:12:47  PAGE 8   

  413          // ä½¿ç”¨ç¤ºä¾‹                ips114_show_int32(0,0,x,3);                     // x å¯ä»¥ä¸º int32 uint1
             -6 int16 uint8 int8 ç±»å‹
  414          // note:                        è´Ÿæ•°ä¼šæ˜¾ç¤ºä¸€ä¸ª â€˜-â€™å·   æ­£æ•°æ˜¾ç¤ºä¸€ä¸ªç©ºæ ¼
  415          //-------------------------------------------------------------------------------------------------------
             -------------
  416          void ips114_show_int32(uint16 x,uint16 y,int32 dat,uint8 num)
  417          {
  418   1        
  419   1          int8    buff[34];
  420   1          uint8   length;
  421   1        
  422   1          zf_assert(x < ips114_x_max);
  423   1          zf_assert(y < ips114_y_max);
  424   1      
  425   1          if(10<num)      num = 10;
  426   1          
  427   1          num++;
  428   1          if(0>dat)   length = zf_sprintf( &buff[0],(const int8 *)"%d",dat);        // è´Ÿæ•°
  429   1          else
  430   1          {
  431   2              buff[0] = ' ';
  432   2              length = zf_sprintf( &buff[1],(const int8 *)"%d",dat);
  433   2              length++;
  434   2          }
  435   1          while(length < num)
  436   1          {
  437   2              buff[length] = ' ';
  438   2              length++;
  439   2          }
  440   1          buff[num] = '\0';
  441   1      
  442   1          ips114_show_string(x, y, (const char *)buff);                               // æ˜¾ç¤ºæ•°å­—
  443   1      }
  444          
  445          //-------------------------------------------------------------------------------------------------------
             -------------
  446          // å‡½æ•°ç®€ä»‹       æ¶²æ™¶æ˜¾ç¤ºæµ®ç‚¹æ•°(å»é™¤æ•´æ•°éƒ¨åˆ†æ— æ•ˆçš„0)
  447          // å‚æ•°è¯´æ˜       x               åæ ‡xæ–¹å‘çš„èµ·ç‚¹ å‚æ•°èŒƒå›´ [0, ips114_x_max-1]
  448          // å‚æ•°è¯´æ˜       y               åæ ‡yæ–¹å‘çš„èµ·ç‚¹ å‚æ•°èŒƒå›´ [0, ips114_y_max-1]
  449          // å‚æ•°è¯´æ˜       dat             éœ€è¦æ˜¾ç¤ºçš„å˜é‡ï¼Œæ•°æ®ç±»å‹floatæˆ–double
  450          // å‚æ•°è¯´æ˜       num             æ•´æ•°ä½æ˜¾ç¤ºé•¿åº¦   æœ€é«˜10ä½
  451          // å‚æ•°è¯´æ˜       pointnum        å°æ•°ä½æ˜¾ç¤ºé•¿åº¦   æœ€é«˜6ä½
  452          // è¿”å›å‚æ•°      void
  453          // ä½¿ç”¨ç¤ºä¾‹                ips114_show_float(0,0,x,2,3);                    // æ˜¾ç¤ºæµ®ç‚¹æ•°   æ•´æ
             -•°æ˜¾ç¤º2ä½   å°æ•°æ˜¾ç¤ºä¸‰ä½
  454          // @note                        ç‰¹åˆ«æ³¨æ„å½“å‘ç°å°æ•°éƒ¨åˆ†æ˜¾ç¤ºçš„å€¼ä¸ä½ å†™å…¥çš„å€¼ä¸ä¸€æ ·ç
             -š„æ—¶å€™ï¼Œ
  455          //                              å¯èƒ½æ˜¯ç”±äºæµ®ç‚¹æ•°ç²¾åº¦ä¸¢å¤±é—®é¢˜å¯¼è‡´çš„ï¼Œè¿™å¹¶ä¸æ˜¯æ˜¾ç¤ºå
             -‡½æ•°çš„é—®é¢˜ï¼Œ
  456          //                              æœ‰å…³é—®é¢˜çš„è¯¦æƒ…ï¼Œè¯·è‡ªè¡Œç™¾åº¦å­¦ä¹    æµ®ç‚¹æ•°ç²¾åº¦ä¸¢å¤±é—®é
             -¢˜ã€‚
  457          //                              è´Ÿæ•°ä¼šæ˜¾ç¤ºä¸€ä¸ª â€˜-â€™å·   æ­£æ•°æ˜¾ç¤ºä¸€ä¸ªç©ºæ ¼
  458          //-------------------------------------------------------------------------------------------------------
             -------------
  459          void ips114_show_float(uint16 x,uint16 y,double dat,uint8 num,uint8 pointnum)
  460          {
  461   1          uint8   length;
  462   1          int8    buff[34];
  463   1          int8    start,end,point;
  464   1        
  465   1          zf_assert(x < ips114_x_max);
  466   1          zf_assert(y < ips114_y_max);
  467   1        
  468   1          if(6<pointnum)  pointnum = 6;
  469   1          if(10<num)      num = 10;
  470   1              
C251 COMPILER V5.60.0,  zf_device_ips114                                                   08/01/26  02:12:47  PAGE 9   

  471   1          if(0>dat)   length = zf_sprintf( &buff[0],(const int8 *)"%f",dat);        // è´Ÿæ•°
  472   1          else
  473   1          {
  474   2              length = zf_sprintf( &buff[1],(const int8 *)"%f",dat);
  475   2              length++;
  476   2          }
  477   1          point = length - 7;                                                         // è®¡ç®—å°æ•°ç‚¹ä½ç½®
  478   1          start = point - num - 1;                                                    // è®¡ç®—èµ·å§‹ä½
  479   1          end = point + pointnum + 1;                                                 // è®¡ç®—ç»“æŸä½
  480   1          while(0>start)                                                              // æ•´æ•°ä½ä¸å¤Ÿ  æœ«å°
             -¾åº”è¯¥å¡«å……ç©ºæ ¼
  481   1          {
  482   2              buff[end] = ' ';
  483   2              end++;
  484   2              start++;
  485   2          }
  486   1          
  487   1          if(0>dat)   buff[start] = '-';
  488   1          else        buff[start] = ' ';
  489   1          
  490   1          buff[end] = '\0';
  491   1      
  492   1          ips114_show_string(x, y, (const char *)buff);                               // æ˜¾ç¤ºæ•°å­—
  493   1      }
  494          
  495          
  496          //-------------------------------------------------------------------------------------------------------
             -------------
  497          // å‡½æ•°ç®€ä»‹       IPS114 æ˜¾ç¤ºæ³¢å½¢
  498          // å‚æ•°è¯´æ˜       x               åæ ‡xæ–¹å‘çš„èµ·ç‚¹ å‚æ•°èŒƒå›´ [0, ips114_x_max-1]
  499          // å‚æ•°è¯´æ˜       y               åæ ‡yæ–¹å‘çš„èµ·ç‚¹ å‚æ•°èŒƒå›´ [0, ips114_y_max-1]
  500          // å‚æ•°è¯´æ˜       *p              æ³¢å½¢æ•°ç»„æŒ‡é’ˆ
  501          // å‚æ•°è¯´æ˜       width           æ³¢å½¢å®é™…å®½åº¦
  502          // å‚æ•°è¯´æ˜       value_max       æ³¢å½¢å®é™…æœ€å¤§å€¼
  503          // å‚æ•°è¯´æ˜       dis_width       æ³¢å½¢æ˜¾ç¤ºå®½åº¦ å‚æ•°èŒƒå›´ [0, ips114_x_max]
  504          // å‚æ•°è¯´æ˜       dis_value_max   æ³¢å½¢æ˜¾ç¤ºæœ€å¤§å€¼ å‚æ•°èŒƒå›´ [0, ips114_y_max]
  505          // è¿”å›å‚æ•°      void
  506          // ä½¿ç”¨ç¤ºä¾‹                ips114_show_gray_image(0,0,camera_buffer_addr,MT9V03X_W,MT9V03X_H,240,135,
             -128);
  507          //-------------------------------------------------------------------------------------------------------
             -------------
  508          void ips114_show_wave(uint16 x, uint16 y, uint8 *p, uint16 width, uint16 value_max, uint16 dis_width, uin
             -t16 dis_value_max)
  509          {
  510   1          uint32 i = 0, j = 0;
  511   1          uint32 width_index, value_max_index;
  512   1        
  513   1          zf_assert(x < ips114_x_max);
  514   1          zf_assert(y < ips114_y_max);
  515   1        
  516   1          ips114_set_region(x, y, x+dis_width-1, y+dis_value_max-1);                  // è®¾ç½®æ˜¾ç¤ºåŒºåŸŸ
  517   1          for(i=0;i<dis_value_max;i++)
  518   1          {
  519   2              for(j=0;j<dis_width;j++)
  520   2              {
  521   3                  ips114_write_16bit_data(ips114_bgcolor); 
  522   3              }
  523   2          }
  524   1      
  525   1          for(i=0;i<dis_width;i++)
  526   1          {
  527   2              width_index = i*width/dis_width;
  528   2              value_max_index = *(p+width_index)*(dis_value_max-1)/value_max;
  529   2              ips114_draw_point(i+x, (dis_value_max-1)-value_max_index+y, ips114_pencolor);
  530   2          }
  531   1      }
C251 COMPILER V5.60.0,  zf_device_ips114                                                   08/01/26  02:12:47  PAGE 10  

  532          
  533          //-------------------------------------------------------------------------------------------------------
             -------------
  534          // å‡½æ•°ç®€ä»‹       æ±‰å­—æ˜¾ç¤º
  535          // å‚æ•°è¯´æ˜       x               åæ ‡xæ–¹å‘çš„èµ·ç‚¹ å‚æ•°èŒƒå›´ [0, ips114_x_max-1]
  536          // å‚æ•°è¯´æ˜       y               åæ ‡yæ–¹å‘çš„èµ·ç‚¹ å‚æ•°èŒƒå›´ [0, ips114_y_max-1]
  537          // å‚æ•°è¯´æ˜       siz            å–æ¨¡çš„æ—¶å€™è®¾ç½®çš„æ±‰å­—å­—ä½“å¤§å° ä¹Ÿå°±æ˜¯ä¸€ä¸ªæ±‰å­—å ç
             -”¨çš„ç‚¹é˜µé•¿å®½ä¸ºå¤šå°‘ä¸ªç‚¹ å–æ¨¡çš„æ—¶å€™éœ€è¦é•¿å®½æ˜¯ä¸€æ ·çš„
  538          // å‚æ•°è¯´æ˜       *p              éœ€è¦æ˜¾ç¤ºçš„æ±‰å­—æ•°ç»„
  539          // å‚æ•°è¯´æ˜       number          éœ€è¦æ˜¾ç¤ºå¤šå°‘ä½
  540          // å‚æ•°è¯´æ˜       color           æ˜¾ç¤ºé¢œè‰²
  541          // è¿”å›å‚æ•°      void
  542          // ä½¿ç”¨ç¤ºä¾‹                ips114_show_chinese(0,0,16,chinese_test[0],4,RED);//æ˜¾ç¤ºfontæ–‡ä»¶é‡Œé¢
             -çš„ ç¤ºä¾‹
  543          // å¤‡æ³¨ä¿¡æ¯                        ä½¿ç”¨PCtoLCD2002è½¯ä»¶å–æ¨¡           é˜´ç ã€é€è¡Œå¼ã€é¡ºå
             -‘   16*16
  544          //-------------------------------------------------------------------------------------------------------
             -------------
  545          void ips114_show_chinese (uint16 x, uint16 y, uint8 siz, const uint8 *p, uint8 number, uint16 color)
  546          {
  547   1      
  548   1          int i, j, k; 
  549   1          uint8 temp, temp1, temp2;
  550   1          const uint8 *p_data;
  551   1              
  552   1        zf_assert(x < ips114_x_max);
  553   1          zf_assert(y < ips114_y_max);
  554   1      
  555   1          temp2 = siz/8;
  556   1          
  557   1          ips114_set_region(x,y,number*siz-1+x,y+siz-1);
  558   1          
  559   1          for(i=0;i<siz;i++)
  560   1          {
  561   2              temp1 = number;
  562   2              p_data = p+i*temp2;
  563   2              while(temp1--)
  564   2              {
  565   3                  for(k=0;k<temp2;k++)
  566   3                  {
  567   4                      for(j=8;j>0;j--)
  568   4                      {
  569   5                          temp = (*p_data>>(j-1)) & 0x01;
  570   5                          if(temp)    ips114_write_16bit_data(color);
  571   5                          else        ips114_write_16bit_data(ips114_bgcolor);
  572   5                      }
  573   4                      p_data++;
  574   4                  }
  575   3                  p_data = p_data - temp2 + temp2*siz;
  576   3              }   
  577   2          }
  578   1      }
  579          
  580          //-------------------------------------------------------------------------------------------------------
             -------------
  581          // å‡½æ•°ç®€ä»‹       1.14å¯¸ IPSæ¶²æ™¶åˆå§‹åŒ–
  582          // è¿”å›å‚æ•°      void
  583          // ä½¿ç”¨ç¤ºä¾‹                ips114_init();
  584          //-------------------------------------------------------------------------------------------------------
             -------------
  585          void ips114_init (void)
  586          {
  587   1      #if (IPS114_USE_INTERFACE==SOFT_SPI)
                   soft_spi_init(&ips114_spi, SPI_MODE0, IPS114_SOFT_SPI_DELAY, IPS114_SCL_PIN, IPS114_SDA_PIN, SOFT_SPI
             -_PIN_NULL, SOFT_SPI_PIN_NULL);
               #elif (IPS114_USE_INTERFACE==HARDWARE_SPI)
C251 COMPILER V5.60.0,  zf_device_ips114                                                   08/01/26  02:12:47  PAGE 11  

  590   1          zf_assert(IPS114_SPI != (IPS114_SCL_PIN&0xF000>>12));
  591   1          zf_assert(IPS114_SPI != (IPS114_SDA_PIN&0xF000>>12));
  592   1          spi_init(IPS114_SPI, SPI_MODE0, IPS114_SPI_SPEED, IPS114_SCL_PIN, IPS114_SDA_PIN, SPI_MISO_NULL, SPI_
             -CS_NULL);
  593   1      #endif
  594   1      
  595   1      //    gpio_init(IPS114_DC_PIN, GPO, GPIO_LOW, GPO_PUSH_PULL);
  596   1      //    gpio_init(IPS114_RST_PIN, GPO, GPIO_LOW, GPO_PUSH_PULL);
  597   1      //    gpio_init(IPS114_CS_PIN, GPO, GPIO_LOW, GPO_PUSH_PULL);
  598   1      //    gpio_init(IPS114_BLK_PIN, GPO, GPIO_HIGH, GPO_PUSH_PULL);
  599   1      
  600   1          ips114_set_dir(ips114_display_dir);
  601   1          ips114_set_color(ips114_pencolor, ips114_bgcolor);
  602   1      
  603   1          IPS114_RST(0);
  604   1          system_delay_ms(200);
  605   1      
  606   1          IPS114_RST(1);
  607   1          system_delay_ms(100);
  608   1      
  609   1          ips114_write_index(0x36);
  610   1          system_delay_ms(100);
  611   1          if      (ips114_display_dir==0) ips114_write_8bit_data(0x00);
  612   1          else if (ips114_display_dir==1) ips114_write_8bit_data(0xC0);
  613   1          else if (ips114_display_dir==2) ips114_write_8bit_data(0x70);
  614   1          else                            ips114_write_8bit_data(0xA0);
  615   1      
  616   1          ips114_write_index(0x3A);
  617   1          ips114_write_8bit_data(0x05);
  618   1      
  619   1          ips114_write_index(0xB2);
  620   1          ips114_write_8bit_data(0x0C);
  621   1          ips114_write_8bit_data(0x0C);
  622   1          ips114_write_8bit_data(0x00);
  623   1          ips114_write_8bit_data(0x33);
  624   1          ips114_write_8bit_data(0x33);
  625   1      
  626   1          ips114_write_index(0xB7);
  627   1          ips114_write_8bit_data(0x35);
  628   1      
  629   1          ips114_write_index(0xBB);
  630   1          ips114_write_8bit_data(0x37);
  631   1      
  632   1          ips114_write_index(0xC0);
  633   1          ips114_write_8bit_data(0x2C);
  634   1      
  635   1          ips114_write_index(0xC2);
  636   1          ips114_write_8bit_data(0x01);
  637   1      
  638   1          ips114_write_index(0xC3);
  639   1          ips114_write_8bit_data(0x12);
  640   1      
  641   1          ips114_write_index(0xC4);
  642   1          ips114_write_8bit_data(0x20);
  643   1      
  644   1          ips114_write_index(0xC6);
  645   1          ips114_write_8bit_data(0x0F);
  646   1      
  647   1          ips114_write_index(0xD0);
  648   1          ips114_write_8bit_data(0xA4);
  649   1          ips114_write_8bit_data(0xA1);
  650   1      
  651   1          ips114_write_index(0xE0);
  652   1          ips114_write_8bit_data(0xD0);
  653   1          ips114_write_8bit_data(0x04);
  654   1          ips114_write_8bit_data(0x0D);
C251 COMPILER V5.60.0,  zf_device_ips114                                                   08/01/26  02:12:47  PAGE 12  

  655   1          ips114_write_8bit_data(0x11);
  656   1          ips114_write_8bit_data(0x13);
  657   1          ips114_write_8bit_data(0x2B);
  658   1          ips114_write_8bit_data(0x3F);
  659   1          ips114_write_8bit_data(0x54);
  660   1          ips114_write_8bit_data(0x4C);
  661   1          ips114_write_8bit_data(0x18);
  662   1          ips114_write_8bit_data(0x0D);
  663   1          ips114_write_8bit_data(0x0B);
  664   1          ips114_write_8bit_data(0x1F);
  665   1          ips114_write_8bit_data(0x23);
  666   1      
  667   1          ips114_write_index(0xE1);
  668   1          ips114_write_8bit_data(0xD0);
  669   1          ips114_write_8bit_data(0x04);
  670   1          ips114_write_8bit_data(0x0C);
  671   1          ips114_write_8bit_data(0x11);
  672   1          ips114_write_8bit_data(0x13);
  673   1          ips114_write_8bit_data(0x2C);
  674   1          ips114_write_8bit_data(0x3F);
  675   1          ips114_write_8bit_data(0x44);
  676   1          ips114_write_8bit_data(0x51);
  677   1          ips114_write_8bit_data(0x2F);
  678   1          ips114_write_8bit_data(0x1F);
  679   1          ips114_write_8bit_data(0x1F);
  680   1          ips114_write_8bit_data(0x20);
  681   1          ips114_write_8bit_data(0x23);
  682   1      
  683   1          ips114_write_index(0x21);
  684   1      
  685   1          ips114_write_index(0x11);
  686   1          system_delay_ms(120);
  687   1      
  688   1          ips114_write_index(0x29);
  689   1      
  690   1          ips114_clear(ips114_bgcolor);
  691   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      4118     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =         8        176
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        84     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
