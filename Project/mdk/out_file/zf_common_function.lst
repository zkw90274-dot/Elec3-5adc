C251 COMPILER V5.60.0,  zf_common_function                                                 08/01/26  02:12:46  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_common_function
OBJECT MODULE PLACED IN .\out_file\zf_common_function.obj
COMPILER INVOKED BY: E:\Tools\keil5\Keil_v5\C251\BIN\C251.EXE ..\..\libraries\zf_common\zf_common_function.c LARGE NOALI
                    -AS WARNINGLEVEL(3) OPTIMIZE(SIZE) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\
                    -zf_device;..\..\libraries\zf_driver;..\user;..\code) DEBUG PRINT(.\out_file\zf_common_function.lst) TABS(2) OBJECT(.\out
                    -_file\zf_common_function.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * STC32G Opensourec Library ¼´£¨STC32G ¿ªÔ´¿â£©ÊÇÒ»¸ö»ùÓÚ¹Ù·½ SDK ½Ó¿ÚµÄµÚÈý·½¿ªÔ´¿â
    3          * Copyright (c) 2022 SEEKFREE Öð·É¿Æ¼¼
    4          *
    5          * ±¾ÎÄ¼þÊÇSTC ¿ªÔ´¿âµÄÒ»²¿·Ö
    6          *
    7          * STC32G ¿ªÔ´¿â ÊÇÃâ·ÑÈí¼þ
    8          * Äú¿ÉÒÔ¸ù¾Ý×ÔÓÉÈí¼þ»ù½ð»á·¢²¼µÄ GPL£¨GNU General Public License£¬¼´ GNUÍ¨ÓÃ¹«¹²Ðí¿ÉÖ¤£©µÄÌõ¿î
    9          * ¼´ GPL µÄµÚ3°æ£¨¼´ GPL3.0£©»ò£¨ÄúÑ¡ÔñµÄ£©ÈÎºÎºóÀ´µÄ°æ±¾£¬ÖØÐÂ·¢²¼ºÍ/»òÐÞ¸ÄËü
   10          *
   11          * ±¾¿ªÔ´¿âµÄ·¢²¼ÊÇÏ£ÍûËüÄÜ·¢»Ó×÷ÓÃ£¬µ«²¢Î´¶ÔÆä×÷ÈÎºÎµÄ±£Ö¤
   12          * ÉõÖÁÃ»ÓÐÒþº¬µÄÊÊÏúÐÔ»òÊÊºÏÌØ¶¨ÓÃÍ¾µÄ±£Ö¤
   13          * ¸ü¶àÏ¸½ÚÇë²Î¼û GPL
   14          *
   15          * ÄúÓ¦¸ÃÔÚÊÕµ½±¾¿ªÔ´¿âµÄÍ¬Ê±ÊÕµ½Ò»·Ý GPL µÄ¸±±¾
   16          * Èç¹ûÃ»ÓÐ£¬Çë²ÎÔÄ<https://www.gnu.org/licenses/>
   17          *
   18          * ¶îÍâ×¢Ã÷£º
   19          * ±¾¿ªÔ´¿âÊ¹ÓÃ GPL3.0 ¿ªÔ´Ðí¿ÉÖ¤Ð­Òé ÒÔÉÏÐí¿ÉÉêÃ÷ÎªÒëÎÄ°æ±¾
   20          * Ðí¿ÉÉêÃ÷Ó¢ÎÄ°æÔÚ libraries/doc ÎÄ¼þ¼ÐÏÂµÄ GPL3_permission_statement.txt ÎÄ¼þÖÐ
   21          * Ðí¿ÉÖ¤¸±±¾ÔÚ libraries ÎÄ¼þ¼ÐÏÂ ¼´¸ÃÎÄ¼þ¼ÐÏÂµÄ LICENSE ÎÄ¼þ
   22          * »¶Ó­¸÷Î»Ê¹ÓÃ²¢´«²¥±¾³ÌÐò µ«ÐÞ¸ÄÄÚÈÝÊ±±ØÐë±£ÁôÖð·É¿Æ¼¼µÄ°æÈ¨ÉùÃ÷£¨¼´±¾ÉùÃ÷£©
   23          *
   24          * ÎÄ¼þÃû³Æ          
   25          * ¹«Ë¾Ãû³Æ          ³É¶¼Öð·É¿Æ¼¼ÓÐÏÞ¹«Ë¾
   26          * °æ±¾ÐÅÏ¢          ²é¿´ libraries/doc ÎÄ¼þ¼ÐÄÚ version ÎÄ¼þ °æ±¾ËµÃ÷
   27          * ¿ª·¢»·¾³          MDK FOR C251
   28          * ÊÊÓÃÆ½Ì¨          STC32G
   29          * µêÆÌÁ´½Ó          https://seekfree.taobao.com/
   30          *
   31          * ÐÞ¸Ä¼ÇÂ¼
   32          * ÈÕÆÚ              ×÷Õß           ±¸×¢
   33          * 2024-08-01        ´óW            first version
   34          *********************************************************************************************************
             -***********/
   35          
   36          #include "zf_common_debug.h"
   37          #include "zf_common_function.h"
   38          #include <stdarg.h>  // °üº¬±ê×¼¿É±ä²ÎÊýºêµÄÍ·ÎÄ¼þ
   39          #include <stdio.h>   // °üº¬±ê×¼ÊäÈëÊä³öµÄÍ·ÎÄ¼þ
   40          
   41          //-------------------------------------------------------------------------------------------------------
             -------------
   42          // º¯Êý¼ò½é     »ñÈ¡ÕûÐÍÊýµÄ×î´ó¹«Ô¼Êý ¾ÅÕÂËãÊõÖ®¸üÏà¼õËðÊõ
   43          // ²ÎÊýËµÃ÷     num1            Êý×Ö1
   44          // ²ÎÊýËµÃ÷     num2            Êý×Ö2
   45          // ·µ»Ø²ÎÊý     uint32          ×î´ó¹«Ô¼Êý
   46          // Ê¹ÓÃÊ¾Àý     return func_get_greatest_common_divisor(144, 36);               // »ñÈ¡ 144 Óë 36 µÄ×î´ó¹
             -«Ô¼Êý
   47          // ±¸×¢ÐÅÏ¢     
   48          //-------------------------------------------------------------------------------------------------------
             -------------
   49          uint32 func_get_greatest_common_divisor (uint32 num1, uint32 num2)
   50          {
   51   1          while(num1 != num2)
C251 COMPILER V5.60.0,  zf_common_function                                                 08/01/26  02:12:46  PAGE 2   

   52   1          {
   53   2              if(num1 > num2)
   54   2              {
   55   3                  num1 = num1 - num2;
   56   3              }
   57   2              if(num1 < num2)
   58   2              {
   59   3                  num2 = num2 - num1;
   60   3              }
   61   2          }
   62   1          return num1;
   63   1      }
   64          
   65          //-------------------------------------------------------------------------------------------------------
             -------------
   66          // º¯Êý¼ò½é     Èí¼þÑÓÊ±
   67          // ²ÎÊýËµÃ÷     t               ÑÓÊ±Ê±¼ä
   68          // ·µ»Ø²ÎÊý     void
   69          // Ê¹ÓÃÊ¾Àý     func_soft_delay(100);
   70          // ±¸×¢ÐÅÏ¢     
   71          //-------------------------------------------------------------------------------------------------------
             -------------
   72          void func_soft_delay (volatile long t)
   73          {
   74   1          while(t --);
   75   1      }
   76          
   77          //-------------------------------------------------------------------------------------------------------
             -------------
   78          // º¯Êý¼ò½é     ×Ö·û´®×ªÕûÐÎÊý×Ö Êý¾Ý·¶Î§ÊÇ [-32768,32767]
   79          // ²ÎÊýËµÃ÷     *str            ´«Èë×Ö·û´® ¿É´ø·ûºÅ
   80          // ·µ»Ø²ÎÊý     int32           ×ª»»ºóµÄÊý¾Ý          
   81          // Ê¹ÓÃÊ¾Àý     int32 dat = func_str_to_int("-100");
   82          // ±¸×¢ÐÅÏ¢     
   83          //-------------------------------------------------------------------------------------------------------
             -------------
   84          int32 func_str_to_int (char *str)
   85          {
   86   1          uint8 sign = 0;                                                             // ±ê¼Ç·ûºÅ 0-ÕýÊý 1-¸ºÊý
   87   1          int32 temp = 0;                                                             // ÁÙÊ±¼ÆËã±äÁ¿
   88   1        zf_assert(str != NULL);
   89   1        do
   90   1          {
   91   2              if(NULL == str)
   92   2              {
   93   3                  break;
   94   3              }
   95   2      
   96   2              if('-' == *str)                                                         // Èç¹ûµÚÒ»¸ö×Ö·ûÊÇ¸ººÅ
   97   2              {
   98   3                  sign = 1;                                                           // ±ê¼Ç¸ºÊý
   99   3                  str ++;
  100   3              }
  101   2              else if('+' == *str)                                                    // Èç¹ûµÚÒ»¸ö×Ö·ûÊÇÕýºÅ
  102   2              {
  103   3                  str ++;
  104   3              }
  105   2      
  106   2              while(('0' <= *str) && ('9' >= *str))                                   // È·¶¨ÕâÊÇ¸öÊý×Ö
  107   2              {
  108   3                  temp = temp * 10 + ((uint8)(*str) - 0x30);                          // ¼ÆËãÊýÖµ
  109   3                  str ++;
  110   3              }
  111   2      
  112   2              if(sign)
  113   2              {
C251 COMPILER V5.60.0,  zf_common_function                                                 08/01/26  02:12:46  PAGE 3   

  114   3                  temp = -temp;
  115   3              }
  116   2          }while(0);
  117   1          return temp;
  118   1      }
  119          
  120          //-------------------------------------------------------------------------------------------------------
             -------------
  121          // º¯Êý¼ò½é     ÕûÐÎÊý×Ö×ª×Ö·û´® Êý¾Ý·¶Î§ÊÇ [-32768,32767]
  122          // ²ÎÊýËµÃ÷     *str            ×Ö·û´®Ö¸Õë
  123          // ²ÎÊýËµÃ÷     number          ´«ÈëµÄÊý¾Ý
  124          // ·µ»Ø²ÎÊý     void
  125          // Ê¹ÓÃÊ¾Àý     func_int_to_str(data_buffer, -300);
  126          // ±¸×¢ÐÅÏ¢     
  127          //-------------------------------------------------------------------------------------------------------
             -------------
  128          void func_int_to_str (char *str, int32 number)
  129          {
  130   1          uint8 data_temp[16];                                                        // »º³åÇø
  131   1          uint8 temp_bit = 0;                                                              // Êý×ÖÎ»Êý
  132   1          int32 number_temp = 0;
  133   1          zf_assert(str != NULL);
  134   1          do
  135   1          {
  136   2              if(NULL == str)
  137   2              {
  138   3                  break;
  139   3              }
  140   2      
  141   2              if(0 > number)                                                          // ¸ºÊý
  142   2              {
  143   3                  *str ++ = '-';
  144   3                  number = -number;
  145   3              }
  146   2              else if(0 == number)                                                    // »òÕßÕâÊÇ¸ö 0
  147   2              {
  148   3                  *str = '0';
  149   3                  break;
  150   3              }
  151   2      
  152   2              while(0 != number)                                                      // Ñ­»·Ö±µ½ÊýÖµ¹éÁã
  153   2              {
  154   3                  number_temp = number % 10;
  155   3                  data_temp[temp_bit ++] = func_abs(number_temp);                          // µ¹Ðò½«ÊýÖµÌáÈ¡³öÀ
             -´
  156   3                  number /= 10;                                                       // Ï÷¼õ±»ÌáÈ¡µÄ¸öÎ»Êý
  157   3              }
  158   2              while(0 != temp_bit)                                                         // ÌáÈ¡µÄÊý×Ö¸öÊýµÝ¼
             -õ´¦Àí
  159   2              {
  160   3                  *str ++ = (data_temp[temp_bit - 1] + 0x30);                              // ½«Êý×Ö´Óµ¹ÐòÊý×éÖ
             -Ðµ¹ÐòÈ¡³ö ±ä³ÉÕýÐò·ÅÈë×Ö·û´®
  161   3                  temp_bit --;
  162   3              }
  163   2          }while(0);
  164   1      }
  165          
  166          //-------------------------------------------------------------------------------------------------------
             -------------
  167          // º¯Êý¼ò½é     ×Ö·û´®×ªÕûÐÎÊý×Ö Êý¾Ý·¶Î§ÊÇ [0,65535]
  168          // ²ÎÊýËµÃ÷     *str            ´«Èë×Ö·û´® ÎÞ·ûºÅ
  169          // ·µ»Ø²ÎÊý     uint32          ×ª»»ºóµÄÊý¾Ý          
  170          // Ê¹ÓÃÊ¾Àý     uint32 dat = func_str_to_uint("100");
  171          // ±¸×¢ÐÅÏ¢     
  172          //-------------------------------------------------------------------------------------------------------
             -------------
C251 COMPILER V5.60.0,  zf_common_function                                                 08/01/26  02:12:46  PAGE 4   

  173          uint32 func_str_to_uint (char *str)
  174          {
  175   1        uint32 temp = 0;                                                            // ÁÙÊ±¼ÆËã±äÁ¿
  176   1          zf_assert(str != NULL);
  177   1      
  178   1          do
  179   1          {
  180   2              if(NULL == str)
  181   2              {
  182   3                  break;
  183   3              }
  184   2      
  185   2              while(('0' <= *str) && ('9' >= *str))                                  // È·¶¨ÕâÊÇ¸öÊý×Ö
  186   2              {
  187   3                  temp = temp * 10 + ((uint8)(*str) - 0x30);                         // ¼ÆËãÊýÖµ
  188   3                  str ++;
  189   3              }
  190   2          }while(0);
  191   1      
  192   1          return temp;
  193   1      }
  194          
  195          //-------------------------------------------------------------------------------------------------------
             -------------
  196          // º¯Êý¼ò½é     ÕûÐÎÊý×Ö×ª×Ö·û´® Êý¾Ý·¶Î§ÊÇ [0,65535]
  197          // ²ÎÊýËµÃ÷     *str            ×Ö·û´®Ö¸Õë
  198          // ²ÎÊýËµÃ÷     number          ´«ÈëµÄÊý¾Ý
  199          // ·µ»Ø²ÎÊý     void
  200          // Ê¹ÓÃÊ¾Àý     func_uint_to_str(data_buffer, 300);
  201          // ±¸×¢ÐÅÏ¢     
  202          //-------------------------------------------------------------------------------------------------------
             -------------
  203          void func_uint_to_str (char *str, uint32 number)
  204          {
  205   1          int8 data_temp[16];                                                         // »º³åÇø
  206   1          uint8 temp_bit = 0;                                                              // Êý×ÖÎ»Êý
  207   1          
  208   1        zf_assert(str != NULL);
  209   1          
  210   1        do
  211   1          {
  212   2              if(NULL == str)
  213   2              {
  214   3                  break;
  215   3              }
  216   2      
  217   2              if(0 == number)                                                         // ÕâÊÇ¸ö 0
  218   2              {
  219   3                  *str = '0';
  220   3                  break;
  221   3              }
  222   2      
  223   2              while(0 != number)                                                      // Ñ­»·Ö±µ½ÊýÖµ¹éÁã
  224   2              {
  225   3                  data_temp[temp_bit ++] = (number % 10);                                  // µ¹Ðò½«ÊýÖµÌáÈ¡³öÀ
             -´
  226   3                  number /= 10;                                                       // Ï÷¼õ±»ÌáÈ¡µÄ¸öÎ»Êý
  227   3              }
  228   2              while(0 != temp_bit)                                                         // ÌáÈ¡µÄÊý×Ö¸öÊýµÝ¼
             -õ´¦Àí
  229   2              {
  230   3                  *str ++ = (data_temp[temp_bit - 1] + 0x30);                              // ½«Êý×Ö´Óµ¹ÐòÊý×éÖ
             -Ðµ¹ÐòÈ¡³ö ±ä³ÉÕýÐò·ÅÈë×Ö·û´®
  231   3                  temp_bit --;
  232   3              }
  233   2          }while(0);
C251 COMPILER V5.60.0,  zf_common_function                                                 08/01/26  02:12:46  PAGE 5   

  234   1      }
  235          
  236          //-------------------------------------------------------------------------------------------------------
             -------------
  237          // º¯Êý¼ò½é     ×Ö·û´®×ª¸¡µãÊý ÓÐÐ§ÀÛ¼Æ¾«¶ÈÎªÐ¡ÊýµãºóÁùÎ»
  238          // ²ÎÊýËµÃ÷     *str            ´«Èë×Ö·û´® ¿É´ø·ûºÅ
  239          // ·µ»Ø²ÎÊý     float           ×ª»»ºóµÄÊý¾Ý          
  240          // Ê¹ÓÃÊ¾Àý     float dat = func_str_to_float("-100.2");
  241          // ±¸×¢ÐÅÏ¢     
  242          //-------------------------------------------------------------------------------------------------------
             -------------
  243          float func_str_to_float (char *str)
  244          {
  245   1          uint8 sign = 0;                                                             // ±ê¼Ç·ûºÅ 0-ÕýÊý 1-¸ºÊý
  246   1          float temp = 0.0;                                                           // ÁÙÊ±¼ÆËã±äÁ¿ ÕûÊý²¿·Ö
  247   1          float temp_point = 0.0;                                                     // ÁÙÊ±¼ÆËã±äÁ¿ Ð¡Êý²¿·Ö
  248   1          float point_bit = 1;                                                        // Ð¡ÊýÀÛ¼Æ³ýÊý
  249   1          
  250   1        zf_assert(str != NULL);
  251   1          
  252   1        do
  253   1          {
  254   2              if(NULL == str)
  255   2              {
  256   3                  break;
  257   3              }
  258   2      
  259   2              if('-' == *str)                                                         // ¸ºÊý
  260   2              {
  261   3                  sign = 1;                                                           // ±ê¼Ç¸ºÊý
  262   3                  str ++;
  263   3              }
  264   2              else if('+' == *str)                                                    // Èç¹ûµÚÒ»¸ö×Ö·ûÊÇÕýºÅ
  265   2              {
  266   3                  str ++;
  267   3              }
  268   2      
  269   2              // ÌáÈ¡ÕûÊý²¿·Ö
  270   2              while(('0' <= *str) && ('9' >= *str))                                   // È·¶¨ÕâÊÇ¸öÊý×Ö
  271   2              {
  272   3                  temp = temp * 10 + ((uint8)(*str) - 0x30);                          // ½«ÊýÖµÌáÈ¡³öÀ´
  273   3                  str ++;
  274   3              }
  275   2              if('.' == *str)
  276   2              {
  277   3                  str ++;
  278   3                  while(('0' <= *str) && ('9' >= *str) && point_bit < 1000000.0)      // È·ÈÏÕâÊÇ¸öÊý×Ö ²¢ÇÒ¾«¶
             -È¿ØÖÆ»¹Ã»µ½ÁùÎ»
  279   3                  {
  280   4                      temp_point = temp_point * 10 + ((uint8)(*str) - 0x30);          // ÌáÈ¡Ð¡Êý²¿·ÖÊýÖµ
  281   4                      point_bit *= 10;                                                // ¼ÆËãÕâ²¿·ÖÐ¡ÊýµÄ³ýÊý
  282   4                      str ++;
  283   4                  }
  284   3                  temp_point /= point_bit;                                            // ¼ÆËãÐ¡Êý
  285   3              }
  286   2              temp += temp_point;                                                     // ½«ÊýÖµÆ´ºÏ
  287   2      
  288   2              if(sign)
  289   2              {
  290   3                  temp = -temp;
  291   3              }
  292   2          }while(0);
  293   1          return temp;
  294   1      }
  295          
  296          //-------------------------------------------------------------------------------------------------------
C251 COMPILER V5.60.0,  zf_common_function                                                 08/01/26  02:12:46  PAGE 6   

             -------------
  297          // º¯Êý¼ò½é     ¸¡µãÊý×Ö×ª×Ö·û´®
  298          // ²ÎÊýËµÃ÷     *str            ×Ö·û´®Ö¸Õë
  299          // ²ÎÊýËµÃ÷     number          ´«ÈëµÄÊý¾Ý
  300          // ²ÎÊýËµÃ÷     point_bit       Ð¡Êýµã¾«¶È
  301          // ·µ»Ø²ÎÊý     void
  302          // Ê¹ÓÃÊ¾Àý     func_float_to_str(data_buffer, 3.1415, 2);                      // ½á¹ûÊä³ö data_buffer =
             - "3.14"
  303          // ±¸×¢ÐÅÏ¢     
  304          //-------------------------------------------------------------------------------------------------------
             -------------
  305          void func_float_to_str (char *str, float number, uint8 point_bit)
  306          {
  307   1          int data_int = 0;                                                           // ÕûÊý²¿·Ö
  308   1          int data_float = 0.0;                                                       // Ð¡Êý²¿·Ö
  309   1          int data_temp[8];                                                           // ÕûÊý×Ö·û»º³å
  310   1          int data_temp_point[6];                                                     // Ð¡Êý×Ö·û»º³å
  311   1          uint8 temp_bit = point_bit;                                                      // ×ª»»¾«¶ÈÎ»Êý
  312   1          
  313   1        zf_assert(str != NULL);
  314   1          
  315   1        do
  316   1          {
  317   2              if(NULL == str)
  318   2              {
  319   3                  break;
  320   3              }
  321   2      
  322   2              // ÌáÈ¡ÕûÊý²¿·Ö
  323   2              data_int = (int)number;                                                 // Ö±½ÓÇ¿ÖÆ×ª»»Îª int
  324   2              if(0 > number)                                                          // ÅÐ¶ÏÔ´Êý¾ÝÊÇÕýÊý»¹ÊÇ¸º
             -Êý
  325   2              {
  326   3                  *str ++ = '-';
  327   3              }
  328   2              else if(0.0 == number)                                                  // Èç¹ûÊÇ¸ö 0
  329   2              {
  330   3                  *str ++ = '0';
  331   3                  *str ++ = '.';
  332   3                  *str = '0';
  333   3                  break;
  334   3              }
  335   2      
  336   2              // ÌáÈ¡Ð¡Êý²¿·Ö
  337   2              number = number - data_int;                                             // ¼õÈ¥ÕûÊý²¿·Ö¼´¿É
  338   2              while(temp_bit --)
  339   2              {
  340   3                  number = number * 10;                                               // ½«ÐèÒªµÄÐ¡ÊýÎ»ÊýÌáÈ¡µ½
             -ÕûÊý²¿·Ö
  341   3              }
  342   2              data_float = (int)number;                                               // »ñÈ¡Õâ²¿·ÖÊýÖµ
  343   2      
  344   2              // ÕûÊý²¿·Ö×ªÎª×Ö·û´®
  345   2              temp_bit = 0;
  346   2              do
  347   2              {
  348   3                  data_temp[temp_bit ++] = data_int % 10;                                  // ½«ÕûÊý²¿·Öµ¹ÐòÐ´È
             -ë×Ö·û»º³åÇø
  349   3                  data_int /= 10;
  350   3              }while(0 != data_int);
  351   2              while(0 != temp_bit)
  352   2              {
  353   3                  *str ++ = (func_abs(data_temp[temp_bit - 1]) + 0x30);                    // ÔÙµ¹Ðò½«µ¹ÐòµÄÊýÖ
             -µÐ´Èë×Ö·û´® µÃµ½ÕýÐòÊýÖµ
  354   3                  temp_bit --;
  355   3              }
C251 COMPILER V5.60.0,  zf_common_function                                                 08/01/26  02:12:46  PAGE 7   

  356   2      
  357   2              // Ð¡Êý²¿·Ö×ªÎª×Ö·û´®
  358   2              if(point_bit != 0)
  359   2              {
  360   3                  temp_bit = 0;
  361   3                  *str ++ = '.';
  362   3                  if(0 == data_float)
  363   3                  {
  364   4                      *str = '0';
  365   4                  }
  366   3                  else
  367   3                  {
  368   4                      while(0 != point_bit)                                           // ÅÐ¶ÏÓÐÐ§Î»Êý
  369   4                      {
  370   5                          data_temp_point[temp_bit ++] = data_float % 10;                  // µ¹ÐòÐ´Èë×Ö·û»º³åÇ
             -ø
  371   5                          data_float /= 10;
  372   5                          point_bit --;                                                
  373   5                      }
  374   4                      while(0 != temp_bit)
  375   4                      {
  376   5                          *str ++ = (func_abs(data_temp_point[temp_bit - 1]) + 0x30);      // ÔÙµ¹Ðò½«µ¹ÐòµÄÊýÖ
             -µÐ´Èë×Ö·û´® µÃµ½ÕýÐòÊýÖµ
  377   5                          temp_bit --;
  378   5                      }
  379   4                  }
  380   3              }
  381   2          }while(0);
  382   1      }
  383          
  384          //-------------------------------------------------------------------------------------------------------
             -------------
  385          // º¯Êý¼ò½é     ×Ö·û´®×ª¸¡µãÊý ÓÐÐ§ÀÛ¼Æ¾«¶ÈÎªÐ¡Êýµãºó¾ÅÎ»
  386          // ²ÎÊýËµÃ÷     str             ´«Èë×Ö·û´® ¿É´ø·ûºÅ
  387          // ·µ»Ø²ÎÊý     double          ×ª»»ºóµÄÊý¾Ý          
  388          // Ê¹ÓÃÊ¾Àý     double dat = func_str_to_double("-100.2");
  389          // ±¸×¢ÐÅÏ¢     
  390          //-------------------------------------------------------------------------------------------------------
             -------------
  391          double func_str_to_double (char *str)
  392          {
  393   1          uint8 sign = 0;                                                             // ±ê¼Ç·ûºÅ 0-ÕýÊý 1-¸ºÊý
  394   1          double temp = 0.0;                                                          // ÁÙÊ±¼ÆËã±äÁ¿ ÕûÊý²¿·Ö
  395   1          double temp_point = 0.0;                                                    // ÁÙÊ±¼ÆËã±äÁ¿ Ð¡Êý²¿·Ö
  396   1          double point_bit = 1;                                                       // Ð¡ÊýÀÛ¼Æ³ýÊý
  397   1          
  398   1        zf_assert(str != NULL);
  399   1          
  400   1        do
  401   1          {
  402   2              if(NULL == str)
  403   2              {
  404   3                  break;
  405   3              }
  406   2      
  407   2              if('-' == *str)                                                         // ¸ºÊý
  408   2              {
  409   3                  sign = 1;                                                           // ±ê¼Ç¸ºÊý
  410   3                  str ++;
  411   3              }
  412   2              else if('+' == *str)                                                    // Èç¹ûµÚÒ»¸ö×Ö·ûÊÇÕýºÅ
  413   2              {
  414   3                  str ++;
  415   3              }
  416   2      
  417   2              // ÌáÈ¡ÕûÊý²¿·Ö
C251 COMPILER V5.60.0,  zf_common_function                                                 08/01/26  02:12:46  PAGE 8   

  418   2              while(('0' <= *str) && ('9' >= *str))                                   // È·¶¨ÕâÊÇ¸öÊý×Ö
  419   2              {
  420   3                  temp = temp * 10 + ((uint8)(*str) - 0x30);                          // ½«ÊýÖµÌáÈ¡³öÀ´
  421   3                  str ++;
  422   3              }
  423   2              if('.' == *str)
  424   2              {
  425   3                  str ++;
  426   3                  while(('0' <= *str) && ('9' >= *str) && point_bit < 1000000000.0)   // È·ÈÏÕâÊÇ¸öÊý×Ö ²¢ÇÒ¾«¶
             -È¿ØÖÆ»¹Ã»µ½¾ÅÎ»
  427   3                  {
  428   4                      temp_point = temp_point * 10 + ((uint8)(*str) - 0x30);          // ÌáÈ¡Ð¡Êý²¿·ÖÊýÖµ
  429   4                      point_bit *= 10;                                                // ¼ÆËãÕâ²¿·ÖÐ¡ÊýµÄ³ýÊý
  430   4                      str ++;
  431   4                  }
  432   3                  temp_point /= point_bit;                                            // ¼ÆËãÐ¡Êý
  433   3              }
  434   2              temp += temp_point;                                                     // ½«ÊýÖµÆ´ºÏ
  435   2      
  436   2              if(sign)
  437   2              {
  438   3                  temp = -temp;
  439   3              }
  440   2          }while(0);
  441   1          return temp;
  442   1      
  443   1      }
  444          
  445          //-------------------------------------------------------------------------------------------------------
             -------------
  446          // º¯Êý¼ò½é     ¸¡µãÊý×Ö×ª×Ö·û´®
  447          // ²ÎÊýËµÃ÷     *str            ×Ö·û´®Ö¸Õë
  448          // ²ÎÊýËµÃ÷     number          ´«ÈëµÄÊý¾Ý
  449          // ²ÎÊýËµÃ÷     point_bit       Ð¡Êýµã¾«¶È
  450          // ·µ»Ø²ÎÊý     void
  451          // Ê¹ÓÃÊ¾Àý     func_double_to_str(data_buffer, 3.1415, 2);                     // ½á¹ûÊä³ö data_buffer =
             - "3.14"
  452          // ±¸×¢ÐÅÏ¢     
  453          //-------------------------------------------------------------------------------------------------------
             -------------
  454          void func_double_to_str (char *str, double number, uint8 point_bit)
  455          {
  456   1          int data_int = 0;                                                           // ÕûÊý²¿·Ö
  457   1          int data_float = 0.0;                                                       // Ð¡Êý²¿·Ö
  458   1          int data_temp[12];                                                          // ÕûÊý×Ö·û»º³å
  459   1          int data_temp_point[9];                                                     // Ð¡Êý×Ö·û»º³å
  460   1          uint8 temp_bit = point_bit;                                                      // ×ª»»¾«¶ÈÎ»Êý
  461   1          
  462   1        zf_assert(str != NULL);
  463   1          
  464   1        do
  465   1          {
  466   2              if(NULL == str)
  467   2              {
  468   3                  break;
  469   3              }
  470   2      
  471   2              // ÌáÈ¡ÕûÊý²¿·Ö
  472   2              data_int = (int)number;                                                 // Ö±½ÓÇ¿ÖÆ×ª»»Îª int
  473   2              if(0 > number)                                                          // ÅÐ¶ÏÔ´Êý¾ÝÊÇÕýÊý»¹ÊÇ¸º
             -Êý
  474   2              {
  475   3                  *str ++ = '-';
  476   3              }
  477   2              else if(0.0 == number)                                                  // Èç¹ûÊÇ¸ö 0
  478   2              {
C251 COMPILER V5.60.0,  zf_common_function                                                 08/01/26  02:12:46  PAGE 9   

  479   3                  *str ++ = '0';
  480   3                  *str ++ = '.';
  481   3                  *str = '0';
  482   3                  break;
  483   3              }
  484   2      
  485   2              // ÌáÈ¡Ð¡Êý²¿·Ö
  486   2              number = number - data_int;                                             // ¼õÈ¥ÕûÊý²¿·Ö¼´¿É
  487   2              while(temp_bit --)
  488   2              {
  489   3                  number = number * 10;                                               // ½«ÐèÒªµÄÐ¡ÊýÎ»ÊýÌáÈ¡µ½
             -ÕûÊý²¿·Ö
  490   3              }
  491   2              data_float = (int)number;                                               // »ñÈ¡Õâ²¿·ÖÊýÖµ
  492   2      
  493   2              // ÕûÊý²¿·Ö×ªÎª×Ö·û´®
  494   2              temp_bit = 0;
  495   2              do
  496   2              {
  497   3                  data_temp[temp_bit ++] = data_int % 10;                                  // ½«ÕûÊý²¿·Öµ¹ÐòÐ´È
             -ë×Ö·û»º³åÇø
  498   3                  data_int /= 10;
  499   3              }while(0 != data_int);
  500   2              while(0 != temp_bit)
  501   2              {
  502   3                  *str ++ = (func_abs(data_temp[temp_bit - 1]) + 0x30);                    // ÔÙµ¹Ðò½«µ¹ÐòµÄÊýÖ
             -µÐ´Èë×Ö·û´® µÃµ½ÕýÐòÊýÖµ
  503   3                  temp_bit --;
  504   3              }
  505   2      
  506   2              // Ð¡Êý²¿·Ö×ªÎª×Ö·û´®
  507   2              if(point_bit != 0)
  508   2              {
  509   3                  temp_bit = 0;
  510   3                  *str ++ = '.';
  511   3                  if(0 == data_float)
  512   3                      *str = '0';
  513   3                  else
  514   3                  {
  515   4                      while(0 != point_bit)                                           // ÅÐ¶ÏÓÐÐ§Î»Êý
  516   4                      {
  517   5                          data_temp_point[temp_bit ++] = data_float % 10;                  // µ¹ÐòÐ´Èë×Ö·û»º³åÇ
             -ø
  518   5                          data_float /= 10;
  519   5                          point_bit --;                                                
  520   5                      }
  521   4                      while(0 != temp_bit)
  522   4                      {
  523   5                          *str ++ = (func_abs(data_temp_point[temp_bit - 1]) + 0x30);      // ÔÙµ¹Ðò½«µ¹ÐòµÄÊýÖ
             -µÐ´Èë×Ö·û´® µÃµ½ÕýÐòÊýÖµ
  524   5                          temp_bit --;
  525   5                      }
  526   4                  }
  527   3              }
  528   2          }while(0);
  529   1      }
  530          
  531          //-------------------------------------------------------------------------------------------------------
             -------------
  532          // º¯Êý¼ò½é     ×Ö·û´®×ª Hex
  533          // ²ÎÊýËµÃ÷     str             ´«Èë×Ö·û´® ÎÞ·ûºÅ
  534          // ·µ»Ø²ÎÊý     uint32          ×ª»»ºóµÄÊý¾Ý
  535          // Ê¹ÓÃÊ¾Àý     uint32 dat = func_str_to_hex("0x11");
  536          // ±¸×¢ÐÅÏ¢     
  537          //-------------------------------------------------------------------------------------------------------
             -------------
C251 COMPILER V5.60.0,  zf_common_function                                                 08/01/26  02:12:46  PAGE 10  

  538          uint32 func_str_to_hex (char *str)
  539          {
  540   1          uint32 str_len = strlen(str);                                               // ×Ö·û´®³¤
  541   1          uint32 result_data = 0;                                                     // ½á¹û»º´æ
  542   1          uint8 temp = 0;                                                             // ¼ÆËã±äÁ¿
  543   1          uint8 flag = 0;                                                             // ±êÖ¾Î»
  544   1      
  545   1        zf_assert(str != NULL);
  546   1        
  547   1          do
  548   1          {
  549   2              if(NULL == str)
  550   2              {
  551   3                  break;
  552   3              }
  553   2      
  554   2              if(flag)
  555   2              {
  556   3                  if(('a' <= *str) && ('f' >= *str))
  557   3                  {
  558   4                      temp = (*str - 87);
  559   4                  }
  560   3                  else if(('A' <= *str) && ('F' >= *str))
  561   3                  {
  562   4                      temp = (*str - 55);
  563   4                  }
  564   3                  else if(('0' <= *str) && ('9' >= *str))
  565   3                  {
  566   4                      temp = (*str - 48);
  567   4                  }
  568   3                  else
  569   3                  {
  570   4                      break;
  571   4                  }
  572   3                  result_data = ((result_data << 4) | (temp & 0x0F));
  573   3              }
  574   2              else
  575   2              {
  576   3      //            if(strncmp("0x", str, 2))
  577   3                  if((*str == '0') && (*(str + 1) == 'x'))
  578   3                  {
  579   4                      str ++;
  580   4                      flag = 1;
  581   4                  }
  582   3              }
  583   2              str ++;
  584   2          }while(str_len --);
  585   1      
  586   1          return result_data;
  587   1      }
  588          
  589          //-------------------------------------------------------------------------------------------------------
             -------------
  590          // º¯Êý¼ò½é     Hex ×ª×Ö·û´®
  591          // ²ÎÊýËµÃ÷     *str            ×Ö·û´®Ö¸Õë
  592          // ²ÎÊýËµÃ÷     number          ´«ÈëµÄÊý¾Ý
  593          // ·µ»Ø²ÎÊý     void
  594          // Ê¹ÓÃÊ¾Àý     func_hex_to_str(data_buffer, 0x11);                             // ½á¹ûÊä³ö data_buffer =
             - "0x11"
  595          // ±¸×¢ÐÅÏ¢     
  596          //-------------------------------------------------------------------------------------------------------
             -------------
  597          void func_hex_to_str (char *str, uint32 number)
  598          {
  599   1          const char hex_index[16] = {
  600   1              '0', '1', '2', '3',
C251 COMPILER V5.60.0,  zf_common_function                                                 08/01/26  02:12:46  PAGE 11  

  601   1              '4', '5', '6', '7',
  602   1              '8', '9', 'A', 'B',
  603   1              'C', 'D', 'E', 'F'};
  604   1          int8 data_temp[12];                                                         // »º³åÇø
  605   1          uint8 temp_bit = 0;                                                              // Êý×ÖÎ»Êý
  606   1      
  607   1          zf_assert(str != NULL);
  608   1          
  609   1          *str++ = '0';
  610   1          *str++ = 'x';
  611   1          do
  612   1          {
  613   2              if(NULL == str)
  614   2              {
  615   3                  break;
  616   3              }
  617   2      
  618   2              if(0 == number)                                                         // ÕâÊÇ¸ö 0
  619   2              {
  620   3                  *str = '0';
  621   3                  break;
  622   3              }
  623   2      
  624   2              while(0 != number)                                                      // Ñ­»·Ö±µ½ÊýÖµ¹éÁã
  625   2              {
  626   3                  data_temp[temp_bit ++] = (number & 0xF);                                 // µ¹Ðò½«ÊýÖµÌáÈ¡³öÀ
             -´
  627   3                  number >>= 4;                                                       // Ï÷¼õ±»ÌáÈ¡µÄ¸öÎ»Êý
  628   3              }
  629   2              while(0 != temp_bit)                                                         // ÌáÈ¡µÄÊý×Ö¸öÊýµÝ¼
             -õ´¦Àí
  630   2              {
  631   3                  *str ++ = hex_index[data_temp[temp_bit - 1]];                            // ½«Êý×Ö´Óµ¹ÐòÊý×éÖ
             -Ðµ¹ÐòÈ¡³ö ±ä³ÉÕýÐò·ÅÈë×Ö·û´®
  632   3                  temp_bit --;
  633   3              }
  634   2          }while(0);
  635   1      }
  636          
  637          //-------------------------------------------------------------------------------------------------------
             -------------
  638          // º¯Êý¼ò½é     Êý×Ö×ª»»Îª ASCII Öµ
  639          // ²ÎÊýËµÃ÷     dat             ´«ÈëµÄÊý¾Ý
  640          // ²ÎÊýËµÃ÷     *p              Êý¾Ý»º³å
  641          // ²ÎÊýËµÃ÷     neg_type        Êý¾ÝÀàÐÍ
  642          // ²ÎÊýËµÃ÷     radix           ½øÖÆ
  643          // ·µ»Ø²ÎÊý     uint8           Êý¾Ý
  644          // Ê¹ÓÃÊ¾Àý     number_conversion_ascii((uint32)ival, vstr, 1, 10);
  645          // ±¸×¢ÐÅÏ¢     ±¾º¯ÊýÔÚÎÄ¼þÄÚ²¿µ÷ÓÃ ÓÃ»§²»ÓÃ¹Ø×¢ Ò²²»¿ÉÐÞ¸Ä
  646          //-------------------------------------------------------------------------------------------------------
             -------------
  647          static uint8 number_conversion_ascii (uint32 dat, int8 *p, uint8 neg_type, uint8 radix)
  648          {
  649   1          int32   neg_dat;
  650   1          uint32  pos_dat;
  651   1          uint8   temp_data = 0;
  652   1          uint8   valid_num = 0;
  653   1      
  654   1          if(neg_type)
  655   1          {
  656   2              neg_dat = (int32)dat;
  657   2              if(0 > neg_dat)
  658   2              {
  659   3                  neg_dat = -neg_dat;
  660   3              }
  661   2              while(1)
C251 COMPILER V5.60.0,  zf_common_function                                                 08/01/26  02:12:46  PAGE 12  

  662   2              {
  663   3                  *p = neg_dat%radix + '0';
  664   3                  neg_dat = neg_dat/radix;
  665   3                  valid_num ++;
  666   3      
  667   3                  if(!neg_dat)
  668   3                  {
  669   4                      break;
  670   4                  }
  671   3                  p ++;
  672   3              }
  673   2          }
  674   1          else
  675   1          {
  676   2              pos_dat = dat;
  677   2              while(1)
  678   2              {
  679   3                  temp_data = pos_dat%radix;
  680   3                  if(10 <= temp_data)
  681   3                  {
  682   4                      temp_data += 'A'-10;
  683   4                  }
  684   3                  else
  685   3                  {
  686   4                      temp_data += '0';
  687   4                  }
  688   3      
  689   3                  *p = temp_data;
  690   3      
  691   3                  pos_dat = pos_dat/radix;
  692   3                  valid_num ++;
  693   3      
  694   3                  if(!pos_dat)
  695   3                  {
  696   4                      break;
  697   4                  }
  698   3                  p ++;
  699   3              }
  700   2          }
  701   1          return valid_num;
  702   1      }
  703          
  704          //-------------------------------------------------------------------------------------------------------
             -------------
  705          // º¯Êý¼ò½é     printf ÏÔÊ¾×ª»»
  706          // ²ÎÊýËµÃ÷     *d_buff         »º³åÇø
  707          // ²ÎÊýËµÃ÷     len             ³¤¶È
  708          // ·µ»Ø²ÎÊý     void
  709          // Ê¹ÓÃÊ¾Àý     printf_reverse_order(vstr, vlen);
  710          // ±¸×¢ÐÅÏ¢     ±¾º¯ÊýÔÚÎÄ¼þÄÚ²¿µ÷ÓÃ ÓÃ»§²»ÓÃ¹Ø×¢ Ò²²»¿ÉÐÞ¸Ä
  711          //-------------------------------------------------------------------------------------------------------
             -------------
  712          static void printf_reverse_order (int8 *d_buff, uint32 len)
  713          {
  714   1          uint32 i;
  715   1          int8  temp_data;
  716   1          for(i = 0; len / 2 > i; i ++)
  717   1          {
  718   2              temp_data = d_buff[len - 1 - i];
  719   2              d_buff[len - 1 -i ] = d_buff[i];
  720   2              d_buff[i] = temp_data; 
  721   2          }
  722   1      }
  723          
  724          
  725          
C251 COMPILER V5.60.0,  zf_common_function                                                 08/01/26  02:12:46  PAGE 13  

  726          //-------------------------------------------------------------------------------------------------------
             -------------
  727          // º¯Êý¼ò½é     sprintf º¯ÊýÊµÏÖ
  728          // ²ÎÊýËµÃ÷     *buffer         »º³åÇø
  729          // ²ÎÊýËµÃ÷   siz       ´óÐ¡
  730          // ²ÎÊýËµÃ÷     *format         Ô´×Ö·û´®
  731          // ²ÎÊýËµÃ÷     args            ¿É±ä²ÎÊýÁÐ±í
  732          // ·µ»Ø²ÎÊý     int32          ´¦ÀíºóÊý¾Ý³¤
  733          // Ê¹ÓÃÊ¾Àý     zf_sprintf(buff, "Data : %d", 100);
  734          // ±¸×¢ÐÅÏ¢     ±¾º¯ÊýÔÚÎÄ¼þÄÚ²¿µ÷ÓÃ ÓÃ»§²»ÓÃ¹Ø×¢ Ò²²»¿ÉÐÞ¸Ä
  735          //-------------------------------------------------------------------------------------------------------
             -------------
  736          int32 vsnprintf(char *buffer, uint32 siz, const char *format, va_list args) 
  737          {
  738   1          uint32 i;
  739   1          char *ptr;
  740   1          int j;
  741   1          int num;
  742   1          char temp[16];
  743   1          int len;
  744   1          int is_negative;
  745   1          char *str;
  746   1          uint32 num_x;
  747   1          char temp_x[9];
  748   1          const char hex_digits[] = "0123456789abcdef";
  749   1      
  750   1          i = 0;
  751   1          ptr = buffer;
  752   1          
  753   1          if (buffer == NULL || format == NULL || siz == 0)
  754   1        {
  755   2              return 0;
  756   2          }
  757   1          
  758   1          while (*format != '\0' && i < siz - 1) 
  759   1        {
  760   2              if (*format != '%') 
  761   2          {
  762   3                  *ptr++ = *format++;
  763   3                  i++;
  764   3                  continue;
  765   3              }
  766   2      
  767   2              /* ´¦Àí¸ñÊ½·û */
  768   2              format++;
  769   2              switch (*format) 
  770   2          {
  771   3                  case 'd':
  772   3                      num = va_arg(args, int);
  773   3                      len = 0;
  774   3                      is_negative = 0;
  775   3      
  776   3                      if (num < 0) 
  777   3              {
  778   4                          is_negative = 1;
  779   4                          num = -num;
  780   4                      }
  781   3      
  782   3                      /* Êý×Ö×ª×Ö·û´® */
  783   3                      do {
  784   4                          temp[len++] = '0' + (num % 10);
  785   4                          num /= 10;
  786   4                      } while (num > 0 && len < (int)sizeof(temp) - 1);
  787   3      
  788   3                      /* Ìí¼Ó¸ººÅ */
  789   3                      if (is_negative) 
C251 COMPILER V5.60.0,  zf_common_function                                                 08/01/26  02:12:46  PAGE 14  

  790   3              {
  791   4                          temp[len++] = '-';
  792   4                      }
  793   3      
  794   3                      /* ·´×ª×Ö·û´® */
  795   3                      for (j = 0; j < len / 2; j++) 
  796   3              {
  797   4                          char t = temp[j];
  798   4                          temp[j] = temp[len - j - 1];
  799   4                          temp[len - j - 1] = t;
  800   4                      }
  801   3      
  802   3                      /* ¸´ÖÆµ½»º³åÇø */
  803   3                      for (j = 0; j < len && i < siz - 1; j++) 
  804   3              {
  805   4                          *ptr++ = temp[j];
  806   4                          i++;
  807   4                      }
  808   3                      break;
  809   3      
  810   3                  case 's':
  811   3                      str = va_arg(args, char*);
  812   3                      if (str == NULL) 
  813   3              {
  814   4                          str = "(null)";
  815   4                      }
  816   3                      
  817   3                      while (*str != '\0' && i < siz - 1) 
  818   3              {
  819   4                          *ptr++ = *str++;
  820   4                          i++;
  821   4                      }
  822   3                      break;
  823   3      
  824   3                  case 'c':
  825   3                      *ptr++ = (char)va_arg(args, int);
  826   3                      i++;
  827   3                      break;
  828   3      
  829   3                  case 'x':
  830   3                      num_x = va_arg(args, uint32);
  831   3                      len = 0;
  832   3      
  833   3                      do {
  834   4                          temp_x[len++] = hex_digits[num_x % 16];
  835   4                          num_x /= 16;
  836   4                      } while (num_x > 0 && len < (int)sizeof(temp_x) - 1);
  837   3      
  838   3                      /* ·´×ª×Ö·û´® */
  839   3                      for (j = 0; j < len / 2; j++) 
  840   3              {
  841   4                          char t = temp_x[j];
  842   4                          temp_x[j] = temp_x[len - j - 1];
  843   4                          temp_x[len - j - 1] = t;
  844   4                      }
  845   3      
  846   3                      /* ¸´ÖÆµ½»º³åÇø */
  847   3                      for (j = 0; j < len && i < siz - 1; j++) 
  848   3              {
  849   4                          *ptr++ = temp_x[j];
  850   4                          i++;
  851   4                      }
  852   3                      break;
  853   3      
  854   3                  default:
  855   3                      *ptr++ = *format;
C251 COMPILER V5.60.0,  zf_common_function                                                 08/01/26  02:12:46  PAGE 15  

  856   3                      i++;
  857   3                      break;
  858   3              }
  859   2              format++;
  860   2          }
  861   1      
  862   1          *ptr = '\0';  /* È·±£×Ö·û´®½áÊø */
  863   1          return (int32)i;
  864   1      }
  865          
  866          //-------------------------------------------------------------------------------------------------------
             -------------
  867          // º¯Êý¼ò½é     sprintf º¯ÊýÊµÏÖ
  868          // ²ÎÊýËµÃ÷     *buff           »º³åÇø
  869          // ²ÎÊýËµÃ÷     *format         Ô´×Ö·û´®
  870          // ²ÎÊýËµÃ÷     ...             ¿É±ä²ÎÊýÁÐ±í
  871          // ·µ»Ø²ÎÊý     uint32          ´¦ÀíºóÊý¾Ý³¤
  872          // Ê¹ÓÃÊ¾Àý     zf_sprintf(buff, "Data : %d", 100);
  873          // ±¸×¢ÐÅÏ¢     ±¾º¯ÊýÔÚÎÄ¼þÄÚ²¿µ÷ÓÃ ÓÃ»§²»ÓÃ¹Ø×¢ Ò²²»¿ÉÐÞ¸Ä
  874          //-------------------------------------------------------------------------------------------------------
             -------------
  875          uint32 zf_sprintf (int8 *buff, const int8 *format, ...)
  876          {
  877   1          uint32 buff_len = 0;
  878   1        va_list arg;
  879   1        va_start(arg, format);
  880   1      
  881   1          while (*format)
  882   1          {
  883   2              int8 ret = *format;
  884   2              if ('%' == ret)
  885   2              {
  886   3                  switch (*++ format)
  887   3                  {
  888   4                      case 'a':// Ê®Áù½øÖÆp¼ÆÊý·¨Êä³ö¸¡µãÊý ÔÝÎ´ÊµÏÖ
  889   4                          {
  890   5                          }
  891   4                          break;
  892   4      
  893   4                      case 'c':// Ò»¸ö×Ö·û
  894   4                          {
  895   5                              int8 ch = (int8)va_arg(arg, uint32);
  896   5                              *buff = ch;
  897   5                              buff ++;
  898   5                              buff_len ++;
  899   5                          }
  900   4                          break;
  901   4      
  902   4                      case 'd':
  903   4                      case 'i':// ÓÐ·ûºÅÊ®½øÖÆÕûÊý
  904   4                          {
  905   5                              int8 vstr[33];
  906   5                              int32 ival = (int32)va_arg(arg, int32);
  907   5                              uint8 vlen = number_conversion_ascii((uint32)ival, vstr, 1, 10);
  908   5      
  909   5                              if(0 > ival)  
  910   5                              {
  911   6                                  vstr[vlen] = '-';
  912   6                                  vlen ++;
  913   6                              }
  914   5                              printf_reverse_order(vstr, vlen);
  915   5                              memcpy(buff, vstr, vlen);
  916   5                              buff += vlen;
  917   5                              buff_len += vlen;
  918   5                          }
  919   4                          break;
C251 COMPILER V5.60.0,  zf_common_function                                                 08/01/26  02:12:46  PAGE 16  

  920   4      
  921   4                      case 'f':// ¸¡µãÊý£¬Êä³öÐ¡ÊýµãºóÁùÎ»  ²»ÄÜÖ¸¶¨Êä³ö¾«¶È
  922   4                      case 'F':// ¸¡µãÊý£¬Êä³öÐ¡ÊýµãºóÁùÎ»  ²»ÄÜÖ¸¶¨Êä³ö¾«¶È
  923   4                      {
  924   5                          int8 vstr[33];
  925   5                          double ival = (double)va_arg(arg, double);
  926   5                          uint8 vlen = number_conversion_ascii((uint32)(int32)ival, vstr, 1, 10);
  927   5      
  928   5                          if(0 > ival)  
  929   5                          {
  930   6                              vstr[vlen] = '-';
  931   6                              vlen ++;
  932   6                          }
  933   5                          printf_reverse_order(vstr, vlen);
  934   5                          memcpy(buff, vstr, vlen);
  935   5                          buff += vlen;
  936   5                          buff_len += vlen;
  937   5      
  938   5                          ival = ((double)ival - (int32)ival)*1000000;
  939   5                          if(ival)
  940   5                          {
  941   6                              vlen = number_conversion_ascii((uint32)(int32)ival, vstr, 1, 10);
  942   6                          }
  943   5                          else
  944   5                          {
  945   6                              vstr[0] = vstr[1] = vstr[2] = vstr[3] = vstr[4] = vstr[5] = '0';
  946   6                              vlen = 6;
  947   6                          }
  948   5      
  949   5                          while(6 > vlen)
  950   5                          {
  951   6                              vstr[vlen] = '0';
  952   6                              vlen ++;
  953   6                          }
  954   5      
  955   5                          vstr[vlen] = '.';
  956   5                          vlen ++;
  957   5      
  958   5                          printf_reverse_order(vstr, vlen);
  959   5                          memcpy(buff, vstr, vlen);
  960   5                          buff += vlen;
  961   5                          buff_len += vlen;
  962   5                      }
  963   4                      break;
  964   4      
  965   4                      case 'u':// ÎÞ·ûºÅÊ®½øÖÆÕûÊý
  966   4                          {
  967   5                              int8 vstr[33];
  968   5                              uint32 ival = (uint32)va_arg(arg, uint32);
  969   5                              uint8 vlen = number_conversion_ascii(ival, vstr, 0, 10);
  970   5      
  971   5                              printf_reverse_order(vstr, vlen);
  972   5                              memcpy(buff, vstr, vlen);
  973   5                              buff += vlen;
  974   5                              buff_len += vlen;
  975   5                          }
  976   4                          break;
  977   4      
  978   4                      case 'o':// ÎÞ·ûºÅ°Ë½øÖÆÕûÊý 
  979   4                          {
  980   5                              int8 vstr[33];
  981   5                              uint32 ival = (uint32)va_arg(arg, uint32);
  982   5                              uint8 vlen = number_conversion_ascii(ival, vstr, 0, 8);
  983   5      
  984   5                              printf_reverse_order(vstr, vlen);
  985   5                              memcpy(buff, vstr, vlen);
C251 COMPILER V5.60.0,  zf_common_function                                                 08/01/26  02:12:46  PAGE 17  

  986   5                              buff += vlen;
  987   5                              buff_len += vlen;
  988   5      
  989   5                          }
  990   4                          break;
  991   4      
  992   4                      case 'x':// ÎÞ·ûºÅÊ®Áù½øÖÆÕûÊý
  993   4                      case 'X':// ÎÞ·ûºÅÊ®Áù½øÖÆÕûÊý
  994   4                          {
  995   5                              int8 vstr[33];
  996   5                              uint32 ival = (uint32)va_arg(arg, uint32);
  997   5                              uint8 vlen = number_conversion_ascii(ival, vstr, 0, 16);
  998   5      
  999   5                              printf_reverse_order(vstr, vlen);
 1000   5                              memcpy(buff, vstr, vlen);
 1001   5                              buff += vlen;
 1002   5                              buff_len += vlen;
 1003   5                          }
 1004   4                          break;
 1005   4      
 1006   4                      case 's':// ×Ö·û´®
 1007   4                          {
 1008   5                              int8 *pc = va_arg(arg, int8 *);
 1009   5                              while (*pc)
 1010   5                              {
 1011   6                                  *buff = *pc;
 1012   6                                  buff ++;
 1013   6                                  buff_len ++;
 1014   6                                  pc ++;
 1015   6                              }
 1016   5                          }
 1017   4                          break;
 1018   4      
 1019   4                      case 'p':// ÒÔ16½øÖÆÐÎÊ½Êä³öÖ¸Õë
 1020   4                          {
 1021   5                              int8 vstr[33];
 1022   5                              uint32 ival = (uint32)va_arg(arg, uint32);
 1023   5                              //uint8 vlen = number_conversion_ascii(ival, vstr, 0, 16);
 1024   5                              number_conversion_ascii(ival, vstr, 0, 16);
 1025   5                              printf_reverse_order(vstr, 8);
 1026   5                              memcpy(buff, vstr, 8);
 1027   5                              buff += 8;
 1028   5                              buff_len += 8;
 1029   5                          }
 1030   4                          break;
 1031   4      
 1032   4                      case '%':// Êä³ö×Ö·û% 
 1033   4                          {
 1034   5                              *buff = '%';
 1035   5                              buff ++;
 1036   5                              buff_len ++;
 1037   5                          }
 1038   4                          break;
 1039   4      
 1040   4                      default:
 1041   4                          break;
 1042   4                  }
 1043   3              }
 1044   2              else
 1045   2              {
 1046   3                  *buff = (int8)(*format);
 1047   3                  buff ++;
 1048   3                  buff_len ++;
 1049   3              }
 1050   2              format ++;
 1051   2          }
C251 COMPILER V5.60.0,  zf_common_function                                                 08/01/26  02:12:46  PAGE 18  

 1052   1          va_end(arg);
 1053   1      
 1054   1          return buff_len;
 1055   1      }
 1056          
 1057          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      6106     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------        379
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        87     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
